
(define-library (chibi uri)
  (export uri? uri->string make-uri string->uri string->path-uri uri-has-scheme?
          uri-scheme uri-user uri-host uri-port uri-path uri-query uri-fragment
          uri-with-scheme uri-with-user uri-with-host uri-with-path
          uri-with-query uri-with-fragment uri-resolve
          uri-encode uri-decode uri-query->alist uri-alist->query)
  (import (chibi) (chibi string) (chibi pathname) (srfi 9))
  (include "uri.scm"))

(define-library (chibi binary-record)
  (import (scheme base)
          (srfi 1) (srfi 9) (srfi 33)
          (chibi io) (chibi string)
          (only (chibi) identifier? er-macro-transformer))
  (export define-binary-record-type)
  (include "binary-record.scm"))

(define-library (chibi test)
  (export
   test test-equal test-error test-assert test-not test-values
   test-group current-test-group
   test-begin test-end test-syntax-error test-propagate-info
   test-vars test-run test-exit
   current-test-verbosity current-test-epsilon current-test-comparator
   current-test-applier current-test-handler current-test-skipper
   current-test-group-reporter test-failure-count
   current-test-epsilon current-test-comparator)
  (import (scheme write)
          (scheme complex)
          (scheme process-context)
          (scheme time)
          (chibi term ansi))
  (cond-expand
   (chibi
    (import (except (scheme base) guard)
            (rename (only (chibi) pair-source print-exception protect)
                    (protect guard))))
   (else
    (import (scheme base))
    (begin
      (define (pair-source x) #f)
      (define print-exception write))))
  (include "test.scm"))
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A general, non-filesystem-specific pathname library.

;; POSIX basename
;; (define (path-strip-directory path)
;;   (if (string=? path "")
;;       path
;;       (let ((end (string-skip-right path #\/)))
;;         (if (zero? end)
;;             "/"
;;             (let ((start (string-find-right path #\/ 0 end)))
;;               (substring-cursor path start end))))))

;;> Returns just the basename of \var{path}, with any directory
;;> removed.  If \var{path} does not contain a directory separator,
;;> return the whole \var{path}.  If \var{path} ends in a directory
;;> separator (i.e. path is a directory), or is empty, return the
;;> empty string.

;; GNU basename
(define (path-strip-directory path)
  (substring-cursor path (string-find-right path #\/)))

;;> Returns just the directory of \var{path}.
;;> If \var{path} is relative (or empty), return \scheme{"."}.

(define (path-directory path)
  (if (string=? path "")
      "."
      (let ((end (string-skip-right path #\/)))
        (if (zero? end)
            "/"
            (let ((start (string-find-right path #\/ 0 end)))
              (if (zero? start)
                  "."
                  (let ((start2 (string-skip-right path #\/ 0 start)))
                    (if (zero? start2)
                        "/"
                        (substring-cursor path 0 start2)))))))))

(define (path-extension-pos path)
  (let ((end (string-cursor-end path)))
    (let lp ((i end) (dot #f))
      (if (<= i 0)
          #f
          (let* ((i2 (string-cursor-prev path i))
                 (ch (string-cursor-ref path i2)))
            (cond ((eqv? #\. ch) (and (< i end) (lp i2 (or dot i))))
                  ((eqv? #\/ ch) #f)
                  (dot)
                  (else (lp i2 #f))))))))

;;> Returns the rightmost extension of \var{path}, not including the
;;> \scheme{"."}.  If there is no extension, returns \scheme{#f}.  The
;;> extension will always be non-empty and contain no \scheme{"."}s.

(define (path-extension path)
  (let ((i (path-extension-pos path)))
    (and i
         (substring-cursor path i))))

;;> Returns \var{path} with the extension, if any, removed,
;;> along with the \scheme{"."}.

(define (path-strip-extension path)
  (let ((i (path-extension-pos path)))
    (if i
        (substring-cursor path 0 (string-cursor-prev path i))
        path)))

;;> Returns \var{path} with the extension, if any, replaced
;;> with \var{ext}.

(define (path-replace-extension path ext)
  (string-append (path-strip-extension path) "." ext))

;;> Returns \var{path} with any leading ../ removed.

(define (path-strip-leading-parents path)
  (if (string-prefix? "../" path)
      (path-strip-leading-parents (substring path 3))
      (if (equal? path "..") "" path)))

;;> Returns \scheme{#t} iff \var{path} is an absolute path,
;;> i.e. begins with "/".

(define (path-absolute? path)
  (and (not (string=? "" path)) (eqv? #\/ (string-ref path 0))))

;;> Returns \scheme{#t} iff \var{path} is a relative path.

(define (path-relative? path) (not (path-absolute? path)))

;;> Returns the suffix of \var{path} relative to the directory
;;> \var{dir}, or \scheme{#f} if \var{path} is not contained in
;;> \var{dir}.  If the two are the same (modulo a trailing
;;> \scheme{"/"}), then \scheme{"."} is returned.

(define (path-relative-to path dir)
  (let* ((path (path-normalize path))
         (path-end (string-cursor-end path))
         (dir (path-normalize dir))
         (dir-end (string-cursor-end dir))
         (i (string-mismatch dir path)))
    (cond
     ((not (<= 1 dir-end i path-end))
      (let ((i2 (string-cursor-next path i)))
        (and (= i path-end)
             (= i2 dir-end)
             (eqv? #\/ (string-cursor-ref dir i))
             ".")))
     ((= i path-end)
      ".")
     ((eqv? #\/ (string-cursor-ref path i))
      (let ((i2 (string-cursor-next path i)))
        (if (= i2 path-end) "." (substring-cursor path i2))))
     ((eqv? #\/ (string-cursor-ref path (string-cursor-prev path i)))
      (substring-cursor path i))
     (else
      #f))))

;;> Resolve \var{path} relative to the given directory.  Returns
;;> \var{path} unchanged if already absolute.

(define (path-resolve path dir)
  (if (path-absolute? path) path (make-path dir path)))

;; This looks big and hairy, but it's mutation-free and guarantees:
;;   (string=? s (path-normalize s))  <=>  (eq? s (path-normalize s))
;; i.e. fast and simple for already normalized paths.

;;> Returns a normalized version of path, with duplicate directory
;;> separators removed and "/./" and "x/../" references removed.
;;> Does not take symbolic links into account - this is meant to
;;> be abstract and applicable to paths on remote systems and in
;;> URIs.  Returns \var{path} itself if \var{path} is already
;;> normalized.

(define (path-normalize path)
  (let* ((len (string-length path)) (len-1 (- len 1)))
    (define (collect i j res)
      (if (>= i j) res (cons (substring path i j) res)))
    (define (finish i res)
      (if (zero? i)
          path
          (string-join (reverse (collect i len res)))))
    ;; loop invariants:
    ;;   - res is a list such that (string-concatenate-reverse res)
    ;;     is always the normalized string up to j
    ;;   - the tail of the string from j onward can be concatenated to
    ;;     the above value to get a partially normalized path referring
    ;;     to the same location as the original path
    (define (inside i j res)
      (if (>= j len)
          (finish i res)
          (if (eqv? #\/ (string-ref path j))
              (boundary i (+ j 1) res)
              (inside i (+ j 1) res))))
    (define (boundary i j res)
      (if (>= j len)
          (finish i res)
          (case (string-ref path j)
            ((#\.)
             (cond
              ((or (= j len-1) (eqv? #\/ (string-ref path (+ j 1))))
               (if (= i j)
                   (boundary (+ j 2) (+ j 2) res)
                   (let ((s (substring path i j)))
                     (boundary (+ j 2) (+ j 2) (cons s res)))))
              ((eqv? #\. (string-ref path (+ j 1)))
               (if (or (>= j (- len 2))
                       (eqv? #\/ (string-ref path (+ j 2))))
                   (if (>= i (- j 1))
                       (if (null? res)
                           (backup j "" '())
                           (backup j (car res) (cdr res)))
                       (backup j (substring path i j) res))
                   (inside i (+ j 2) res)))
              (else
               (inside i (+ j 1) res))))
            ((#\/) (boundary (+ j 1) (+ j 1) (collect i j res)))
            (else (inside i (+ j 1) res)))))
    (define (backup j s res)
      (let ((pos (+ j 3)))
        (cond
         ;; case 1: we're reduced to accumulating parents of the cwd
         ((or (string=? s "/..") (string=? s ".."))
          (boundary pos pos (cons "/.." (cons s res))))
         ;; case 2: the string isn't a component itself, skip it
         ((or (string=? s "") (string=? s ".") (string=? s "/"))
          (if (pair? res)
              (backup j (car res) (cdr res))
              (boundary pos pos (if (string=? s "/") '("/") '("..")))))
         ;; case3: just take the directory of the string
         (else
          (let ((d (path-directory s)))
            (cond
             ((string=? d "/")
              (boundary pos pos (if (null? res) '("/") res)))
             ((string=? d ".")
              (boundary pos pos res))
             (else (boundary pos pos (cons "/" (cons d res))))))))))
    ;; start with boundary if abs path, otherwise inside
    (if (zero? len)
        path
        ((if (eqv? #\/ (string-ref path 0)) boundary inside) 0 1 '()))))

;;> Return a new string representing the path where each of \var{args}
;;> is a path component, separated with the directory separator.
;;> \var{args} may include symbols and integers, in addition to
;;> strings.

(define (make-path . args)
  (define (x->string x)
    (cond ((string? x) x)
          ((symbol? x) (symbol->string x))
          ((number? x) (number->string x))
          (else (error "not a valid path component" x))))
  (define (trim-trailing-slash s)
    (substring-cursor s 0 (string-skip-right s #\/)))
  (if (null? args)
      ""
      (let* ((args0 (x->string (car args)))
             (start (trim-trailing-slash args0)))
        (let lp ((ls (cdr args))
                 (res (if (string=? "" start) '() (list start))))
          (cond
           ((null? ls)
            (if (and (null? res) (not (string=? "" args0)))
                "/"
                (string-join (reverse res))))
           ((pair? (car ls))
            (lp (append (car ls) (cdr ls)) res))
           (else
            (let ((x (trim-trailing-slash (x->string (car ls)))))
              (cond
               ((string=? x "")
                (lp (cdr ls) res))
               ((eqv? #\/ (string-ref x 0))
                (lp (cdr ls) (cons x res)))
               (else
                (lp (cdr ls) (cons x (cons "/" res))))))))))))
(define-binary-record-type tar
  (make (make-tar))
  (write write-tar-raw)
  (block
   (path (padded-string 100) (getter tar-path-raw) (setter tar-path-raw-set!))
   (mode (octal 8))
   (uid (octal 8))
   (gid (octal 8))
   (size (octal 12))
   (time (octal 12))
   (checksum (octal 8))
   (type (fixed-string 1))
   (link-name (padded-string 100))
   (ustar (padded-string 6))
   (ustar-version (padded-string 2))
   (owner (padded-string 32))
   (group (padded-string 32))
   (device-major (octal 8))
   (device-minor (octal 8))
   (path-prefix (padded-string 155))
   #u8(0 0 0 0 0 0 0 0 0 0 0 0)))

(define (tar-compute-checksum tar)
  (let ((tmp (open-output-bytevector)))
    (write-tar-raw tar tmp)
    (let ((bv (get-output-bytevector tmp)))
      (do ((i 0 (+ i 1))) ((= i 8))
        (bytevector-u8-set! bv (+ i 148) 32))
      (do ((i 0 (+ i 1))
           (sum 0 (+ sum (bytevector-u8-ref bv i))))
          ((= i 512) sum)))))

;; wrap the writer to automatically compute the checksum
(define (write-tar tar out)
  (tar-checksum-set! tar (tar-compute-checksum tar))
  (write-tar-raw tar out))

;; wrap the path to use the prefix
(define (tar-path tar)
  (string-append (tar-path-prefix tar) (tar-path-raw tar)))

(define (tar-normalize-path tar path)
  (cond ((string-suffix? "/." path) (string-trim-right path #\.))
        ((and (not (string-suffix? "/" path)) (equal? "5" (tar-type tar)))
         (string-append path "/"))
        (else path)))

(define (tar-path-set! tar path)
  (let* ((path (tar-normalize-path tar path))
         (len (string-length path)))
    (cond ((< len 100)
           (tar-path-raw-set! tar path))
          ((< len 255)
           (tar-path-raw-set! tar (substring path (- len 100)))
           (tar-path-prefix-set! tar (substring path 0 (- len 100))))
          (else (error "path name too long")))))

;; utilities

(define (read-modulo-bytevector in len mod)
  (let ((res (read-bytevector len in))
        (rem (modulo len mod)))
    (if (positive? rem)
        (read-bytevector (- mod rem) in))
    res))

(define (write-modulo-file out file mod)
  (let ((in (open-binary-input-file file)))
    (let lp ()
      (let ((bv (read-bytevector mod in)))
        (cond
         ((eof-object? bv))
         (else
          (write-bytevector bv out)
          (let ((len (bytevector-length bv)))
            (if (< len mod)
                (write-bytevector (make-bytevector (- mod len) 0) out)
                (lp)))))))))

;; fundamental iterator
(define (tar-fold src kons knil)
  (let ((in (cond ((string? src) (open-binary-input-file src))
                  ((bytevector? src) (open-input-bytevector src))
                  (else src))))
    (let lp ((acc knil) (empty 0))
      (cond
       ((or (eof-object? (peek-u8 in)) (>= empty 2))
        (close-input-port in)
        acc)
       (else
        (let ((tar (read-tar in)))
          (if (and (equal? "" (tar-path tar)) (zero? (tar-size tar)))
              (lp acc (+ empty 1))
              (let ((bv (read-modulo-bytevector in (tar-size tar) 512)))
                (lp (kons tar bv acc) 0)))))))))

;; not a tar-bomb and no absolute paths
(define (tar-safe? tarball)
  (define (path-top path)
    (substring path 0 (string-find path #\/)))
  (let ((files (map path-normalize (tar-files tarball))))
    (and (every path-relative? files)
         (or (< (length files) 2)
             (let ((dir (path-top (car files))))
               (every (lambda (f) (equal? dir (path-top f))) (cdr files)))))))

(define (tar-for-each tarball proc)
  (tar-fold tarball (lambda (tar bv acc) (proc tar bv)) #f))

;; list the files in the archive
(define (tar-files tarball)
  (reverse (tar-fold tarball (lambda (tar bv acc) (cons (tar-path tar) acc)) '())))

;; extract to the current filesystem
(define (tar-extract tarball . o)
  (define (safe-path path)
    (string-trim-left
     (path-strip-leading-parents (path-normalize path))
     #\/))
  (let ((rename (if (pair? o) (car o) safe-path)))
    (tar-for-each
     tarball
     (lambda (tar bv)
       (let ((path (rename (tar-path tar))))
         (case (string-ref (tar-type tar) 0)
           ((#\0 #\null)
            (let ((out (open-output-file-descriptor
                        (open path
                              (bitwise-ior open/write
                                           open/create
                                           open/non-block)
                              (tar-mode tar)))))
              (write-bytevector bv out)
              (close-output-port out)))
           ((#\1) (link-file (rename (tar-link-name tar)) path))
           ((#\2) (symbolic-link-file (rename (tar-link-name tar)) path))
           ((#\5) (create-directory* path (tar-mode tar)))
           ((#\g #\x))                   ;; meta data
           ((#\3 #\4 #\6) (error "devices not supported" (tar-type tar)))
           (else (error "invalid tar type" (tar-type tar)))))))))

(define (tar-extract-file tarball file)
  (call-with-current-continuation
   (lambda (return)
     (tar-for-each
      tarball
      (lambda (tar bv) (if (equal? (tar-path tar) file) (return bv))))
     #f)))

(define (file-owner-or-nobody st)
  (or (user-name (user-information (file-owner st))) "nobody"))
(define (file-group-or-nobody st)
  (or (group-name (group-information (file-group st))) "nobody"))

(define (file->tar file)
  (let ((tar (make-tar))
        (st (file-link-status file)))
    (tar-path-set! tar file)
    (tar-ustar-set! tar "ustar")
    (tar-ustar-version-set! tar "00")
    (cond
     (st
      (tar-mode-set! tar (file-mode st))
      (tar-uid-set! tar (file-owner st))
      (tar-gid-set! tar (file-group st))
      (tar-owner-set! tar (file-owner-or-nobody st))
      (tar-group-set! tar (file-group-or-nobody st))
      (tar-time-set! tar (+ 1262271600 (file-modification-time st)))
      (tar-type-set! tar (cond ((file-link? st) "2")
                               ((file-character? st) "3")
                               ((file-block? st) "4")
                               ((file-directory? st) "5")
                               (else "0")))
      (if (equal? "0" (tar-type tar))
          (tar-size-set! tar (file-size st)))
      (if (file-link? st)
          (tar-link-name-set! tar (read-link file)))))
    tar))

(define (inline->tar file content . o)
  (let ((tar (make-tar)))
    (tar-path-set! tar file)
    (tar-ustar-set! tar "ustar")
    (tar-ustar-version-set! tar "00")
    (tar-mode-set! tar (if (pair? o) (car o) #o644))
    (tar-uid-set! tar (current-user-id))
    (tar-gid-set! tar (current-group-id))
    (tar-owner-set! tar (user-name (user-information (current-user-id))))
    (tar-group-set! tar (group-name (group-information (current-group-id))))
    (tar-time-set! tar (exact (round (current-second))))
    (tar-type-set! tar "0")
    (tar-size-set! tar (bytevector-length content))
    tar))

(define (tar-add-directories tar out acc)
  (let lp ((dir (path-directory (tar-path tar))) (acc acc))
    (let ((dir/ (if (string-suffix? "/" dir) dir (string-append dir "/"))))
      (cond
       ((member dir '("" "." "/")) acc)
       ((assoc dir/ acc) (lp (path-directory dir) acc))
       (else
        (let ((acc (lp (path-directory dir) (cons (cons dir/ #f) acc))))
          (let ((tar2 (make-tar)))
            (tar-path-set! tar2 dir/)
            (tar-ustar-set! tar2 "ustar")
            (tar-ustar-version-set! tar2 "00")
            (tar-mode-set! tar2 (bitwise-ior #o111 (tar-mode tar) ))
            (tar-uid-set! tar2 (tar-uid tar))
            (tar-gid-set! tar2 (tar-gid tar))
            (tar-owner-set! tar2 (tar-owner tar))
            (tar-group-set! tar2 (tar-group tar))
            (tar-time-set! tar2 (tar-time tar))
            (tar-type-set! tar2 "5")
            (tar-size-set! tar2 0)
            (write-tar tar2 out)
            acc)))))))

;; create an archive for a given file list
(define (tar-create tarball files . o)
  (let* ((rename (if (pair? o) (car o) (lambda (f) f)))
         (no-recurse? (and (pair? o) (pair? (cdr o)) (cadr o)))
         (get-src
          (lambda (x) (if (pair? x) (and (eq? 'rename (car x)) (cadr x)) x)))
         (get-dest
          (lambda (x)
            (rename (if (pair? x)
                        (if (eq? 'rename (car x))
                            (car (cddr x))
                            (cadr x))
                        x))))
         (get-content
          (lambda (x) (and (pair? x) (eq? 'inline (car x))
                       (let ((c (car (cddr x))))
                         (if (string? c) (string->utf8 c) c))))))
    (let ((out (cond ((eq? #t tarball) (current-output-port))
                     ((eq? #f tarball) (open-output-bytevector))
                     (else (open-binary-output-file tarball)))))
      (fold
       (lambda (file acc)
         (let ((src0 (get-src file))
               (dest0 (get-dest file))
               (content0 (get-content file)))
           (define (kons x acc)
             (let* ((src (get-src x))
                    (dest (if (equal? x src0) dest0 (get-dest x)))
                    (content (if (equal? x src0) content0 (get-content x)))
                    (tar (if content
                             (inline->tar dest content)
                             (file->tar src))))
               (tar-path-set! tar dest)
               (cond
                ((assoc (tar-path tar) acc)
                 => (lambda (prev)
                      (if (not (and (file-directory? src)
                                    (file-directory? (cdr prev))))
                          (write-string
                           (string-append "tar-create: duplicate file: "
                                          dest "\n")
                           (current-error-port)))
                      acc))
                (else
                 (let ((acc (tar-add-directories tar out acc)))
                   (write-tar tar out)
                   (cond
                    ((and (string? src) (equal? "0" (tar-type tar)))
                     (write-modulo-file out src 512))
                    (content
                     (write-bytevector content out)
                     (let ((rem (modulo (bytevector-length content) 512)))
                       (if (positive? rem)
                           (write-bytevector
                            (make-bytevector (- 512 rem) 0) out)))))
                   (cons (cons (tar-path tar) src) acc))))))
           (if (and src0 (not no-recurse?))
               (directory-fold-tree src0 kons acc kons)
               (kons src0 acc))))
       '() files)
      (write-bytevector (make-bytevector 1024 0) out)
      (let ((res (if (eq? #f tarball) (get-output-bytevector out))))
        (close-output-port out)
        res))))

(define (main args)
  (let ((args (cdr args)))
    (cond
     ((equal? "t" (car args))
      (for-each (lambda (f) (write-string f) (newline)) (tar-files (cadr args))))
     ((equal? "x" (car args))
      (if (tar-safe? (cadr args))
          (tar-extract (cadr args))
          (error "tar file not a single relative directory" (cadr args))))
     ((equal? "c" (car args))
      (tar-create (cadr args) (cddr args)))
     ((equal? "f" (car args))
      (write-string
       (utf8->string (tar-extract-file (cadr args) (car (cddr args))))))
     (else
      (error "unknown tar command" (car args))))))

(define-library (chibi zlib)
  (export gzip-file gunzip-file gzip gunzip maybe-gunzip)
  (import (scheme base) (chibi io) (chibi process))
  (include "zlib.scm"))

(define-library (chibi regexp pcre)
  (export pcre->sre pcre->regexp)
  (import (scheme base) (scheme char) (scheme cxr)
          (srfi 1) (srfi 33)
          (chibi string) (chibi regexp))
  (include "pcre.scm"))

;; PCRE parsing, adapted from IrRegex.

(define ~none 0)
(define ~save? 1)
(define ~case-insensitive? 2)
(define ~multi-line? 4)
(define ~single-line? 8)
(define ~ignore-space? 16)

(define (flag-set? flags i)
  (= i (bitwise-and flags i)))
(define (flag-join a b)
  (if b (bitwise-ior a b) a))
(define (flag-clear a b)
  (bitwise-and a (bitwise-not b)))

(define (symbol-list->flags ls)
  (let lp ((ls ls) (res ~none))
    (cond
     ((null? ls)
      res)
     ((not (pair? ls))
      (lp (list ls) res))
     (else
      (lp (cdr ls)
          (flag-join
           res
           (case (car ls)
             ((i ci case-insensitive) ~case-insensitive?)
             ((m multi-line) ~multi-line?)
             ((s single-line) ~single-line?)
             ((x ignore-space) ~ignore-space?)
             (else #f))))))))

(define posix-escape-sequences
  `((#\n . #\newline)
    (#\r . #\return)
    (#\t . #\tab)
    (#\a . #\alarm)
    (#\e . #\escape)))

(define (char-altcase c)
  (if (char-upper-case? c) (char-downcase c) (char-upcase c)))

(define (char-mirror c)
  (case c ((#\<) #\>) ((#\{) #\}) ((#\() #\)) ((#\[) #\]) (else c)))

(define (string-scan-char-escape str c . o)
  (let ((end (string-length str)))
    (let scan ((i (if (pair? o) (car o) 0)))
      (cond ((= i end) #f)
            ((eqv? c (string-ref str i)) i)
            ((eqv? c #\\) (scan (+ i 2)))
            (else (scan (+ i 1)))))))

(define (string-parse-hex-escape str i end)
  (cond
   ((>= i end)
    (error "incomplete hex escape" str i))
   ((eqv? #\{ (string-ref str i))
    (let ((j (string-scan-char-escape str #\} (+ i 1))))
      (if (not j)
          (error "incomplete hex brace escape" str i)
          (let* ((s (substring str (+ i 1) j))
                 (n (string->number s 16)))
            (if n
                (list (integer->char n) j)
                (error "bad hex brace escape" s))))))
   ((>= (+ i 1) end)
    (error "incomplete hex escape" str i))
   (else
    (let* ((s (substring str i (+ i 2)))
           (n (string->number s 16)))
      (if n
          (list (integer->char n) (+ i 2))
          (error "bad hex escape" s))))))

(define (string-parse-cset str start flags)
  (let* ((end (string-length str))
         (invert? (and (< start end) (eqv? #\^ (string-ref str start)))))
    (define (cset-union a b)
      (cond ((not a) b)
            ((not b) a)
            ((and (pair? a) (eq? 'or (car a))) `(,@a ,b))
            (else `(or ,a ,b))))
    (define (go i prev-char ones pairs classes)
      (if (>= i end)
          (error "incomplete char set" str i end))
      (case (string-ref str i)
        ((#\])
         (if (and (null? ones) (null? pairs))
             (go (+ i 1) #\] (cons #\] ones) pairs classes)
             (list
              (let ((res
                     (cset-union
                      (cset-union
                       (and (pair? classes)
                            `(or ,@classes))
                       (and (pair? ones)
                            `(,(list->string (reverse ones)))))
                      (and (pair? pairs)
                           `(/ ,(list->string (reverse pairs)))))))
                (if invert? `(~ ,res) res))
              i)))
        ((#\-)
         (cond
          ((or (= i start)
               (and (= i (+ start 1)) invert?)
               (eqv? #\] (string-ref str (+ i 1))))
           (go (+ i 1) #\- (cons #\- ones) pairs classes))
          ;; alternately permissively allow this as a -
          ((not prev-char)
           (error "bad pcre char-set, unexpected -" str))
          (else
           (let ((ch (string-ref str (+ i 1))))
             (apply
              (lambda (c j)
                (if (char<? c prev-char)
                    (error "inverted range in pcre char-set" prev-char c)
                    (go j #f (cdr ones) (cons c (cons prev-char pairs))
                        classes)))
              (cond
               ((and (eqv? #\\ ch)
                     (assv (string-ref str (+ i 2)) posix-escape-sequences))
                => (lambda (x) (list (cdr x) (+ i 3))))
               ((and (eqv? #\\ ch)
                     (eqv? (string-ref str (+ i 2)) #\x))
                (string-parse-hex-escape str (+ i 3) end))
               (else
                (list ch (+ i 2)))))))))
        ((#\[)
         (let* ((inv? (eqv? #\^ (string-ref str (+ i 1))))
                (i2 (if inv? (+ i 2) (+ i 1))))
           (case (string-ref str i2)
             ((#\:)
              (let ((j (string-find str #\: (+ i2 1) end)))
                (if (or (>= (+ j 1) end)
                        (not (eqv? #\] (string-ref str (+ j 1)))))
                    (error "incomplete character class" str)
                    (let* ((class (string->symbol (substring str (+ i2 1) j)))
                           (class (if inv? `(~ ,class) class)))
                      (go (+ j 2) #f ones pairs (cons class classes))))))
             ((#\= #\.)
              (error "collating sequences not supported" str))
             (else
              (go (+ i 1) #\[ (cons #\[ ones) pairs classes)))))
        ((#\\)
         (let ((c (string-ref str (+ i 1))))
           (case c
             ((#\d #\D #\s #\S #\w #\W)
              (go (+ i 2) #f ones pairs
                  (cons (pcre->sre (string #\\ c)) classes)))
             ((#\x)
              (apply
               (lambda (c j) (go j c (cons c ones) pairs classes))
               (string-parse-hex-escape str (+ i 2) end)))
             (else
              (let ((c (cond ((assv c posix-escape-sequences) => cdr)
                             (else c))))
                (go (+ i 2) c (cons c ones) pairs classes))))))
        (else
         => (lambda (c) (go (+ i 1) c (cons c ones) pairs classes)))))
    (if invert?
        (let ((ones (if (flag-set? flags ~multi-line?) '(#\newline) '())))
          (go (+ start 1) #f ones '() '()))
        (go start #f '() '() '()))))

;; build a (seq ls ...) sre from a list
(define (sre-sequence ls)
  (cond
   ((null? ls) 'epsilon)
   ((null? (cdr ls)) (car ls))
   (else (cons 'seq ls))))

;; build a (or ls ...) sre from a list
(define (sre-alternate ls)
  (cond
   ((null? ls) '(or))
   ((null? (cdr ls)) (car ls))
   (else (cons 'or ls))))

;; returns #t if the sre can ever be empty
(define (sre-empty? sre)
  (if (pair? sre)
      (case (car sre)
        ((* ? look-ahead look-behind neg-look-ahead neg-look-behind) #t)
        ((**) (or (not (number? (cadr sre))) (zero? (cadr sre))))
        ((or) (any sre-empty? (cdr sre)))
        ((: seq $ submatch => submatch-named + atomic)
         (every sre-empty? (cdr sre)))
        (else #f))
      (memq sre '(epsilon bos eos bol eol bow eow commit))))

;; returns #t if the sre is a */+ repetition
(define (sre-repeater? sre)
  (and (pair? sre)
       (or (memq (car sre) '(* +))
           (and (memq (car sre) '($ submatch => submatch-named seq :))
                (pair? (cdr sre))
                (null? (cddr sre))
                (sre-repeater? (cadr sre))))))

(define (pcre->sre str . o)
  (if (not (string? str))
      (error "pcre->sre: expected a string" str))
  (let ((end (string-length str))
        (orig-flags (if (pair? o) (symbol-list->flags (car o)) ~none)))
    (let lp ((i 0) (from 0) (flags orig-flags) (res '()) (st '()))
      ;; accumulate the substring from..i as literal text
      (define (collect)
        (if (= i from) res (cons (substring str from i) res)))
      ;; like collect but breaks off the last single character when
      ;; collecting literal data, as the argument to ?/*/+ etc.
      (define (collect/single)
        (let ((j (- i 1)))
          (cond
           ((< j from)
            res)
           (else
            (let ((c (string-ref str j)))
              (cond
               ((= j from)
                (cons c res))
               (else
                (cons c (cons (substring str from j) res)))))))))
      ;; collects for use as a result, reversing and grouping OR
      ;; terms, and some ugly tweaking of `function-like' groups and
      ;; conditionals
      (define (collect/terms)
        (let* ((ls (collect))
               (func
                (and (pair? ls)
                     (memq (last ls)
                           '(atomic if look-ahead neg-look-ahead
                                    look-behind neg-look-behind
                                    => submatch-named))))
               (prefix (if (and func (memq (car func) '(=> submatch-named)))
                           (list 'submatch-named (cadr (reverse ls)))
                           (and func (list (car func)))))
               (ls (if func
                       (if (memq (car func) '(=> submatch-named))
                           (reverse (cddr (reverse ls)))
                           (reverse (cdr (reverse ls))))
                       ls)))
          (let lp ((ls ls) (term '()) (res '()))
            (define (shift)
              (cons (sre-sequence term) res))
            (cond
             ((null? ls)
              (let* ((res (sre-alternate (shift)))
                     (res (if (flag-set? flags ~save?)
                              (list 'submatch res)
                              res)))
                (if prefix
                    (if (eq? 'if (car prefix))
                        (cond
                         ((not (pair? res))
                          'epsilon)
                         ((memq (car res)
                                '(look-ahead neg-look-ahead
                                             look-behind neg-look-behind))
                          res)
                         ((eq? 'seq (car res))
                          `(if ,(cadr res)
                               ,(sre-sequence (cddr res))))
                         (else
                          `(if ,(cadadr res)
                               ,(sre-sequence (cddadr res))
                               ,(sre-alternate (cddr res)))))
                        `(,@prefix ,res))
                    res)))
             ((eq? 'or (car ls)) (lp (cdr ls) '() (shift)))
             (else (lp (cdr ls) (cons (car ls) term) res))))))
      (define (save)
        (cons (cons flags (collect)) st))
      ;; main parsing
      (cond
       ((>= i end)
        (if (pair? st)
            (error "unterminated parenthesis in regexp" str)
            (collect/terms)))
       (else
        (case (string-ref str i)
          ((#\.)
           (lp (+ i 1) (+ i 1) flags
               (cons (if (flag-set? flags ~single-line?) 'any 'nonl)
                     (collect))
               st))
          ((#\?)
           (let ((res (collect/single)))
             (if (null? res)
                 (error "? can't follow empty pattern" str res)
                 (let ((x (car res)))
                   (lp (+ i 1)
                       (+ i 1)
                       flags
                       (cons
                        (if (pair? x)
                            (case (car x)
                              ((*)  `(*? ,@(cdr x)))
                              ((+)  `(**? 1 #f ,@(cdr x)))
                              ((?)  `(?? ,@(cdr x)))
                              ((**) `(**? ,@(cdr x)))
                              ((=)  `(**? ,(cadr x) ,@(cdr x)))
                              ((>=)  `(**? ,(cadr x) #f ,@(cddr x)))
                              (else `(? ,x)))
                            `(? ,x))
                        (cdr res))
                       st)))))
          ((#\+ #\*)
           (let* ((res (collect/single))
                  (x (if (pair? res) (car res) 'epsilon))
                  (op (string->symbol (string (string-ref str i)))))
             (cond
              ((sre-repeater? x)
               (error "duplicate repetition (e.g. **) in pattern" str res))
              ((sre-empty? x)
               (error "can't repeat empty pattern (e.g. ()*)" str res))
              (else
               (lp (+ i 1) (+ i 1) flags
                   (cons (list op x) (cdr res))
                   st)))))
          ((#\()
           (cond
            ((>= (+ i 1) end)
             (error "unterminated parenthesis in regexp" str))
            ((not (memv (string-ref str (+ i 1)) '(#\? #\*))) ; normal case
             (lp (+ i 1) (+ i 1) (flag-join flags ~save?) '() (save)))
            ((>= (+ i 2) end)
             (error "unterminated parenthesis in regexp" str))
            ((eqv? (string-ref str (+ i 1)) #\*)
             (error "bad regexp syntax: (*FOO) not supported" str))
            (else ;; (?...) case
             (case (string-ref str (+ i 2))
               ((#\#)
                (let ((j (string-find str #\) (+ i 3))))
                  (lp (+ j i) (min (+ j 1) end) flags (collect) st)))
               ((#\:)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?) '() (save)))
               ((#\=)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(look-ahead) (save)))
               ((#\!)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(neg-look-ahead) (save)))
               ((#\<)
                (cond
                 ((>= (+ i 3) end)
                  (error "unterminated parenthesis in regexp" str))
                 (else
                  (case (string-ref str (+ i 3))
                    ((#\=)
                     (lp (+ i 4) (+ i 4) (flag-clear flags ~save?)
                         '(look-behind) (save)))
                    ((#\!)
                     (lp (+ i 4) (+ i 4) (flag-clear flags ~save?)
                         '(neg-look-behind) (save)))
                    (else
                     (let ((j (and (char-alphabetic?
                                    (string-ref str (+ i 3)))
                                   (string-find str #\> (+ i 4)))))
                       (if (< j end)
                           (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                               `(,(string->symbol (substring str (+ i 3) j))
                                 submatch-named)
                               (save))
                           (error "invalid (?< sequence" str))))))))
               ((#\>)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(atomic) (save)))
               ;;((#\' #\P) ; named subpatterns
               ;; )
               ;;((#\R) ; recursion
               ;; )
               ((#\()
                (cond
                 ((>= (+ i 3) end)
                  (error "unterminated parenthesis in regexp" str))
                 ((char-numeric? (string-ref str (+ i 3)))
                  (let* ((j (string-find str #\) (+ i 3)))
                         (n (string->number (substring str (+ i 3) j))))
                    (if (or (= j end) (not n))
                        (error "invalid conditional reference" str)
                        (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                            `(,n if) (save)))))
                 ((char-alphabetic? (string-ref str (+ i 3)))
                  (let ((j (string-find str #\) (+ i 3))))
                    (if (= j end)
                        (error "invalid named conditional reference" str)
                        (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                            `(,(string->symbol (substring str (+ i 3) j)) if)
                            (save)))))
                 (else
                  (lp (+ i 2) (+ i 2) (flag-clear flags ~save?)
                      '(if) (save)))))
               ((#\{)
                (error "unsupported Perl-style cluster" str))
               (else
                (let ((old-flags flags))
                  (let lp2 ((j (+ i 2)) (flags flags) (invert? #f))
                    (define (join x)
                      ((if invert? flag-clear flag-join) flags x))
                    (cond
                     ((>= j end)
                      (error "incomplete cluster" str i))
                     (else
                      (case (string-ref str j)
                        ((#\i)
                         (lp2 (+ j 1) (join ~case-insensitive?) invert?))
                        ((#\m)
                         (lp2 (+ j 1) (join ~multi-line?) invert?))
                        ((#\x)
                         (lp2 (+ j 1) (join ~ignore-space?) invert?))
                        ((#\-)
                         (lp2 (+ j 1) flags (not invert?)))
                        ((#\))
                         (lp (+ j 1) (+ j 1) flags (collect)
                             st))
                        ((#\:)
                         (lp (+ j 1) (+ j 1) flags '()
                             (cons (cons old-flags (collect)) st)))
                        (else
                         (error "unknown regex cluster modifier" str)
                         )))))))))))
          ((#\))
           (if (null? st)
               (error "too many )'s in regexp" str)
               (lp (+ i 1)
                   (+ i 1)
                   (caar st)
                   (cons (collect/terms) (cdar st))
                   (cdr st))))
          ((#\[)
           (apply
            (lambda (sre j)
              (lp (+ j 1) (+ j 1) flags (cons sre (collect)) st))
            (string-parse-cset str (+ i 1) flags)))
          ((#\{)
           (cond
            ((or (>= (+ i 1) end)
                 (not (or (char-numeric? (string-ref str (+ i 1)))
                          (eqv? #\, (string-ref str (+ i 1))))))
             (lp (+ i 1) from flags res st))
            (else
             (let ((res (collect/single)))
               (cond
                ((null? res)
                 (error "{ can't follow empty pattern"))
                (else
                 (let* ((x (car res))
                        (tail (cdr res))
                        (j (string-find str #\} (+ i 1)))
                        (s2 (string-split (substring str (+ i 1) j) #\,))
                        (n (string->number (car s2)))
                        (m (and (pair? (cdr s2))
                                (string->number (cadr s2)))))
                   (cond
                    ((or (= j end)
                         (not n)
                         (and (pair? (cdr s2))
                              (not (equal? "" (cadr s2)))
                              (not m)))
                     (error "invalid {n} repetition syntax" s2))
                    ((null? (cdr s2))
                     (lp (+ j 1) (+ j 1) flags `((= ,n ,x) ,@tail) st))
                    (m
                     (lp (+ j 1) (+ j 1) flags `((** ,n ,m ,x) ,@tail) st))
                    (else
                     (lp (+ j 1) (+ j 1) flags `((>= ,n ,x) ,@tail) st)
                     )))))))))
          ((#\\)
           (cond
            ((>= (+ i 1) end)
             (error "incomplete escape sequence" str))
            (else
             (let ((c (string-ref str (+ i 1))))
               (case c
                 ((#\d)
                  (lp (+ i 2) (+ i 2) flags `(numeric ,@(collect)) st))
                 ((#\D)
                  (lp (+ i 2) (+ i 2) flags `((~ numeric) ,@(collect)) st))
                 ((#\s)
                  (lp (+ i 2) (+ i 2) flags `(space ,@(collect)) st))
                 ((#\S)
                  (lp (+ i 2) (+ i 2) flags `((~ space) ,@(collect)) st))
                 ((#\w)
                  (lp (+ i 2) (+ i 2) flags
                      `((or alphanumeric ("_")) ,@(collect)) st))
                 ((#\W)
                  (lp (+ i 2) (+ i 2) flags
                      `((~ (or alphanumeric ("_"))) ,@(collect)) st))
                 ((#\b)
                  (lp (+ i 2) (+ i 2) flags
                      `((or bow eow) ,@(collect)) st))
                 ((#\B)
                  (lp (+ i 2) (+ i 2) flags `(nwb ,@(collect)) st))
                 ((#\A)
                  (lp (+ i 2) (+ i 2) flags `(bos ,@(collect)) st))
                 ((#\Z)
                  (lp (+ i 2) (+ i 2) flags
                      `((? #\newline) eos ,@(collect)) st))
                 ((#\z)
                  (lp (+ i 2) (+ i 2) flags `(eos ,@(collect)) st))
                 ((#\R)
                  (lp (+ i 2) (+ i 2) flags `(newline ,@(collect)) st))
                 ((#\K)
                  (lp (+ i 2) (+ i 2) flags `(reset ,@(collect)) st))
                 ;; these two are from Emacs and TRE, but not in PCRE
                 ((#\<)
                  (lp (+ i 2) (+ i 2) flags `(bow ,@(collect)) st))
                 ((#\>)
                  (lp (+ i 2) (+ i 2) flags `(eow ,@(collect)) st))
                 ((#\x)
                  (apply
                   (lambda (ch j)
                     (lp (+ j 1) (+ j 1) flags `(,ch ,@(collect)) st))
                   (string-parse-hex-escape str (+ i 2) end)))
                 ((#\k)
                  (let ((c (string-ref str (+ i 2))))
                    (if (not (memv c '(#\< #\{ #\')))
                        (error "bad \\k usage, expected \\k<...>" str)
                        (let* ((terminal (char-mirror c))
                               (j (string-find str terminal (+ i 2)))
                               (s (substring str (+ i 3) j))
                               (backref
                                (if (flag-set? flags ~case-insensitive?)
                                    'backref-ci
                                    'backref)))
                          (if (= j end)
                              (error "unterminated named backref" str)
                              (lp (+ j 1) (+ j 1) flags
                                  `((,backref ,(string->symbol s))
                                    ,@(collect))
                                  st))))))
                 ((#\Q) ;; \Q..\E escapes
                  (let ((res (collect)))
                    (let lp2 ((j (+ i 2)))
                      (cond
                       ((>= j end)
                        (lp j (+ i 2) flags res st))
                       ((eqv? #\\ (string-ref str j))
                        (cond
                         ((>= (+ j 1) end)
                          (lp (+ j 1) (+ i 2) flags res st))
                         ((eqv? #\E (string-ref str (+ j 1)))
                          (lp (+ j 2) (+ j 2) flags
                              (cons (substring str (+ i 2) j) res) st))
                         (else
                          (lp2 (+ j 2)))))
                       (else
                        (lp2 (+ j 1)))))))
                 ;;((#\p)  ; XXXX unicode properties
                 ;; )
                 ;;((#\P)
                 ;; )
                 (else
                  (cond
                   ((char-numeric? c)
                    (let* ((j (string-skip str char-numeric? (+ i 2)))
                           (backref
                            (if (flag-set? flags ~case-insensitive?)
                                'backref-ci
                                'backref))
                           (res `((,backref ,(string->number
                                              (substring str (+ i 1) j)))
                                  ,@(collect))))
                      (lp j j flags res st)))
                   ((char-alphabetic? c)
                    (let ((cell (assv c posix-escape-sequences)))
                      (if cell
                          (lp (+ i 2) (+ i 2) flags
                              (cons (cdr cell) (collect)) st)
                          (error "unknown escape sequence" str c))))
                   (else
                    (lp (+ i 2) (+ i 1) flags (collect) st)))))))))
          ((#\|)
           (lp (+ i 1) (+ i 1) flags (cons 'or (collect)) st))
          ((#\^)
           (let ((sym (if (flag-set? flags ~multi-line?) 'bol 'bos)))
             (lp (+ i 1) (+ i 1) flags (cons sym (collect)) st)))
          ((#\$)
           (let ((sym (if (flag-set? flags ~multi-line?) 'eol 'eos)))
             (lp (+ i 1) (+ i 1) flags (cons sym (collect)) st)))
          ((#\space)
           (if (flag-set? flags ~ignore-space?)
               (lp (+ i 1) (+ i 1) flags (collect) st)
               (lp (+ i 1) from flags res st)))
          ((#\#)
           (if (flag-set? flags ~ignore-space?)
               (let ((j (string-find str #\newline (+ i 1))))
                 (lp (+ j 1) (min (+ j 1) end) flags (collect) st))
               (lp (+ i 1) from flags res st)))
          (else
           (lp (+ i 1) from flags res st))))))))

(define (pcre->regexp pcre . o)
  (regexp (apply pcre->sre pcre o)))

(define-library (chibi net)
  (export sockaddr? address-info? get-address-info make-address-info
          socket connect bind accept listen open-socket-pair
          sockaddr-name sockaddr-port make-sockaddr
          with-net-io open-net-io make-listener-socket
          send receive! receive
          send/non-blocking receive!/non-blocking receive/non-blocking
          address-info-family address-info-socket-type address-info-protocol
          address-info-address address-info-address-length address-info-next
          address-family/unix address-family/inet address-family/inet6
          address-family/unspecified
          socket-type/stream socket-type/datagram socket-type/raw
          ip-proto/ip ip-proto/icmp ip-proto/tcp ip-proto/udp
          ai/passive ai/canonname ai/numeric-host
          get-socket-option set-socket-option! level/socket
          socket-opt/debug socket-opt/broadcast socket-opt/reuseaddr
          socket-opt/keepalive socket-opt/oobinline socket-opt/sndbuf
          socket-opt/rcvbuf socket-opt/dontroute socket-opt/rcvlowat
          socket-opt/sndlowat
          get-peer-name
          ;; C structs
          sockaddr addrinfo)
  (import (chibi) (chibi filesystem))
  (include-shared "net")
  (include "net.scm"))
;; scribble.scm - scribble parsing
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library used for parsing "scribble" format, introduced by
;;> \hyperlink["http://www.racket-lang.org/"]{Racket} and the format
;;> used to write this manual.  The default escape character is
;;> backslash as in TeX instead of @ as in Racket, though this can be
;;> overridden.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; general character utils

(define (char-mirror ch)
  (case ch ((#\() #\)) ((#\[) #\]) ((#\{) #\}) ((#\<) #\>) (else ch)))

(define (char-delimiter? ch)
  (or (eof-object? ch) (char-whitespace? ch)
      (memv ch '(#\( #\) #\[ #\] #\{ #\} #\" #\|))))

(define (char-punctuation? ch)
  (memv ch '(#\- #\+ #\! #\< #\> #\[ #\] #\|)))

(define (char-digit ch) (- (char->integer ch) (char->integer #\0)))

(define default-ecape-char #\\)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; list utils

(define (drop ls n) (if (<= n 0) ls (drop (cdr ls) (- n 1))))

(define (drop-while pred ls)
  (if (or (null? ls) (not (pred (car ls)))) ls (drop-while pred (cdr ls))))

(define (list-prefix? prefix ls)
  (cond ((null? prefix) #t)
        ((null? ls) #f)
        ((equal? (car prefix) (car ls)) (list-prefix? (cdr prefix) (cdr ls)))
        (else #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; scribble reader (standalone, don't use the native reader)

(define scribble-dot (list "."))
(define scribble-close (list ")"))

(define (if-peek-char ch in pass fail)
  (cond ((eqv? ch (peek-char in)) (read-char in) pass) (else fail)))

(define (skip-line in)
  (do ((c #f (read-char in))) ((or (eof-object? c) (eqv? c #\newline)))))

(define (read-float-tail in acc)
  (let lp ((res acc) (k 0.1))
    (let ((ch (read-char in)))
      (cond ((or (eof-object? ch) (char-delimiter? ch)) res)
            ((char-numeric? ch) (lp (+ res (* k (char-digit ch))) (* k 0.1)))
            (else (error "invalid numeric syntax"))))))

(define (read-number in acc base)
  (let lp ((acc acc))
    (let ((ch (peek-char in)))
      (cond
       ((or (eof-object? ch) (char-delimiter? ch)) acc)
       ((char-numeric? ch) (read-char in) (lp (+ (* acc base) (char-digit ch))))
       ((eqv? #\. ch)
        (read-char in)
        (if (= base 10)
            (begin (read-char in) (read-float-tail in (exact->inexact acc)))
            (error "non-base-10 floating point")))
       (else (error "invalid numeric syntax"))))))

(define (read-escaped in terminal)
  (let lp ((ls '()))
    (let ((ch (read-char in)))
      (cond
       ((or (eof-object? ch) (eqv? ch terminal)) (list->string (reverse ls)))
       ((eqv? ch #\\) (lp (cons (read-char in) ls)))
       (else (lp (cons ch ls)))))))

(define (read-symbol in ls)
  (do ((ls ls (cons c ls)) (c (peek-char in) (peek-char in)))
      ((char-delimiter? c) (string->symbol (list->string (reverse ls))))
    (read-char in)))

(define (scrib-read in . o)
  (define ch (read-char in))
  (define ec (if (pair? o) (car o) default-ecape-char))
  (cond
   ((eof-object? ch) ch)
   ((char-whitespace? ch) (scrib-read in))
   ((eqv? ch ec)
    (scribble-parse-escape in ec))
   (else
    (case ch
      ((#\( #\[ #\{)
       (let lp ((res '()))
         (let ((x (scrib-read in)))
           (cond ((eof-object? x) (error "unterminated list" x))
                 ((eq? x scribble-close) (reverse res))
                 ((eq? x scribble-dot)
                  (let ((y (scrib-read in)))
                    (if (or (eof-object? y) (eq? y scribble-close))
                        (error "unterminated dotted list")
                        (let ((z (scrib-read in)))
                          (if (not (eq? z scribble-close))
                              (error "dot in non-terminal position in list" y z)
                              (append (reverse res) y))))))
                 (else (lp (cons x res)))))))
      ((#\} #\] #\)) scribble-close)
      ((#\.) (if (char-delimiter? (peek-char in)) scribble-dot (read-float-tail in 0.0)))
      ((#\') (list 'quote (scrib-read in)))
      ((#\`) (list 'quasiquote (scrib-read in)))
      ((#\,) (list (if-peek-char #\@ in 'unquote-splicing 'unquote) (scrib-read in)))
      ((#\;) (skip-line in) (scrib-read in))
      ((#\|) (string->symbol (read-escaped in #\|)))
      ((#\") (read-escaped in #\"))
      ((#\+ #\-)
       (cond ((char-numeric? (peek-char in))
              ((if (eqv? ch #\+) + -) 0 (read-number in 0 10)))
             (else (read-symbol in (list ch)))))
      ((#\#)
       (case (peek-char in)
         ((#\t #\f) (eqv? (read-char in) #\t))
         ((#\() (list->vector (scrib-read in)))
         ((#\\)
          (read-char in)
          (if (char-alphabetic? (peek-char in))
              (let ((name (scrib-read in)))
                (case name
                  ((space) #\space) ((newline) #\newline)
                  (else (string-ref (symbol->string name) 0))))
              (read-char in)))
         (else (error "unknown # syntax"))))
      (else
       (if (char-numeric? ch)
           (read-number in (char-digit ch) 10)
           (read-symbol in (list ch))))))))

(define (scribble-read in . o)
  (let ((res (scrib-read in (if (pair? o) (car o) default-ecape-char))))
    (cond ((eq? res scribble-dot) (error "invalid . in source"))
          ((eq? res scribble-close) (error "too many )'s"))
          (else res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; scribble parser

(define (read-punctuation in)
  (if (not (eqv? #\| (peek-char in)))
      '()
      (let lp ((ls '()))
        (let ((c (peek-char in)))
          (cond ((or (eof-object? c) (not(char-punctuation? c))) ls)
                (else (lp (cons (char-mirror (read-char in)) ls))))))))

(define (read-prefix-wrapper in)
  (let lp ((wrap (lambda (x) x)))
    (case (peek-char in)
      ((#\') (read-char in) (lp (lambda (x) (wrap (list 'quote x)))))
      ((#\`) (read-char in) (lp (lambda (x) (wrap (list 'quasiquote x)))))
      ((#\,)
       (read-char in)
       (cond ((eqv? #\@ (peek-char in))
              (read-char in)
              (lp (lambda (x) (wrap (list 'unquote-splicing x)))))
             (else (lp (lambda (x) (wrap (list 'unquote x)))))))
      (else wrap))))

(define (scribble-parse-escape in ec)
  (define bracket-char #\[)
  (define brace-char #\{)
  (let* ((wrap (read-prefix-wrapper in))
         (c (peek-char in))
         (cmd (if (or (eqv? c bracket-char) (eqv? c brace-char)) '() (list (scribble-read in ec))))
         (data? (eqv? (peek-char in) bracket-char))
         (data (if data? (scribble-read in ec) '()))
         (punc (read-punctuation in))
         (body? (eqv? (peek-char in) brace-char))
         (body (cond (body? (read-char in) (scribble-parse in punc ec)) (else '()))))
    (wrap (if (or data? body?) (append cmd data body) (car cmd)))))

(define (scribble-parse in . o)
  (define init-punc (if (pair? o) (car o) '()))
  (define escape-char
    (if (and (pair? o) (pair? (cdr o))) (cadr o) default-ecape-char))
  (define comment-char #\;)
  (define bracket-char #\[)
  (define brace-char #\{)
  (define close-bracket-char (char-mirror bracket-char))
  (define close-brace-char (char-mirror brace-char))
  (define (collect str res)
    (if (pair? str) (cons (list->string (reverse str)) res) res))
  (define (skip-space in)
    (let ((ch (peek-char in)))
      (cond ((char-whitespace? ch) (read-char in) (skip-space in))
            ((eqv? ch #\;) (skip-line in) (skip-space in)))))
  (define (tok str res punc depth)
    (let ((c (read-char in)))
      (cond
        ((eof-object? c)
         (if (zero? depth)
             (reverse (collect str res))
             (error "unterminated expression" punc)))
        ((and (eqv? c escape-char) (list-prefix? punc str))
         (let ((c (peek-char in)))
           (cond
            ((eof-object? c)
             (tok str res punc depth))
            ((char-whitespace? c)
             (tok (cons c str) res punc depth))
            ((eqv? c comment-char)
             (read-char in)
             (cond ((eqv? brace-char (peek-char in))
                    (scribble-parse-escape in escape-char))
                   (else
                    (skip-line in)
                    ;; (let lp ()
                    ;;   (cond ((char-whitespace? (peek-char in)) (read-char in) (lp))))
                    ))
             (tok str res punc depth))
            ((eqv? c #\|)
             (read-char in)
             (let lp ((ls (collect str res)))
               (skip-space in)
               (cond ((eqv? #\| (peek-char in)) (read-char in) (tok '() ls punc depth))
                     (else (lp (cons (scribble-read in) ls))))))
            (else
             (let ((str (drop str (length punc)))
                   (x (scribble-parse-escape in escape-char)))
               (if (string? x)
                   (tok (append (reverse (string->list x)) str) res punc depth)
                   (tok '() (cons x (collect str res)) punc depth)))))))
        ((eqv? c brace-char)
         (tok (cons c str) res punc (+ depth 1)))
        ((eqv? c close-brace-char)
         (cond
          ((zero? depth)
           (let lp ((p punc) (ls '()))
             (cond ((null? p)
                    (reverse (collect str res)))
                   ((not (eqv? (car p) (peek-char in)))
                    (tok (append ls (cons c str)) res punc (- depth 1)))
                   (else
                    (lp (cdr p) (cons (read-char in) ls))))))
          (else (tok (cons c str) res punc (- depth 1)))))
        ((eqv? c #\newline)
         (let* ((res (collect str res))
                (res (if (and (null? res) (null? str))
                         res
                         (cons "\n" res))))
           (tok '() res punc depth)))
        (else
         (tok (cons c str) res punc depth)))))
  ;; begin
  (tok '() '() init-punc 0))

(define (ref=? a b)
  (or (eq? a b)
      (and (ref? a) (ref? b)
           (eq? (ref-name a) (ref-name b))
           (eq? (car (ref-cell a)) (car (ref-cell b)))
           (eq? (cdr (ref-cell a)) (cdr (ref-cell b))))))

(define profile-cells '())

(define (profile-get-cell f)
  (or (assoc f profile-cells ref=?)
      (let ((cell (cons f 0)))
        (set! profile-cells (cons cell profile-cells))
        cell)))

(define (profile-reset)
  (for-each (lambda (x) (set-cdr! x 0)) profile-cells))

(define (profile-report)
  (define (report-op op)
    (match op
      (($ Ref name (p . (and ($ Lam lam-name) f)))
       (write name)
       (cond
        ((not (eq? p name))
         (display " ")
         (write p)))
       (cond
        ((lambda-source f)
         (display " [") (write (lambda-source f)) (display "]"))))
      (($ Ref name (_ . f))
       (write name) (display " (") (write f) (display ")"))
      (else
       (write op))))
  (let ((ls (filter (lambda (x) (> (cdr x) 0))
                    profile-cells)))
    (for-each (lambda (x)
                (write (cdr x)) (display ": ")
                (report-op (car x)) (newline))
              (sort ls > cdr))))

(define (optimize-profile ast)
  (let-syntax ((opt (syntax-rules () ((opt x) (optimize-profile x)))))
    (match ast
      (($ Set ref value)
       (set-value-set! ast (opt value))
       ast)
      (($ Cnd test pass fail)
       (make-cnd (opt test) (opt pass) (opt fail)))
      (($ Seq ls)
       (make-seq (map optimize-profile ls)))
      (($ Lam name params body)
       (lambda-body-set! ast (opt body))
       ast)
      ((($ Ref name cell) args ...)
       (make-seq (list (list increment-cdr!
                             (make-lit (profile-get-cell (car ast))))
                       (cons (car ast) (map optimize-profile args)))))
      ((app ...)
       (map optimize-profile app))
      (else
       ast))))

(register-lambda-optimization! optimize-profile)

(define-library (chibi optimize rest)
  (export optimize-rest rest-parameter-cdrs num-parameters local-ref)
  (import (chibi) (srfi 1) (chibi ast) (chibi match) (chibi optimize))
  (include-shared "rest")
  (include "rest.scm"))

(define (optimize-rest ast)
  (cond
   ((and (lambda? ast)
         (not (list? (lambda-params ast)))
         (rest-parameter-cdrs ast))
    => (lambda (cdrs)
         (replace-rest-destructuring-with-stack-references
          (length* (lambda-params ast))
          ast
          cdrs)))
   (else
    ast)))

(define safe-primitives (list car cdr null? pair?))

(define (adjust-cdrs cdrs f params args)
  (filter-map
   (lambda (p a)
     (match a
       (((? (lambda (op) (eq? op cdr))) ($ Ref name (_ . (? lambda? lam))))
        (let ((x (find (lambda (r)
                         (and (eq? name (car r)) (eq? lam (cadr r))))
                       cdrs)))
          (and x (list p f (+ (car (cddr x)) 1)))))
       (($ Cnd
           ((? (lambda (op) (eq? op pair?))) ($ Ref name (_ . (? lambda? lam))))
           ((? (lambda (op) (eq? op cdr))) ($ Ref name (_ . (? lambda? lam))))
           (or () ($ Lit ())))
        (let ((x (find (lambda (r)
                         (and (eq? name (car r)) (eq? lam (cadr r))))
                       cdrs)))
          (and x (list p f (+ (car (cddr x)) 1.0)))))
       (else #f)))
   params
   args))

(define (rest-parameter-cdrs ast)
  (let analyze ((x (lambda-body ast))
                (cdrs (list (list (dotted-tail (lambda-params ast)) ast 0)))
                (safe? #t))
    (define (recurse x cdrs) (analyze x cdrs safe?))
    (match x
      (($ Ref name (_ . (? lambda? f)))
       (and (not (any (lambda (r) (and (eq? name (car r)) (eq? f (cadr r)))) cdrs))
            cdrs))
      (($ Set ref value)
       (and (recurse ref cdrs) (recurse value cdrs)))
      (($ Cnd test pass fail)
       (fold-every recurse cdrs (list test pass fail)))
      (($ Seq ls)
       (fold-every recurse cdrs ls))
      (($ Lam name params body)
       (analyze body cdrs #f))
      (((and ($ Lam _ (params ...) body) f) args ...)
       (let ((cdrs (fold-every recurse cdrs args)))
         (and (equal? (length params) (length args))
              (recurse body (append (adjust-cdrs cdrs f params args) cdrs)))))
      (((? opcode? op) ($ Ref _ (_ . (? lambda?))))
       (if (and safe? (memq op safe-primitives))
           cdrs
           (recurse (cadr x) cdrs)))
      ((app ...)
       (fold-every recurse cdrs app))
      (else
       cdrs))))

(define (replace-rest-destructuring-with-stack-references base ast cdrs)
  (define (rename p)
    (make-syntactic-closure
     (current-environment) '() (strip-syntactic-closures p)))
  (define (replace-param x)
    (match x
      (($ Cnd test pass fail)
       (make-cnd (replace-param test)
                 (replace-param pass)
                 (replace-param fail)))
      (($ Seq ls)
       (let ((ls (map replace-param ls)))
         (and ls (make-seq ls))))
      (((? opcode? op) ($ Ref name (_ . (? lambda? f))))
       (let ((r (and (memq op safe-primitives)
                     (find (lambda (r) (and (eq? name (car r)) (eq? f (cadr r))))
                           cdrs))))
         (cond
          ((not r)
           x)
          ((eq? op car)
           `(,local-ref ,(+ 1 (inexact->exact (car (cddr r))))))
          ((eq? op cdr)
           (make-lit '()))
          ((eq? op pair?)
           `(,> (,num-parameters) ,(+ base (inexact->exact (car (cddr r))))))
          ((eq? op null?)
           `(,<= (,num-parameters) ,(+ base (inexact->exact (car (cddr r))))))
          (else
           x))))
      (($ Set ref value)
       #f)
      (($ Lam name params body)
       #f)
      ((app ...)
       #f)
      (else
       x)))
  (lambda-body-set!
   ast
   (let replace ((x (lambda-body ast)))
     (match x
       ((($ Lam name (params ...) body) args ...)
        (let* ((locals (map replace-param args))
               (names (map rename params))
               (refs (map (lambda (name) (make-ref name (cons name ast))) names)))
          (let ((res (fold (lambda (p new res)
                             (replace-references res p (car x) new))
                           (replace body)
                           params
                           refs)))
            (lambda-locals-set! ast (append names (lambda-locals ast)))
            (join-seq (make-seq (map make-set refs locals))
                      res))))
       (else
        x))))
  ast)

(register-lambda-optimization! optimize-rest)

(define-library (chibi optimize profile)
  (export optimize-profile increment-cdr! profile-reset profile-report)
  (import (chibi) (srfi 1) (srfi 69) (srfi 95)
          (chibi ast) (chibi match) (chibi optimize))
  (include-shared "profile")
  (include "profile.scm"))
;; app.scm -- unified option parsing and config
;; Copyright (c) 2012-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Parses command-line options into a config object.

(define (parse-option prefix conf-spec args fail)
  (define (parse-value type str)
    (cond
     ((not (string? str))
      str)
     ((and (pair? type) (eq? 'list (car type)))
      (map (lambda (x) (parse-value (cadr type) x))
           (string-split str #\,)))
     (else
      (case type
        ((boolean) (not (member str '("#f" "#false" "#F" "#FALSE"))))
        ((number) (string->number str))
        ((symbol) (string->symbol str))
        ((char) (string-ref str 0))
        (else str)))))
  (define (lookup-conf-spec conf-spec syms strs)
    (let ((sym (car syms))
          (str (car strs)))
      (cond
       ((= 1 (length syms))
        (let lp ((ls conf-spec))
          (and (pair? ls)
               (let ((x (car ls)))
                 (cond
                  ((eq? sym (car x)) x)
                  ((and (pair? (cddr x)) (member str (car (cddr x)))) x)
                  ((and (pair? (cddr x)) (member `(not ,str) (car (cddr x))))
                   `(not ,x))
                  (else (lp (cdr ls))))))))
       (else
        (let lp ((ls conf-spec))
          (and (pair? ls)
               (let ((x (car ls)))
                 (cond
                  ((or (eq? sym (car x))
                       (and (pair? (cddr x)) (member str (car (cddr x)))))
                   (let ((type (cadr x)))
                     (if (not (and (pair? type) (eq? 'conf (car type))))
                         (error "option prefix not a subconf" sym)
                         (lookup-conf-spec (cdr type) (cdr syms) (cdr strs)))))
                  (else (lp (cdr ls)))))))))))
  (define (lookup-short-option ch spec)
    (let lp ((ls spec))
      (and (pair? ls)
           (let ((x (car ls)))
             (cond
              ((and (pair? (cddr x)) (memv ch (car (cddr x))))
               x)
              ((and (pair? (cddr x)) (member `(not ,ch) (car (cddr x))))
               `(not ,x))
              (else (lp (cdr ls))))))))
  (define (parse-conf-spec str args)
    (let* ((strs (string-split str #\.))
           (syms (map string->symbol strs))
           (spec (lookup-conf-spec conf-spec syms strs)))
      (cond
       ((not spec)
        #f)
       ((and (pair? spec) (eq? 'not (car spec)))
        (cons (cons (append prefix (list (car spec))) #f) args))
       ((eq? 'boolean (cadr spec))
        (cons (cons (append prefix (list (car spec))) #t) args))
       ((null? args)
        (error "missing argument to option " str))
       (else
        (cons (cons (append prefix syms) (parse-value (cadr spec) (car args)))
              (cdr args))))))
  (define (parse-long-option str args)
    (let* ((str+val (string-split str #\= 2))
           (str (car str+val))
           (args2 (if (pair? (cdr str+val)) (cons (cadr str+val) args) args)))
      (or (parse-conf-spec str args2)
          (and (string-prefix? "no-" str)
               (let ((res (parse-long-option (substring str 3) args)))
                 (cond
                  ((not res)
                   #f)
                  ((not (boolean? (cdar res)))
                   (error "'no-' prefix only valid on boolean options"))
                  (else
                   `(((,@prefix ,(caar res)) . ,(not (cdar res)))
                     ,@(cdr res)))))))))
  (define (parse-short-option str args)
    (let* ((ch (string-ref str 0))
           (x (lookup-short-option ch conf-spec)))
      (cond
       ((not x)
        #f)
       ((and (pair? x) (eq? 'not (car x)))
        (cons (cons (append prefix (list (car (cadr x)))) #f)
              (if (= 1 (string-length str))
                  args
                  (cons (string-append "-" (substring str 1)) args))))
       ((eq? 'boolean (cadr x))
        (cons (cons (append prefix (list (car x))) #t)
              (if (= 1 (string-length str))
                  args
                  (cons (string-append "-" (substring str 1)) args))))
       ((> (string-length str) 1)
        (cons (cons (append prefix (list (car x)))
                    (parse-value (cadr x) (substring str 1)))
              args))
       ((null? args)
        (error "missing argument to option " x))
       (else
        (cons (cons (append prefix (list (car x))) (car args)) (cdr args))))))
  (or (if (eqv? #\- (string-ref (car args) 1))
          (parse-long-option (substring (car args) 2) (cdr args))
          (parse-short-option (substring (car args) 1) (cdr args)))
      (fail prefix conf-spec (car args) args)))

(define (parse-options prefix conf-spec orig-args fail)
  (let lp ((args orig-args)
           (opts (make-conf '() #f (cons 'options orig-args) #f)))
    (cond
     ((null? args)
      (cons opts args))
     ((or (member (car args) '("" "-" "--"))
          (not (eqv? #\- (string-ref (car args) 0))))
      (cons opts (if (equal? (car args) "--") (cdr args) args)))
     (else
      (let ((val+args (parse-option prefix conf-spec args fail)))
        (lp (cdr val+args)
            (conf-set opts (caar val+args) (cdar val+args))))))))

(define (parse-app prefix spec opt-spec args config init end . o)
  (define (next-prefix prefix name)
    (append (if (null? prefix) '(command) prefix) (list name)))
  (define (prev-prefix prefix)
    (cond ((and (= 2 (length prefix))))
          ((null? prefix) '())
          (else (reverse (cdr (reverse  prefix))))))
  (let ((fail (if (pair? o)
                  (car o)
                  (lambda (prefix spec opt args)
                    ;; TODO: search for closest option
                    (error "unknown option: " opt)))))
    (cond
     ((null? spec)
      (error "no procedure in application spec"))
     ((pair? (car spec))
      (case (caar spec)
        ((@)
         (let* ((new-opt-spec (cadr (car spec)))
                (new-fail
                 (lambda (new-prefix new-spec opt args)
                   (parse-option (prev-prefix prefix) opt-spec args fail)))
                (cfg+args (parse-options prefix new-opt-spec args new-fail))
                (config (conf-append (car cfg+args) config))
                (args (cdr cfg+args)))
           (parse-app prefix (cdr spec) new-opt-spec args config init end new-fail)))
        ((or)
         (any (lambda (x) (parse-app prefix x opt-spec args config init end))
              (cdar spec)))
        ((begin:)
         (parse-app prefix (cdr spec) opt-spec args config (cadr (car spec)) end fail))
        ((end:)
         (parse-app prefix (cdr spec) opt-spec args config init (cadr (car spec)) fail))
        (else
         (if (procedure? (caar spec))
             (vector (caar spec) config args init end) ; TODO: verify
             (parse-app prefix (car spec) opt-spec args config init end fail)))))
     ((symbol? (car spec))
      (and (pair? args)
           (eq? (car spec) (string->symbol (car args)))
           (let ((prefix (next-prefix prefix (car spec))))
             (parse-app prefix (cdr spec) opt-spec (cdr args) config init end fail))))
     ((procedure? (car spec))
      (vector (car spec) config args init end))
     (else
      (if (not (string? (car spec)))
          (error "unknown application spec" (car spec)))
      (parse-app prefix (cdr spec) opt-spec args config init end fail)))))

(define (print-command-help command out)
  (cond
   ((and (pair? command) (symbol? (car command)))
    (display "  " out)
    (display (car command) out)
    (cond
     ((find (lambda (x) (and (pair? x) (procedure? (car x)))) command)
      => (lambda (x)
           (let lp ((args (cdr x)) (opt-depth 0))
             (cond
              ((null? args)
               (display (make-string opt-depth #\]) out))
              ((pair? (car args))
               (display " [" out)
               (display (caar args) out)
               (lp (cdr args) (+ opt-depth 1)))
              (else
               (display " " out)
               (display (car args) out)
               (lp (cdr args) opt-depth)))))))
    (cond
     ((find string? command)
      => (lambda (doc-string) (display " - " out) (display doc-string out))))
    (newline out))))

(define (print-option-help option out)
  (let* ((str (symbol->string (car option)))
         (names (if (and (pair? (cdr option)) (pair? (cddr option)))
                    (car (cddr option))
                    '()))
         (pref-str (cond ((find string? names) => values) (else str)))
         (pref-ch (find char? names))
         (doc (find string? (cdr option))))
    ;; TODO: consider aligning these
    (cond
     (pref-ch (display "  -" out) (write-char pref-ch out))
     (else (display "    " out)))
    (cond
     (pref-str
      (display (if pref-ch ", " "  ") out)
      (display "--" out) (display pref-str out)))
    (cond (doc (display " - " out) (display doc out)))
    (newline out)))

(define (print-help name docs commands options . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (display "Usage: " out) (display name out)
    (if (pair? options) (display " [options]" out))
    (case (length commands)
      ((0) (newline out))
      (else
       (display " <command>\nCommands:\n" out)
       (for-each (lambda (c) (print-command-help c out)) commands))
      ((1) (print-command-help (car commands) out)))
    (if (pair? options) (display "Options:\n" out))
    (for-each (lambda (o) (print-option-help o out)) options)))

(define (app-help spec args . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (let lp ((ls (cdr spec))
             (docs #f)
             (commands '())
             (options '()))
      (cond
       ((null? ls)
        (print-help (car spec) docs commands options out))
       ((or (string? (car ls))
            (and (pair? (car ls)) (memq (caar ls) '(begin: end:) )))
        (lp (cdr ls) (car ls) commands options))
       ((and (pair? (car ls)) (eq? '@ (caar ls)))
        (lp (cdr ls) docs commands (append options (cadr (car ls)))))
       ((and (pair? (car ls)) (symbol? (caar ls)))
        ;; don't print nested commands
        (if (pair? commands)
            (print-help (car spec) docs commands options out)
            (if (eq? 'or (caar ls))
                (lp (cdr ls) docs (cdar ls) options)
                (lp (cdr ls) docs (list (car ls)) options))))
       (else
        (lp (cdr ls) docs commands options))))))

(define (app-help-command config spec . args)
  (app-help spec args (current-output-port)))

(define (run-application spec . o)
  (let ((args (or (and (pair? o) (car o)) (command-line)))
        (config (and (pair? o) (pair? (cdr o)) (cadr o))))
    (cond
     ((parse-app '() (cdr spec) '() (cdr args) config #f #f)
      => (lambda (v)
           (let ((proc (vector-ref v 0))
                 (cfg (vector-ref v 1))
                 (args (vector-ref v 2))
                 (init (vector-ref v 3))
                 (end (vector-ref v 4)))
             (if init (init cfg))
             (apply proc cfg spec args)
             (if end (end cfg)))))
     ((null? (cdr args))
      (apply app-help-command config spec args)
      (error "Expected a command"))
     (else
      (error "Unknown command: " (cdr args))))))
;; Copyright (c) 2005-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> RFC 3548 base64 encoding and decoding utilities.
;;> This API is compatible with the Gauche library rfc.base64.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utils

(define (string-chop str n)
  (let ((len (string-length str)))
    (let lp ((i 0) (res '()))
      (let ((j (+ i n)))
        (if (>= j len)
            (reverse (cons (substring str i len) res))
            (lp j (cons (substring str i j) res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; constants and tables

(define *default-max-col* 76)

(define *outside-char* 99) ; luft-balloons
(define *pad-char* 101)    ; dalmations

(define *base64-decode-table*
  (let ((res (make-vector #x100 *outside-char*)))
    (let lp ((i 0)) ; map letters
      (cond
       ((<= i 25)
        (vector-set! res (+ i 65) i)
        (vector-set! res (+ i 97) (+ i 26))
        (lp (+ i 1)))))
    (let lp ((i 0)) ; map numbers
      (cond
       ((<= i 9)
        (vector-set! res (+ i 48) (+ i 52))
        (lp (+ i 1)))))
    ;; extras (be liberal for different common base64 formats)
    (vector-set! res (char->integer #\+) 62)
    (vector-set! res (char->integer #\-) 62)
    (vector-set! res (char->integer #\/) 63)
    (vector-set! res (char->integer #\_) 63)
    (vector-set! res (char->integer #\~) 63)
    (vector-set! res (char->integer #\=) *pad-char*)
    res))

(define (base64-decode-u8 u8)
  (vector-ref *base64-decode-table* u8))

(define *base64-encode-table*
  (let ((res (make-vector 64)))
    (let lp ((i 0)) ; map letters
      (cond
       ((<= i 25)
        (vector-set! res i (+ i 65))
        (vector-set! res (+ i 26) (+ i 97))
        (lp (+ i 1)))))
    (let lp ((i 0)) ; map numbers
      (cond
       ((<= i 9)
        (vector-set! res (+ i 52) (+ i 48))
        (lp (+ i 1)))))
    (vector-set! res 62 (char->integer #\+))
    (vector-set! res 63 (char->integer #\/))
    res))

(define (enc i)
  (vector-ref *base64-encode-table* i))

;; try to match common boundaries
(define decode-src-length
  (lcm 76 78))

(define decode-dst-length
  (* 3 (arithmetic-shift (+ 3 decode-src-length) -2)))

(define encode-src-length
  (* 3 1024))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; decoding

;;> Return a base64 decoded representation of string, also interpreting
;;> the alternate 62 & 63 valued characters as described in RFC3548.
;;> Other out-of-band characters are silently stripped, and = signals
;;> the end of the encoded string.  No errors will be raised.

;; Create a result buffer with the maximum possible length for the
;; input, and pass it to the internal base64-decode-string! utility.
;; If the resulting length used is exact, we can return that buffer,
;; otherwise we return the appropriate substring.

(define (base64-decode-string str)
  (utf8->string (base64-decode-bytevector (string->utf8 str))))

(define (base64-decode-bytevector src)
  (let* ((len (bytevector-length src))
         (dst-len (* 3 (arithmetic-shift (+ 3 len) -2)))
         (dst (make-bytevector dst-len)))
    (base64-decode-bytevector!
     src 0 len dst
     (lambda (src-offset res-len b1 b2 b3)
       (let ((res-len (base64-decode-finish dst res-len b1 b2 b3)))
         (if (= res-len dst-len)
             dst
             (bytevector-copy dst 0 res-len)))))))

;; This is a little funky.
;;
;;   We want to skip over "outside" characters (e.g. newlines inside
;;   base64-encoded data, as would be passed in mail clients and most
;;   large base64 data).  This would normally mean two nested loops -
;;   one for overall processing the input, and one for looping until
;;   we get to a valid character.  However, many Scheme compilers are
;;   really bad about optimizing nested loops of primitives, so we
;;   flatten this into a single loop, using conditionals to determine
;;   which character is currently being read.
(define (base64-decode-bytevector! src start end dst kont)
  (let lp ((i start)
           (j 0)
           (b1 *outside-char*)
           (b2 *outside-char*)
           (b3 *outside-char*))
    (if (>= i end)
        (kont i j b1 b2 b3)
        (let ((c (base64-decode-u8 (bytevector-u8-ref src i))))
          (cond
           ((eqv? c *pad-char*)
            (kont i j b1 b2 b3))
           ((eqv? c *outside-char*)
            (lp (+ i 1) j b1 b2 b3))
           ((eqv? b1 *outside-char*)
            (lp (+ i 1) j c b2 b3))
           ((eqv? b2 *outside-char*)
            (lp (+ i 1) j b1 c b3))
           ((eqv? b3 *outside-char*)
            (lp (+ i 1) j b1 b2 c))
           (else
            (bytevector-u8-set!
             dst
             j
             (bitwise-ior (arithmetic-shift b1 2)
                          (extract-bit-field 2 4 b2)))
            (bytevector-u8-set!
             dst
             (+ j 1)
             (bitwise-ior
              (arithmetic-shift (extract-bit-field 4 0 b2) 4)
              (extract-bit-field 4 2 b3)))
            (bytevector-u8-set!
             dst
             (+ j 2)
             (bitwise-ior
              (arithmetic-shift (extract-bit-field 2 0 b3) 6)
              c))
            (lp (+ i 1) (+ j 3)
                *outside-char* *outside-char* *outside-char*)))))))

;; If requested, account for any "partial" results (i.e. trailing 2 or
;; 3 chars) by writing them into the destination (additional 1 or 2
;; bytes) and returning the adjusted offset for how much data we've
;; written.
(define (base64-decode-finish dst j b1 b2 b3)
  (cond
   ((eqv? b1 *outside-char*)
    j)
   ((eqv? b2 *outside-char*)
    (bytevector-u8-set! dst j (arithmetic-shift b1 2))
    (+ j 1))
   (else
    (bytevector-u8-set! dst
                        j
                        (bitwise-ior (arithmetic-shift b1 2)
                                     (extract-bit-field 2 4 b2)))
    (cond
     ((eqv? b3 *outside-char*)
      (+ j 1))
     (else
      (bytevector-u8-set! dst
                          (+ j 1)
                          (bitwise-ior
                           (arithmetic-shift (extract-bit-field 4 0 b2) 4)
                           (extract-bit-field 4 2 b3)))
      (+ j 2))))))

;;>  Variation of the above to read and write to ports.

(define (base64-decode . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (out (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (current-output-port))))
    (cond
     ((not (binary-port? in))
      (write-string (base64-decode-string (port->string in)) out))
     (else
      (let ((src (make-bytevector decode-src-length))
            (dst (make-bytevector decode-dst-length)))
        (let lp ((offset 0))
          (let ((src-len
                 (+ offset
                    (read-bytevector! decode-src-length src in offset))))
            (cond
             ((= src-len decode-src-length)
              ;; read a full chunk: decode, write and loop
              (base64-decode-bytevector!
               src 0 decode-src-length dst
               (lambda (src-offset dst-len b1 b2 b3)
                 (cond
                  ((and (< src-offset src-len)
                        (eqv? #\= (string-ref src src-offset)))
                   ;; done
                   (let ((dst-len (base64-decode-finish dst dst-len b1 b2 b3)))
                     (write-bytevector dst out 0 dst-len)))
                  ((eqv? b1 *outside-char*)
                   (write-string dst out 0 dst-len)
                   (lp 0))
                  (else
                   (write-bytevector dst out 0 dst-len)
                   ;; one to three chars left in buffer
                   (bytevector-u8-set! src 0 (enc b1))
                   (cond
                    ((eqv? b2 *outside-char*)
                     (lp 1))
                    (else
                     (bytevector-u8-set! src 1 (enc b2))
                     (cond
                      ((eqv? b3 *outside-char*)
                       (lp 2))
                      (else
                       (bytevector-u8-set! src 2 (enc b3))
                       (lp 3))))))))))
             (else
              ;; end of source - just decode and write once
              (base64-decode-bytevector!
               src 0 src-len dst
               (lambda (src-offset dst-len b1 b2 b3)
                 (let ((dst-len (base64-decode-finish dst dst-len b1 b2 b3)))
                   (write-string dst out 0 dst-len)))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; encoding

;;> Return a base64 encoded representation of string according to the
;;> official base64 standard as described in RFC3548.

(define (base64-encode-string str)
  (utf8->string (base64-encode-bytevector (string->utf8 str))))

(define (base64-encode-bytevector bv)
  (let* ((len (bytevector-length bv))
         (quot (quotient len 3))
         (rem (- len (* quot 3)))
         (res-len (arithmetic-shift (+ quot (if (zero? rem) 0 1)) 2))
         (res (make-bytevector res-len)))
    (base64-encode-bytevector! bv 0 len res)
    res))

(define (base64-encode-bytevector! bv start end res)
  (let* ((res-len (bytevector-length res))
         (limit (- end 2)))
    (let lp ((i start) (j 0))
      (if (>= i limit)
          (case (- end i)
            ((1)
             (let ((b1 (bytevector-u8-ref bv i)))
               (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
               (bytevector-u8-set!
                res
                (+ j 1)
                (enc (arithmetic-shift (bitwise-and #b11 b1) 4)))
               (bytevector-u8-set! res (+ j 2) (char->integer #\=))
               (bytevector-u8-set! res (+ j 3) (char->integer #\=))))
            ((2)
             (let ((b1 (bytevector-u8-ref bv i))
                   (b2 (bytevector-u8-ref bv (+ i 1))))
               (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
               (bytevector-u8-set!
                res
                (+ j 1)
                (enc (bitwise-ior
                      (arithmetic-shift (bitwise-and #b11 b1) 4)
                      (extract-bit-field 4 4 b2))))
               (bytevector-u8-set!
                res
                (+ j 2)
                (enc (arithmetic-shift (extract-bit-field 4 0 b2)
                                       2)))
               (bytevector-u8-set! res (+ j 3) (char->integer #\=)))))
          (let ((b1 (bytevector-u8-ref bv i))
                (b2 (bytevector-u8-ref bv (+ i 1)))
                (b3 (bytevector-u8-ref bv (+ i 2))))
            (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
            (bytevector-u8-set!
             res
             (+ j 1)
             (enc (bitwise-ior
                   (arithmetic-shift (bitwise-and #b11 b1) 4)
                   (extract-bit-field 4 4 b2))))
            (bytevector-u8-set!
             res
             (+ j 2)
             (enc (bitwise-ior
                   (arithmetic-shift (extract-bit-field 4 0 b2) 2)
                   (extract-bit-field 2 6 b3))))
            (bytevector-u8-set! res (+ j 3) (enc (bitwise-and #b111111 b3)))
            (lp (+ i 3) (+ j 4)))))))

;;>  Variation of the above to read and write to ports.

(define (base64-encode . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (out (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (current-output-port))))
    (cond
     ((not (binary-port? in))
      (write-string (base64-encode-string (port->string in)) out))
     (else
      (let ((src (make-string encode-src-length))
            (dst (make-string
                  (arithmetic-shift (quotient encode-src-length 3) 2))))
        (let lp ()
          (let ((n (read-bytevector! src in 0 2048)))
            (base64-encode-bytevector! src 0 n dst)
            (write-bytevector dst out 0 (* 3 (quotient (+ n 3) 4)))
            (if (= n 2048)
                (lp)))))))))

;;> Return a base64 encoded representation of the string \var{str} as
;;> above, wrapped in =?ENC?B?...?= as per RFC1522, split across
;;> multiple MIME-header lines as needed to keep each lines length
;;> less than \var{max-col}.  The string is encoded as is, and the
;;> encoding \var{enc} is just used for the prefix, i.e. you are
;;> responsible for ensuring \var{str} is already encoded according to
;;> \var{enc}.  The optional argument \var{nl} is the newline
;;> separator, defaulting to \var{crlf}.

(define (base64-encode-header encoding str . o)
  (define (round4 i) (arithmetic-shift (arithmetic-shift i -2) 2))
  (let ((start-col (if (pair? o) (car o) 0))
        (max-col (if (and (pair? o) (pair? (cdr o)))
                     (car (cdr o))
                     *default-max-col*))
        (nl (if (and (pair? o) (pair? (cdr o)) (pair? (cdr (cdr o))))
                (car (cdr (cdr o)))
                "\r\n")))
    (let* ((prefix (string-append "=?" encoding "?B?"))
           (prefix-length (+ 2 (string-length prefix)))
           (effective-max-col (round4 (- max-col prefix-length)))
           (first-max-col (round4 (- effective-max-col start-col)))
           (str (base64-encode-string str))
           (len (string-length str)))
      (if (<= len first-max-col)
          (string-append prefix str "?=")
          (string-append
           (if (positive? first-max-col)
               (string-append
                prefix (substring str 0 first-max-col) "?=" nl "\t" prefix)
               "")
           (string-concatenate (string-chop (substring str first-max-col len)
                                            effective-max-col)
                               (string-append "?=" nl "\t" prefix))
           "?=")))))


(define-library (chibi modules)
  (export module-name module-dir module-includes module-shared-includes
          module-include-library-declarations
          module-ast module-ast-set! module-ref module-contains?
          analyze-module containing-module load-module module-exports
          module-name->file procedure-analysis find-module
          available-modules-in-directory available-modules
          modules-exporting-identifier)
  (import (chibi) (meta) (srfi 1) (chibi ast) (chibi filesystem))
  (include "modules.scm"))
;; repl.scm - friendlier repl with line editing and signal handling
;; Copyright (c) 2012-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A user-friendly REPL with line editing and signal handling.  The
;;> default REPL provided by chibi-scheme is very minimal, meant
;;> primarily to be small and work on any platform.  This module
;;> provides an advanced REPL that handles vt100 line editing and
;;> signal handling, so that C-c will interrupt a computation and
;;> bring you back to the REPL prompt.  To use this repl, run
;;> \command{chibi-scheme -R} from the command line or within Emacs.

(define (with-signal-handler sig handler thunk)
  (let ((old-handler #f))
    (dynamic-wind
      (lambda () (set! old-handler (set-signal-action! sig handler)))
      thunk
      (lambda () (set-signal-action! sig old-handler)))))

(define (warn msg . args)
  (let ((out (current-error-port)))
    (display msg out)
    (for-each (lambda (x) (write-char #\space out) (write x out)) args)
    (newline out)))

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (complete-sexp? str)
  (call-with-input-string str
    (lambda (in)
      (let lp () (if (not (eof-object? (read/ss in))) (lp))))))

(define (read-line/complete-sexp in)
  (let lp ((res ""))
    (let ((line (read-line in)))
      (cond
       ((eof-object? line)
        (if (equal? res "") line res))
       (else
        (let ((res (string-append res line "\n")))
          (if (protect (exn (else #f)) (complete-sexp? res))
              res
              (lp res))))))))

(define (buffer-complete-sexp? buf)
  (complete-sexp? (buffer->string buf)))

(define module? vector?)
(define (module-env mod) (vector-ref mod 1))

(define (all-exports env)
  (let lp ((env env) (res '()))
    (if (not env)
        res
        (lp (env-parent env) (append (env-exports env) res)))))

(define (string-common-prefix-length strings)
  (if (null? strings)
      0
      (let lp ((len (string-length (car strings)))
               (prev (car strings))
               (ls (cdr strings)))
        (if (or (null? ls) (zero? len))
            len
            (lp (min len (string-mismatch prev (car ls)))
                (car ls)
                (cdr ls))))))

(define (make-sexp-buffer-completer)
  (buffer-make-completer
   (lambda (buf word)
     (let* ((len (string-length word))
            (candidates
             (filter
              (lambda (w)
                (and (>= (string-length w) len)
                     (equal? word (substring w 0 len))))
              (map symbol->string (all-exports (interaction-environment)))))
            (prefix-len (string-common-prefix-length candidates)))
       (if (> prefix-len len)
           (list (substring (car candidates) 0 prefix-len))
           (sort candidates))))))

(define (describe x . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (cond
     ((null? x)
      (display "empty list\n" out))
     ((list? x)
      (display "list of length " out) (write (length x) out) (newline out)
      (let lp ((ls x) (i 0))
        (cond
         ((pair? ls)
          (display " " out) (write i out) (display ": " out)
          (write/ss (car ls) out) (newline out)
          (lp (cdr ls) (+ i 1))))))
     ((pair? x)
      (display "pair with car " out) (write/ss (car x) out) (newline out)
      (display "and cdr " out) (write/ss (cdr x) out) (newline out))
     ((vector? x)
      (let ((len (vector-length x)))
        (display "vector of length " out) (write len out) (newline out)
        (let lp ((i 0))
          (cond
           ((< i len)
            (display " " out) (write i out) (display ": " out)
            (write/ss (vector-ref x i) out) (newline out)
            (lp (+ i 1)))))))
     ((boolean? x)
      (display (if x "boolean true\n" "boolean false\n") out))
     ((char? x)
      (let ((n (char->integer x)))
        (display "character " out) (write x out)
        (display ", code: " out) (write n out)
        (display ", #x" out) (display (number->string n 16) out)
        (display ", #o" out) (display (number->string n 8) out)
        (newline out)))
     ((and (integer? x) (exact? x))
      (display "exact integer " out) (write x out)
      (display "\n  #x" out) (display (number->string x 16) out)
      (display "\n  #o" out) (display (number->string x 8) out)
      (display "\n  #b" out) (display (number->string x 2) out)
      (newline out))
     (else
      (write/ss x out) (newline out)))))

;;> Runs an interactive REPL.  Repeatedly displays a prompt,
;;> then Reads an expression, Evaluates the expression, Prints
;;> the result then Loops.  Terminates when the end of input is
;;> reached or the \scheme|{\exit}| command is given.
;;>
;;> Basic Emacs-style line editing with persistent history
;;> completion is provided.  C-c can be used to interrupt the
;;> current computation and drop back to the prompt.  The
;;> following keyword arguments customize the REPL:
;;>
;;> \itemlist[
;;> \item{\scheme{in:} - the input port (default \scheme{(current-input-port)})}
;;> \item{\scheme{out:} - the output port (default \scheme{(current-output-port)})}
;;> \item{\scheme{module:} - the initial module}
;;> \item{\scheme{environment:} - the initial environment (default \scheme{(interaction-environment)})}
;;> \item{\scheme{escape:} - the command escape character (default \scheme|{#\\}|)}
;;> \item{\scheme{make-prompt:} - a procedure taking one argument (the current module name as a list) and returning a string to be used as the prompt}
;;> \item{\scheme{history:} - the initial command history}
;;> \item{\scheme{history-file:} - the file to save history to (default ~/.chibi-repl-history)}
;;> ]
;;>
;;> The module: and environment: keyword arguments should not both be given.
;;>
;;> REPL commands in the style of \hyperlink["http://s48.org/"]{Scheme48}
;;> are available to control out-of-band properties.  By default a
;;> command is written as an identifier beginning with an "@"
;;> character, but this can be customized with the \scheme{escape:}
;;> keyword.  The following commands are available:
;;>
;;> \itemlist[
;;> \item{\scheme|{\import <import-spec>}| - import the \var{<import-spec>} in the \scheme{interaction-environment}, useful if the \scheme{import} binding is not available}
;;> \item{\scheme|{\import-only <import-spec>}| - replace the \scheme{interaction-environment} with the given \var{<import-spec>}}
;;> \item{\scheme|{\in [<module>]}| - switch to \var{<module>}, or the \scheme{interaction-environment} if \var{<module>} is not specified}
;;> \item{\scheme|{\meta <expr>}| - evaluate \var{<expr>} in the \scheme{(meta)} module}
;;> \item{\scheme|{\meta-module-is <module>}| - switch the meta module to \var{<module>}}
;;> \item{\scheme|{\exit}| - exit the REPL}
;;> ]

(define-record-type Repl
  (make-repl
   in out escape module env meta-env make-prompt history-file history raw?)
  repl?
  (in repl-in repl-in-set!)
  (out repl-out repl-out-set!)
  (escape repl-escape repl-escape-set!)
  (module repl-module repl-module-set!)
  (env repl-env repl-env-set!)
  (meta-env repl-meta-env  repl-meta-env-set!)
  (make-prompt repl-make-prompt repl-make-prompt-set!)
  (history-file repl-history-file repl-history-file-set!)
  (history repl-history repl-history-set!)
  (raw? repl-raw? repl-raw?-set!))

(define (repl/import-aux rp args meta continue only?)
  (let* ((mod-name (cadr args))
         (mod+imps (eval `(resolve-import ',mod-name) (repl-meta-env rp))))
    (cond
     ((pair? mod+imps)
      (protect
          (exn
           (else
            (print-exception exn (current-error-port))
            (warn "error loading module:" mod-name)
            (continue rp)))
        (let ((env (if only? (make-environment) (repl-env rp)))
              (imp-env
               (module-env
                (eval `(load-module ',(car mod+imps)) (repl-meta-env rp)))))
          (%import env imp-env (cdr mod+imps) #f)
          (repl-env-set! rp env)
          (continue rp))))
     (else
      (warn "couldn't find module:" mod-name)
      (continue rp)))))

(define (repl/import rp args meta continue)
  (repl/import-aux rp args meta continue #f))

(define (repl/import-only rp args meta continue)
  (repl/import-aux rp args meta continue #t))

(define (repl/in rp args meta continue)
  (cond
   ((null? (cdr args))
    (repl-module-set! rp #f)
    (repl-env-set! rp (interaction-environment)))
   ((eval `(load-module ',(cadr args)) (repl-meta-env rp))
    => (lambda (m)
         (repl-module-set! rp (cadr args))
         (repl-env-set! rp (module-env m))))
   (else
    (warn "couldn't find module:" (cadr args))))
  (continue rp))

(define (repl/meta rp args meta continue)
  (cond
   ((null? (cdr args))
    (warn "usage: @meta <expr>")
    (continue rp))
   ((and (symbol? (cadr args))
         (eqv? (repl-escape rp) (string-ref (symbol->string (cadr args)) 0)))
    (meta rp (cdr args) (lambda _ (continue rp))))
   (else
    (eval (cadr args) (repl-meta-env rp))
    (continue rp))))

(define (repl/meta-module-is rp args meta continue)
  (cond
   ((null? (cdr args))
    (warn "usage: @meta-module-is <module>"))
   ((eval `(load-module ',(cadr args)) (repl-meta-env rp))
    => (lambda (m) (repl-meta-env-set! rp (module-env m))))
   (else
    (warn "couldn't find module:" (cadr args))))
  (continue rp))

(define (repl/help rp args meta continue)
  (let ((out (repl-out rp)))
    (cond
     ((null? (cdr args))
      (display "Try @help <identifier> [<module>]\n" out))
     ((null? (cddr args))
      (let* ((failed (list 'failed))
             (val (protect (exn (else (print-exception exn) failed))
                    (eval (second args) (repl-env rp))))
             (mod (and (procedure? val) (containing-module val))))
        (cond
         (mod
          (write val out) (newline out) (newline out)
          (print-module-binding-docs (car mod) (second args) out))
         ((not (eq? val failed))
          (describe val out)))))
     (else
      (protect (exn (else (print-exception exn (current-error-port))))
        (print-module-binding-docs (third args) (second args) out))))
    (continue rp)))

(define (repl/exit rp args meta continue)
  ;; To exit the repl simply don't call continue.
  #f)

;; Utility to read all objects from a port accumulated into a list.
(define (read/ss/all port)
  (let loop ((l '()))
    (let ((x (read/ss port)))
      (if (eof-object? x)
        (reverse l)
        (loop (cons x l))))))

(define (string->sexp-list str)
  (call-with-input-string str read/ss/all))

;; Utility to provide additional help for common exceptions.
(define (repl-advise-exception exn out)
  (cond
   ((and (exception? exn)
         (equal? "undefined variable" (exception-message exn))
         (pair? (exception-irritants exn)))
    (let ((name (car (exception-irritants exn))))
      (cond
       ((identifier? name)
        (display "Searching for modules exporting " out)
        (display name out)
        (display " ...\n" out)
        (let ((mods (modules-exporting-identifier name)))
          (cond
           ((pair? mods)
            (display name out)
            (display " is exported by:\n")
            (for-each
             (lambda (m)
               (display "  " out) (write m out) (newline out))
             (sort (map car mods)
                   (lambda (a b)
                     (string<? (write-to-string a) (write-to-string b))))))
           (else
            (display "... none found.\n"))))))))))

(define (repl/eval rp expr-list)
  (let ((out (repl-out rp)))
    (protect (exn (else (print-exception exn out)))
      (let ((thread
             (make-thread
              (lambda ()
                ;; The inner protect in the child thread catches errors
                ;; from eval.
                (protect (exn
                          (else
                           (print-exception exn out)
                           (repl-advise-exception exn (current-error-port))))
                  (for-each
                   (lambda (expr)
                     (call-with-values (lambda () (eval expr (repl-env rp)))
                       (lambda res-list
                         (cond
                          ((not (or (null? res-list)
                                    (equal? res-list (list (if #f #f)))))
                           (write/ss (car res-list) out)
                           (for-each
                            (lambda (res)
                              (write-char #\space out)
                              (write/ss res out))
                            (cdr res-list))
                           (newline out))))))
                   expr-list))))))
        ;; If an interrupt occurs while the child thread is
        ;; still running, terminate it, otherwise wait for it
        ;; to complete.
        (with-signal-handler
         signal/interrupt
         (lambda (n)
           (display "\nInterrupt\n" out)
           (thread-terminate! thread))
         (lambda () (thread-join! (thread-start! thread))))))))

(define (repl/eval-string rp str)
  (repl/eval
   rp
   (protect (exn (else (print-exception exn (current-error-port))))
     ;; Ugly wrapper to account for the implicit state mutation
     ;; implied by the #!fold-case read syntax.
     (let ((in (repl-in rp))
           (in2 (open-input-string str)))
       (set-port-fold-case! in2 (port-fold-case? in))
       (set-port-line! in2 (port-line in))
       (let ((expr-list (read/ss/all in2)))
         (set-port-fold-case! in (port-fold-case? in2))
         expr-list)))))

(define (keywords->repl ls)
  (let-keywords* ls
      ((in in: (current-input-port))
       (out out: (current-output-port))
       (escape escape: #\@)
       (module module: #f)
       (env
        environment:
        (if module
            (module-env
             (if (module? module) module (load-module module)))
            (interaction-environment)))
       (make-prompt
        make-prompt:
        (lambda (module)
          (string-append (if module (write-to-string module) "") "> ")))
       (history-file
        history-file:
        (string-append (get-environment-variable "HOME")
                       "/.chibi-repl-history"))
       (history
        history:
        (or (protect (exn (else #f))
              (list->history (call-with-input-file history-file read)))
            (make-history)))
       (raw? raw?:
             (member (get-environment-variable "TERM") '("emacs" "dumb")))
       (meta-env meta-env: (module-env (load-module '(meta)))))
    (make-repl
     in out escape module env meta-env make-prompt history-file history raw?)))

(define (repl/edit-line rp)
  (let ((prompt ((repl-make-prompt rp) (repl-module rp)))
        (in (repl-in rp))
        (out (repl-out rp)))
    (cond
     ((repl-raw? rp)
      (display prompt out)
      (flush-output out)
      (read-line/complete-sexp in))
     (else
      (edit-line in out
                 'prompt: prompt
                 'history: (repl-history rp)
                 'complete?: buffer-complete-sexp?
                 'completion: (make-sexp-buffer-completer)
                 'catch-control-c?: #t
                 'fresh-line: " \x1B;[33m\\\x1B;[0m")))))

(define repl-commands
  `((import . ,repl/import)
    (import-only . ,repl/import-only)
    (in . ,repl/in)
    (meta . ,repl/meta)
    (meta-module-is . ,repl/meta-module-is)
    (? . ,repl/help)
    (h . ,repl/help)
    (help . ,repl/help)
    (exit . ,repl/exit)))

(define (repl . o)
  (let ((rp (keywords->repl o)))
    (let lp ((rp rp))
      (let ((line (repl/edit-line rp)))
        (cond
         ((or (not line) (eof-object? line)))
         ((equal? line "")
          (history-reset! (repl-history rp))
          (lp rp))
         (else
          (history-commit! (repl-history rp) line)
          (cond
           ((and (> (string-length line) 1)
                 (eqv? (repl-escape rp) (string-ref line 0)))
            ;; @ escaped command
            (let meta ((rp rp)
                       (args (string->sexp-list (substring line 1)))
                       (continue lp))
              (cond
               ((null? args)
                (warn "empty repl command")
                (continue rp))
               ((assq (car args) repl-commands)
                => (lambda (x) ((cdr x) rp args meta continue)))
               (else
                (warn "unknown repl command" (car args))
                (continue rp)))))
           (else
            ;; Normal expression to eval.
            (repl/eval-string rp line)
            (lp rp)))))))
    ;; Update the history file on completion.
    (if (repl-history-file rp)
        (protect
            (exn
             (else
              (let ((msg (integer->error-string)))
                (display "couldn't save repl history: " (current-error-port))
                (display msg (current-error-port))
                (newline (current-error-port)))))
          (call-with-output-file (repl-history-file rp)
            (lambda (out) (write (history->list (repl-history rp)) out)))))))

(define (main args)
  (repl))

(define-library (chibi char-set ascii)
  (import (chibi) (chibi iset base) (chibi char-set base))
  (export char-set:lower-case  char-set:upper-case  char-set:title-case
          char-set:letter      char-set:digit       char-set:letter+digit
          char-set:graphic     char-set:printing    char-set:whitespace
          char-set:iso-control char-set:punctuation char-set:symbol
          char-set:hex-digit   char-set:blank)
  (include "ascii.scm"))

(define (char-set . args)
  (list->char-set args))

;; This is a mistake in the SRFI-14 design - end should be inclusive.
(define (ucs-range->char-set start end)
  (make-iset start (- end 1)))

(define char-set-copy iset-copy)

(define char-set-size iset-size)

(define (char-set-fold kons knil cset)
  (iset-fold (lambda (i acc) (kons (integer->char i) acc)) knil cset))

(define (char-set-for-each proc cset)
  (iset-for-each (lambda (i) (proc (integer->char i))) cset))

(define (list->char-set ls)
  (list->iset (map char->integer ls)))
(define (char-set->list cset)
  (map integer->char (iset->list cset)))

(define (string->char-set str)
  (list->char-set (string->list str)))
(define (char-set->string cset)
  (list->string (char-set->list cset)))

(define (char-set-adjoin! cset ch)
  (iset-adjoin! cset (char->integer ch)))
(define (char-set-adjoin cset ch)
  (iset-adjoin cset (char->integer ch)))

(define char-set-union iset-union)
(define char-set-union! iset-union!)
(define char-set-intersection iset-intersection)
(define char-set-intersection! iset-intersection!)
(define char-set-difference iset-difference)
(define char-set-difference! iset-difference!)

(define char-set:empty (immutable-char-set (%make-iset 0 0 0 #f #f)))
(define char-set:ascii (immutable-char-set (%make-iset 0 #x7F #f #f #f)))

(cond-expand
 (full-unicode
  (define char-set:full
    (immutable-char-set
     (%make-iset 0 #xD7FF #f #f (%make-iset #xE000 #x10FFFD #f #f #f)))))
 (else
  (define char-set:full (immutable-char-set (%make-iset 0 #xFF #f #f #f)))))

(define (char-set-complement cset)
  (char-set-difference char-set:full cset))
;; char-set:lower-case
(define char-set:lower-case (immutable-char-set (%make-iset 11312 11557 113078212145405220956299481848306876004857152314519694622414813644330106879 (%make-iset 7424 7615 6277101735386680763834460195211881500229451637403754168319 (%make-iset 891 1231 3359617113266706315836163420852667279900761594669382740612734659380575149118011965863067042895076786183 (%make-iset 591 740 1382646202340133545564837515061266821645598719 (%make-iset 97 576 2365509536875796115271152425453441351280931286999514252096600828646551318540912334052744481790519950100366591329056407886414129454316222836375551 #f #f) #f) (%make-iset 1377 1415 #f #f #f)) (%make-iset 8336 8575 1766820104831717270911194217800685387968293958678012717949960101612756991 (%make-iset 7829 8183 63072327451413996121415570261819623312617164997438933550707549860292318813601613991411837156872431794651647 #f #f) (%make-iset 9424 9449 #f #f #f))) (%make-iset 65345 65370 #f (%make-iset 43000 43001 #f (%make-iset 42799 42872 18815678955183742648327 #f #f) (%make-iset 64256 64279 16253055 #f #f)) (%make-iset 119834 120327 51146727486231585908820696036815651831314948480676177501992199236163085036512359821035265912047941451080432971005274950492488384578638513597382131711 (%make-iset 66600 66639 #f #f #f) (%make-iset 120354 120777 42984503304530211461104808282321868720026385944674536297193504244060802094551012793517930744128497289034962077133152853331804159 #f #f))))))

;; char-set:upper-case
(define char-set:upper-case (immutable-char-set (%make-iset 9398 9423 #f (%make-iset 1216 1366 2854495385401535168399502283641929280107053059 (%make-iset 376 582 193510492298500594587530311832788051917914503280678853822825987 (%make-iset 65 222 363948161469878586209393690477933956061783392255 #f #f) (%make-iset 904 1071 374144419156711012060424995402076372759432889630407 #f #f)) (%make-iset 7944 8187 1736907842101479124536426275495535083658609664624882011531376654293716462141695 (%make-iset 4256 4293 #f #f #f) (%make-iset 8459 8559 2535262514830237892353053933799 #f #f))) (%make-iset 66560 66599 #f (%make-iset 42877 42878 #f (%make-iset 11264 11392 595503879886640614262110651042930622463 #f #f) (%make-iset 65313 65338 #f #f #f)) (%make-iset 120328 120744 338460645933693697560665215760249528245999403264098033404085806319476851798827321172475719366475085497933670543086984716353535 (%make-iset 119808 120301 51146727486231585908820696036815651831314948480394089408712024707913450654934185184668161964607423236491353583631673266179433585099917637254106841087 #f #f) #f)))))

;; char-set:title-case
(define char-set:title-case (immutable-char-set (%make-iset 8072 8188 83076749736557537208897815481090303 (%make-iset 453 498 35184372088905 #f #f) #f)))

;; char-set:letter
(define char-set:letter (immutable-char-set (%make-iset 44032 55203 #f (%make-iset 6912 7414 22886562555891042693710382455505074355841760073166317418421820388451117221729500954464088123708152923721508489525154758089698131078348046953168412606447 (%make-iset 3913 4346 44362715105927999221712262984342111652617098472873236058512408135598431308732685725527979136265102154321118707789398691204023975935 (%make-iset 1869 2380 13407424329480734270447878660048428920496373804417168083627602288254107168259292949124979141882146787383731347613928737074953757721179033264662499184082943 (%make-iset 880 1366 399583814438996167382020011346842847816169115710121343500162631807336209279770003226660543306154439487482399564906606488253101298916621286954252495 (%make-iset 452 740 963565667247331348724662781356953235953225866953231882562121816871620562685859362504703 (%make-iset 65 451 314600393224337169960540460799584166474933543237622550739399649019542269878494744694979332000092312996040451282698239 #f #f) #f) (%make-iset 1377 1855 1560874275157973934342501410334434064559112153595576892194119830209925249809262307688780388207250242577643819833026382406056630315346898446188543 #f #f)) (%make-iset 2908 3404 381991200485141231019756222367537226053710584749387702525493540482928266985181611648107653982490012918979831010671369935541658005339438249753284968699 (%make-iset 2382 2892 5366736463464336406706714106425487149575078127243771493347988908203826370682080174911419639786360015702762728603625228669492029470702181043482460663316355 #f #f) (%make-iset 3424 3911 796045880330578019002307293597294347346987043146984104137316595631780707567417231169995506839382805294177527833722740156565765733950441790015275023 #f #f))) (%make-iset 5121 5740 #f (%make-iset 4682 4822 2787528182814337039150675927861957382578127 (%make-iset 4349 4680 #f #f #f) (%make-iset 4824 5108 62165404551223330269422779455378792455782943721961461362086716517957521327837304324095 #f #f)) (%make-iset 6212 6683 12194330229244424385358936041275179229938106075909171049697737889247539090636773541118657721546749280855637804188578406358228684801308538961919 (%make-iset 5743 6210 762145642144808933311681242303344929266684400897434715282060471834151313118761625963263953770881497968694418657905208578955948716669007691775 #f #f) (%make-iset 6688 6772 38685487814037185985773567 #f #f)))) (%make-iset 19968 40908 #f (%make-iset 9398 9449 #f (%make-iset 7680 8188 1669429210027032353070387959902572074068251569912541634239543664469254840701605815586298160569854604812755249439701457169906905863833481177213265564925951 (%make-iset 7424 7615 6277101735386680763834460195211881500229451637403754168319 #f #f) (%make-iset 8336 8584 904625697166121400702423284964750605108746128179460890055734500600385118207 #f #f)) (%make-iset 12321 12799 1560850458106678397246853318509506420346053090363696722427379182288726125506853871807416126725592575693831523564009034418563951096328109074350591 (%make-iset 11264 11775 1716199415031085457304815023196129625190876140284840059163076939411632061379695825768761320243048559913035261692194332965927453391792248614786550156348096511 #f #f) (%make-iset 13312 19893 #f #f #f))) (%make-iset 42656 43137 9366007796590143684266426014173832021882860391206691228341429856634888413055477646498624449482500722743196759142345085250473767233032902320062463 (%make-iset 40982 42124 #f (%make-iset 40960 40980 #f #f #f) (%make-iset 42192 42647 186070703019498633361408888448075376716851403313694244648522839560594426772554545643464113891391655073968019319443321956603475346266783743 #f #f)) (%make-iset 43648 43822 47701954761756259097387504798417463778755529815359487 (%make-iset 43138 43638 6495633707107511592130816216430842683164567658071841769919061558009539875610149675919448576995054309973657727503245554791947025664158092800029345447935 #f #f) (%make-iset 43968 44010 7559142440959 #f #f))))) (%make-iset 71296 71349 17952825858326527 (%make-iset 65536 65908 354901720847464262643270080013918741494457029505007323037992842993478140487429303646626346434630199938330987804055257434518162763775 (%make-iset 64256 64433 383123885216472214589586756787576615644966064332734591 (%make-iset 63744 64109 #f (%make-iset 55216 55291 75557863725914197590015 #f #f) (%make-iset 64112 64217 #f #f #f)) (%make-iset 64848 64967 341611594916723379280938182270919901183 (%make-iset 64467 64829 #f #f #f) (%make-iset 65008 65500 23166459242184795109519745412560813317707843523172326996034783221158488630072272676325665038195628414381257440134258275967737233656228847161199038463 #f #f))) (%make-iset 67840 68220 4925250765375315437575115447282545225619899143486530057386523691675827454339457238250572167562730571287653355880447 (%make-iset 66640 66717 #f (%make-iset 66176 66639 878680692688788100968217104054132723536510135400456683066998889497980605885632024127229627367624962058724496859707859793938161524087860595782141042536975695871 #f #f) (%make-iset 67584 67669 77371243358065019892792383 #f #f)) (%make-iset 68608 68680 #f (%make-iset 68352 68466 1427247352465131255837309846865400673685471231 #f #f) (%make-iset 69635 70084 204586912993508730593563550625432944389072422914203271589172564161864958211730995356562955949992950450193086469961732181890394864571677076213876129791 #f #f)))) (%make-iset 120146 120485 #f (%make-iset 92160 92728 #f (%make-iset 74752 74850 #f (%make-iset 73728 74606 #f #f #f) (%make-iset 77824 78894 #f #f #f)) (%make-iset 110592 110593 #f (%make-iset 93952 94111 1461323231539455856679019361440445717580125044735 #f #f) (%make-iset 119808 120144 1221462192088229133428742507380976417683660481320862010013722843488511299179635651402650638514783282651558855669972991 #f #f))) (%make-iset 131072 173782 #f (%make-iset 120656 120779 21226109557071405325645863666178850815 (%make-iset 120488 120654 187072206790762423064706648907459429699768891211775 #f #f) (%make-iset 126464 126651 6421867392636242726356536395708148792154285362342779204665327 #f #f)) (%make-iset 177984 178205 #f (%make-iset 173824 177972 #f #f #f) (%make-iset 194560 195101 #f #f #f))))))))

;; char-set:punctuation
(define char-set:punctuation (immutable-char-set (%make-iset 10627 10749 7975367975289779630837864365545226239 (%make-iset 5120 5120 #f (%make-iset 2800 2800 #f (%make-iset 1370 1805 177440029682739492195629626423414285791075425806584367987188710887245779556727828964224741026149370230681856791701409903272452423743 (%make-iset 894 903 513 (%make-iset 33 191 6277101735777033378358367027585284040564796057489604901879 #f #f) #f) (%make-iset 2404 2416 4099 (%make-iset 2039 2142 10141204806548057579655195000839 #f #f) #f)) (%make-iset 4347 4347 #f (%make-iset 3844 4175 8612299728833109452216727519275634166367255279803428156814546022481552546661143084834195942383124479 (%make-iset 3572 3675 15214283082817323578510236712961 #f #f) #f) (%make-iset 4960 4968 #f #f #f))) (%make-iset 7002 7008 #f (%make-iset 6468 6469 #f (%make-iset 6100 6154 36011204832919671 (%make-iset 5741 5942 4820814132776970826626481771165599449877669887122490332807171 #f #f) #f) (%make-iset 6816 6829 16255 (%make-iset 6686 6687 #f #f #f) #f)) (%make-iset 9001 9002 #f (%make-iset 8208 8334 127607834706674478748244504138880122879 (%make-iset 7164 7379 52681756409358971006475467946070306489686807156907791211684691983 #f #f) #f) (%make-iset 10088 10223 87027215340059722591700904977272299077631 #f #f)))) (%make-iset 65281 65381 2521683860030948918624327334903 (%make-iset 43124 43615 11987514433213410168505333362405758614102799522152940711615041872404225459959956214682136066587259816913167135759024198010248565942507088814987542543 (%make-iset 12289 12539 1809251394333065553493296641491499378872794969502476229475819322195851214727 (%make-iset 11776 11835 1152780767118491647 (%make-iset 11513 11632 664613997892457936451903530140172399 #f #f) #f) (%make-iset 42509 42743 54351252480975689826048702415431575448442147475312362296571857733681159 (%make-iset 42238 42239 #f #f #f) #f)) (%make-iset 64830 64831 #f (%make-iset 44011 44011 #f (%make-iset 43742 43761 786435 #f #f) #f) (%make-iset 65040 65131 4037812089938908849547248639 #f #f))) (%make-iset 68176 68223 140737488355839 (%make-iset 67671 67671 #f (%make-iset 66463 66512 562949953421313 (%make-iset 65792 65794 #f #f #f) #f) (%make-iset 67871 67903 4294967297 #f #f)) (%make-iset 70085 70088 #f (%make-iset 69703 69955 13569385457497991651199724805705614201565294768222350139146883642703225028735 (%make-iset 68409 68415 #f #f #f) #f) (%make-iset 74864 74867 #f #f #f)))))))

;; char-set:symbol
(define char-set:symbol (immutable-char-set (%make-iset 10750 11084 #f (%make-iset 4254 4255 #f (%make-iset 2801 2928 170141183460469231731687303715884105729 (%make-iset 1423 1551 536343496299213554716686148823119036417 (%make-iset 706 1014 521481209941628438084722096232800884555162981189081790621504207040293760564100563907364454415 (%make-iset 36 247 3291009115408659855127328282852688335858940725263447471358476417 #f #f) (%make-iset 1154 1154 #f #f #f)) (%make-iset 2038 2038 #f (%make-iset 1758 1790 6442452993 #f #f) (%make-iset 2546 2555 771 #f #f))) (%make-iset 3647 3647 #f (%make-iset 3199 3199 #f (%make-iset 3059 3066 #f #f #f) (%make-iset 3449 3449 #f #f #f)) (%make-iset 4030 4056 126058239 (%make-iset 3841 3896 47287798208921607 #f #f) #f))) (%make-iset 8592 9000 #f (%make-iset 6622 6655 #f (%make-iset 6107 6107 #f (%make-iset 5008 5017 #f #f #f) (%make-iset 6464 6464 #f #f #f)) (%make-iset 8125 8527 15180504508302547082559792549452134039979727921597050291198905168453617261872958515620728168035045459212134851764818477085 (%make-iset 7009 7036 267912191 #f #f) #f)) (%make-iset 10224 10626 #f (%make-iset 9472 9983 #f (%make-iset 9003 9449 363419362147803445274660701490199886974208000930090554402992578672453439413725018135787913021374683400778402767997805117095404640403455 #f #f) (%make-iset 9985 10213 862718293047519590130783627714548701007576706064464912086123449155583 #f #f)) (%make-iset 10716 10749 4294967295 (%make-iset 10649 10711 #f #f #f) #f)))) (%make-iset 65020 65129 796084576943328064139929612976131 (%make-iset 19904 19967 #f (%make-iset 12443 12444 #f (%make-iset 11493 11498 #f (%make-iset 11088 11097 #f #f #f) (%make-iset 11904 12351 547258453716185545689710299454841531346882567525409776024515836385994490529377606833512566938465691840048809561654146263061905633443839 #f #f)) (%make-iset 13056 13311 #f (%make-iset 12688 13054 300613450595050653137261935414156179889591998741512647513967970216935158771592840931503642564904187380807827395 #f #f) #f)) (%make-iset 43639 43641 #f (%make-iset 42752 42890 522673715590561479879743397015208866086911 (%make-iset 42128 42182 #f #f #f) (%make-iset 43048 43065 245775 #f #f)) (%make-iset 64434 64449 #f (%make-iset 64297 64297 #f #f #f) #f))) (%make-iset 120513 120771 463168363851011130091785795673740600836767278013411671357985905734243019915265 (%make-iset 118784 119261 780437137578995458467560908739391556888996158179266522929460546508236933653296437157060350808521225678016835714111230592247297551268494937423871 (%make-iset 65504 65533 805339007 (%make-iset 65284 65374 1547425050547877224499904641 #f #f) (%make-iset 65847 66044 401734511064736150903948875408776876244564738538201663144447 #f #f)) (%make-iset 119552 119638 #f (%make-iset 119296 119365 664082786653543858175 #f #f) #f)) (%make-iset 127744 128252 1623601741516486367526542089626489179499454454837360135582644525057721907975405279813447049733043276512275822980244041212191896116171460908759068350349311 (%make-iset 126976 127386 5288447750321425141395456744287458546996189758388629186172721346534510152156602991240248150625623449590204448175840041107455 (%make-iset 126704 126705 #f #f #f) (%make-iset 127462 127569 244021541289521102071576548868095 #f #f)) (%make-iset 128507 128883 307828173409331868845930000782371979146838607456393061394578876014578854359990151589006733868359031372480153387007 (%make-iset 128256 128359 5104235524096485346957782767918670413823 #f #f) #f)))))))

;; char-set:blank
(define char-set:blank (immutable-char-set (%make-iset 6158 6158 #f (%make-iset 160 160 #f (%make-iset 9 32 8388609 #f #f) (%make-iset 5760 5760 #f #f #f)) (%make-iset 12288 12288 #f (%make-iset 8192 8287 39614081257132309534260332543 #f #f) #f))))

;; char-set:whitespace
(define char-set:whitespace (immutable-char-set (%make-iset 6158 6158 #f (%make-iset 160 160 #f (%make-iset 9 32 8388639 #f #f) (%make-iset 5760 5760 #f #f #f)) (%make-iset 12288 12288 #f (%make-iset 8192 8287 39614081257132312832795215871 #f #f) #f))))

;; char-set:digit
(define char-set:digit (immutable-char-set (%make-iset 6992 7097 81050410252092417358195461194751 (%make-iset 3430 3439 #f (%make-iset 1984 1993 #f (%make-iset 1632 1641 #f (%make-iset 48 57 #f #f #f) (%make-iset 1776 1785 #f #f #f)) (%make-iset 2918 3311 743556014954405849072266507808340190880121684743320383604969609548181369962480481034346862340233244904693236621235324859507752652901450751 (%make-iset 2406 2799 743556014954405849072266507808340190880121684743320383604969609548181369962480481034346862340233244904693236621235324859507752652901450751 #f #f) #f)) (%make-iset 6470 6479 #f (%make-iset 4160 4249 1236731113465765645724419071 (%make-iset 3664 3881 420844212009973745855555120560483693212126493377631139457593771007 #f #f) (%make-iset 6112 6169 287948901175002111 #f #f)) (%make-iset 6784 6809 67044351 (%make-iset 6608 6617 #f #f #f) #f))) (%make-iset 66720 66729 #f (%make-iset 43472 43609 6421475075300574421752121441301562791795741843089406187013119 (%make-iset 42528 42537 #f (%make-iset 7232 7257 67044351 #f #f) (%make-iset 43216 43273 287948901175002111 #f #f)) (%make-iset 65296 65305 #f (%make-iset 44016 44025 #f #f #f) #f)) (%make-iset 70096 70105 #f (%make-iset 69872 69951 1207745227993911763403775 (%make-iset 69734 69743 #f #f #f) #f) (%make-iset 120782 120831 #f (%make-iset 71360 71369 #f #f #f) #f))))))

;; char-set:letter+digit
(define char-set:letter+digit (immutable-char-set (%make-iset 44032 55203 #f (%make-iset 6912 7414 22886562555891042693710382458146756289377006471936556892838923982807328844367070294241793956553485968351753386046618718102707539530518625959993520685039 (%make-iset 3913 4346 44362715105927999221712262984621806339048726122702370012163096018033725502663463203116646689073826286574787756247207860776650932223 (%make-iset 1869 2380 13407424329480734270447878660048428920496373804417168083627602288254107168259292949124979141882146787383731347613928779568711247970208345158244457521348607 (%make-iset 880 1366 399583814438996167382020011346842847816169115710121343500162631807336209279770003226660543306154439487482399564906606488253101298916621286954252495 (%make-iset 452 740 963565667247331348724662781356953235953225866953231882562121816871620562685859362504703 (%make-iset 48 451 41235302740700321541067959277923095868202489379241662970514590796289444397514063176660331003916099649017014030525823583231 #f #f) #f) (%make-iset 1377 1855 1560874275157973934343822231147075518302721156252056432767839474782185051280962423908807488297855721715644480587704321413018649007858524599877631 #f #f)) (%make-iset 2908 3404 381991200485141231019756222408812876448756014237186533546277447507183436269917901262081454044646810274583365631168335787645676728618713947476107197691 (%make-iset 2382 2892 5366736463561891048904088864332422319078538891026511232750792789353571719231492410784884055633496549297705163924592108787908229198392583314950938978942851 #f #f) (%make-iset 3424 3911 796045881074145379721101485003658612742377112762910063541249941107066206101891013710754591976857025636790244447628442609572802972081506968078974927 #f #f))) (%make-iset 5121 5740 #f (%make-iset 4682 4822 2787528182814337039150675927861957382578127 (%make-iset 4349 4680 #f #f #f) (%make-iset 4824 5108 62165404551223330269422779455378792455782943721961461362086716517957521327837304324095 #f #f)) (%make-iset 6212 6683 12194330229244424385524038642855360947889231407969113621412693927197786728086255496979946034430370000318048005765115268416095504239842568437759 (%make-iset 5743 6210 762145642145155178562790324783619807494011846352632466837216562044788852063159421730556579887606746611010843054583947091606179550442951671807 #f #f) (%make-iset 6688 6809 5311800736730066244218093126239125503 #f #f)))) (%make-iset 19968 40908 #f (%make-iset 9398 9449 #f (%make-iset 7680 8188 1669429210027032353070387959902572074068251569912541634239543664469254840701605815586298160569854604812755249439701457169906905863833481177213265564925951 (%make-iset 7424 7615 6277101735386680763834460195211881500229451637403754168319 #f #f) (%make-iset 8336 8584 904625697166121400702423284964750605108746128179460890055734500600385118207 #f #f)) (%make-iset 12321 12799 1560850458106678397246853318509506420346053090363696722427379182288726125506853871807416126725592575693831523564009034418563951096328109074350591 (%make-iset 11264 11775 1716199415031085457304815023196129625190876140284840059163076939411632061379695825768761320243048559913035261692194332965927453391792248614786550156348096511 #f #f) (%make-iset 13312 19893 #f #f #f))) (%make-iset 42656 43137 9366007796590143684266426014173832021882860391206691228341429856634888413055477646498624449482500722743196759142345085250473767233032902320062463 (%make-iset 40982 42124 #f (%make-iset 40960 40980 #f #f #f) (%make-iset 42192 42647 186070703019498633361408888448075519920530856307050957164988653405500459175263525083868751559444797946410782900983767246458201399646748671 #f #f)) (%make-iset 43648 43822 47701954761756259097387504798417463778755529815359487 (%make-iset 43138 43638 224726016208531273348937437899872290007502680726266932355584409924411794087837267452460956059789185107995855861761463319664142696520594339463520992995707994505215 #f #f) (%make-iset 43968 44025 287956460317442047 #f #f))))) (%make-iset 71296 71369 348108861360120048141903260542929609949183 (%make-iset 65536 65908 354901720847464262643270080013918741494457029505007323037992842993478140487429303646626346434630199938330987804055257434518162763775 (%make-iset 64256 64433 383123885216472214589586756787576615644966064332734591 (%make-iset 63744 64109 #f (%make-iset 55216 55291 75557863725914197590015 #f #f) (%make-iset 64112 64217 #f #f #f)) (%make-iset 64848 64967 341611594916723379280938182270919901183 (%make-iset 64467 64829 #f #f #f) (%make-iset 65008 65500 23166459242184795109519745412560813317707843523172326996035291982829335841807197632365519235915051181023523126849199870616098935821672668804369354751 #f #f))) (%make-iset 67840 68220 4925250765375315437575115447282545225619899143486530057386523691675827454339457238250572167562730571287653355880447 (%make-iset 66640 66729 1237033344920669303018094591 (%make-iset 66176 66639 878680692688788100968217104054132723536510135400456683066998889497980605885632024127229627367624962058724496859707859793938161524087860595782141042536975695871 #f #f) (%make-iset 67584 67669 77371243358065019892792383 #f #f)) (%make-iset 68608 68680 #f (%make-iset 68352 68466 1427247352465131255837309846865400673685471231 #f #f) (%make-iset 69635 70105 204586912993508730593563550625432944389072422914203271855910203047007904292292283148049105766861891958292943578471947333866751571791177989246645436415 #f #f)))) (%make-iset 120146 120485 #f (%make-iset 92160 92728 #f (%make-iset 74752 74850 #f (%make-iset 73728 74606 #f #f #f) (%make-iset 77824 78894 #f #f #f)) (%make-iset 110592 110593 #f (%make-iset 93952 94111 1461323231539455856679019361440445717580125044735 #f #f) (%make-iset 119808 120144 1221462192088229133428742507380976417683660481320862010013722843488511299179635651402650638514783282651558855669972991 #f #f))) (%make-iset 131072 173782 #f (%make-iset 120656 120831 95780971304117989802914516033683783778383003373273087 (%make-iset 120488 120654 187072206790762423064706648907459429699768891211775 #f #f) (%make-iset 126464 126651 6421867392636242726356536395708148792154285362342779204665327 #f #f)) (%make-iset 177984 178205 #f (%make-iset 173824 177972 #f #f #f) (%make-iset 194560 195101 #f #f #f))))))))

;; char-set:hex-digit
(define char-set:hex-digit (immutable-char-set (%make-iset 48 102 35465847073801215 #f #f)))

;; char-set:iso-control
(define char-set:iso-control (immutable-char-set (%make-iset 0 159 1461501637160761734743215600984595715944343404543 #f #f)))

;; char-set:graphic
(define char-set:graphic (immutable-char-set (%make-iset 4960 4968 #f (%make-iset 64848 64967 341611594916723379280938182270919901183 (%make-iset 8336 8584 904625697166121400702423284964750605108746128179460890055734500600385118207 (%make-iset 4349 4680 #f (%make-iset 1869 2380 13407424329480734270447878660048428920496373804417168083627602288254107168259292949124979141882146787383731347613928779568711247970208345158244457521348607 (%make-iset 880 1366 399583814438996167382020011346842847816169115710121343500162631837690410720797019959777135600271922403770006425096286507812670201087000743294040271 (%make-iset 452 1014 15095849699286165408966218323953077744206039126039399880352876178469244380253667520073008553405383346474973778635124736918461513833545106799961749425123263291782871384063 (%make-iset 33 451 1351198400207268136257714889618984005409259171978990812217822137540885437287020053544046511735433817788139780300462983613513727 #f #f) #f) (%make-iset 1377 1855 1560874275157973934343822231147075518302721156252056432767839474782185051280962423908807488297855721715644480587704321413018649007858524599877631 #f #f)) (%make-iset 3424 3911 796045881074145379721101485003658612742377112762910063541249941107066206101891013710754591976857025636790244447628442609572802972081506968078974927 (%make-iset 2908 3404 381991200485141231019756222408812876448756014237186533546277447507183436269917901262081454044646810274583365631168335787645676728618713947476107197691 (%make-iset 2382 2892 5366736463561891048904088864332422319078538891026511232750792789353571719231492410784884055633496549297705163924592108787908229198392583314950938978942851 #f #f) #f) (%make-iset 3913 4346 44362715105927999221712262984621806339048726122702370012163096018033725502663463203116646689073826286574787756247207860776650932223 #f #f))) (%make-iset 6212 6683 12194330229244424385524038642855360947889231407969113621412693927197786728086255496979946034430370000318048005765115268416095504239842568437759 (%make-iset 5121 5740 #f (%make-iset 4824 5108 62165404551223330269422779455378792455782943721961461362086716517957521327837304324095 (%make-iset 4682 4822 2787528182814337039150675927861957382578127 #f #f) #f) (%make-iset 5743 6210 762145642145155178562790324783619807494011846352632466837216562044788852063159421730556579887606746611010843054583947091606179550442951671807 #f #f)) (%make-iset 7424 7615 6277101735386680763834460195211881500229451637403754168319 (%make-iset 6912 7414 22886562555891042693710382458146756289377006471936556892838923982807328844367070294241793956553485968351753386046618718102707539530518625959993520685039 (%make-iset 6688 6809 5311800736730066244218093126239125503 #f #f) #f) (%make-iset 7680 8188 1669429210027032353070387959902572074068251569912541634239543664469254840701605815586298160569854604812755249439701457169906905863833481177213265564925951 #f #f)))) (%make-iset 43138 43638 224726016208531273348937437899872290007502680726266932355584409924411794087837267452460956059789185107995855861761463319664142696520594339463520992995707994505215 (%make-iset 19968 40908 #f (%make-iset 12321 12799 1560850458106678397246853318509506420346053090363696722427379182288726125506853871807416126725592575693831523564009034418563951096328109074350591 (%make-iset 11264 11775 1716199415031085457304815023196129625190876140284840059163076939411632061379695825768761320243048559913035261692194332965927453391792248614786550156348096511 (%make-iset 9398 9449 #f #f #f) #f) (%make-iset 13312 19893 #f #f #f)) (%make-iset 42192 42647 186070703019498633361408888448075519920530856307050957164988653405500459175263525083868751559444797946410782900983767246458201399646748671 (%make-iset 40982 42124 #f (%make-iset 40960 40980 #f #f #f) #f) (%make-iset 42656 43137 9366007796590143684266426014173832021882860391206691228341429856634888413055477646498624449482500722743196759142345085250473767233032902320062463 #f #f))) (%make-iset 63744 64109 #f (%make-iset 44032 55203 #f (%make-iset 43968 44025 287956460317442047 (%make-iset 43648 43822 47701954761756259097387504798417463778755529815359487 #f #f) #f) (%make-iset 55216 55291 75557863725914197590015 #f #f)) (%make-iset 64256 64433 383123885216472214589586756787576615644966064332734591 (%make-iset 64112 64217 #f #f #f) (%make-iset 64467 64829 #f #f #f))))) (%make-iset 120488 120654 187072206790762423064706648907459429699768891211775 (%make-iset 71296 71369 348108861360120048141903260542929609949183 (%make-iset 67584 67669 77371243358065019892792383 (%make-iset 66176 66639 878680692688788100968217104054132723536510135400456683066998889497980605885632024127229627367624962058724496859707859793938161524087860595782141042536975695871 (%make-iset 65536 65908 354901720847464262643270080013918741494457029505007323037992842993478140487429303646626346434630199938330987804055257434518162763775 (%make-iset 65008 65500 23166459242184795109519745412560813317707843523172326996035291982829335841807197632365519235915051181023523126849199870616098935821672668804369354751 #f #f) #f) (%make-iset 66640 66729 1237033344920669303018094591 #f #f)) (%make-iset 68608 68680 #f (%make-iset 68352 68466 1427247352465131255837309846865400673685471231 (%make-iset 67840 68220 4925250765375315437575115447282545225619899143486530057386523691675827454339457238250572167562730571287653355880447 #f #f) #f) (%make-iset 69635 70105 204586912993508730593563550625432944389072422914203271855910203047007904292292283148049105766861891958292943578471947333866751571791177989246645436415 #f #f))) (%make-iset 93952 94111 1461323231539455856679019361440445717580125044735 (%make-iset 77824 78894 #f (%make-iset 74752 74850 #f (%make-iset 73728 74606 #f #f #f) #f) (%make-iset 92160 92728 #f #f #f)) (%make-iset 119808 120144 1221462192088229133428742507380976417683660481320862010013722843488511299179635651402650638514783282651558855669972991 (%make-iset 110592 110593 #f #f #f) (%make-iset 120146 120485 #f #f #f)))) (%make-iset 2404 2416 4099 (%make-iset 177984 178205 #f (%make-iset 131072 173782 #f (%make-iset 126464 126651 6421867392636242726356536395708148792154285362342779204665327 (%make-iset 120656 120831 95780971304117989802914516033683783778383003373273087 #f #f) #f) (%make-iset 173824 177972 #f #f #f)) (%make-iset 2038 2038 #f (%make-iset 1370 1805 177444091211903494854164183597562195186987239759942234703242934973005962356878807556430406995673757716803475823941853280674043134015 (%make-iset 194560 195101 #f #f #f) #f) (%make-iset 2039 2142 10141204806548057579655195000839 #f #f))) (%make-iset 3449 3449 #f (%make-iset 3059 3066 #f (%make-iset 2800 2928 340282366920938463463374607431768211459 (%make-iset 2546 2555 771 #f #f) #f) (%make-iset 3199 3199 #f #f #f)) (%make-iset 3844 4175 8612299728833109452216727519275634166367255279803428156814546022481552546661143084834195942383124479 (%make-iset 3572 3675 15214283120596255441467398422529 #f #f) (%make-iset 4347 4347 #f #f #f)))))) (%make-iset 6622 6655 #f (%make-iset 44011 44011 #f (%make-iset 9001 9002 #f (%make-iset 6686 6687 #f (%make-iset 6100 6154 36011204832919671 (%make-iset 5741 5942 4820814132776970826626481771165599449877669887122490332807171 (%make-iset 5120 5120 #f #f #f) #f) (%make-iset 6468 6469 #f #f #f)) (%make-iset 7164 7379 52681756409358971006475467946070306489686807156907791211684691983 (%make-iset 7002 7008 #f (%make-iset 6816 6829 16255 #f #f) #f) (%make-iset 8208 8334 127607834706674478748244504138880122879 #f #f))) (%make-iset 12289 12539 1809251394333065553493296641491499378872794969502476229475819322195851214727 (%make-iset 11513 11632 664613997892457936451903530140172399 (%make-iset 10627 10749 7975367975289779630837864365545226239 (%make-iset 10088 10223 87027215340059722591700904977272299077631 #f #f) #f) (%make-iset 11776 11835 1152780767118491647 #f #f)) (%make-iset 43124 43615 11987514433213410168505333362405758614102799522152940711615041872404225459959956214682136066587259816913167135759024198010248565942507088814987542543 (%make-iset 42509 42743 54351252480975689826048702415431575448442147475312362296571857733681159 (%make-iset 42238 42239 #f #f #f) #f) (%make-iset 43742 43761 786435 #f #f)))) (%make-iset 69703 69955 13569385457497991651199724805705614201565294768222350139146883642703225028735 (%make-iset 66463 66512 562949953421313 (%make-iset 65281 65381 2521683860030948918624327334903 (%make-iset 65040 65131 4037812089938908849547248639 (%make-iset 64830 64831 #f #f #f) #f) (%make-iset 65792 65794 #f #f #f)) (%make-iset 68176 68223 140737488355839 (%make-iset 67871 67903 4294967297 (%make-iset 67671 67671 #f #f #f) #f) (%make-iset 68409 68415 #f #f #f))) (%make-iset 4254 4255 #f (%make-iset 3841 3896 47287798208921607 (%make-iset 74864 74867 #f (%make-iset 70085 70088 #f #f #f) #f) (%make-iset 4030 4056 126058239 #f #f)) (%make-iset 6107 6107 #f (%make-iset 5008 5017 #f #f #f) (%make-iset 6464 6464 #f #f #f))))) (%make-iset 42752 42890 522673715590561479879743397015208866086911 (%make-iset 10750 11084 #f (%make-iset 9472 9983 #f (%make-iset 8592 9000 #f (%make-iset 8125 8527 15180504508302547082559792549452134039979727921597050291198905168453617261872958515620728168035045459212134851764818477085 (%make-iset 7009 7036 267912191 #f #f) #f) (%make-iset 9003 9449 363419362147803445274660701490199886974208000930090554402992578672453439413725018135787913021374683400778402767997805117095404640403455 #f #f)) (%make-iset 10649 10711 #f (%make-iset 10224 10626 #f (%make-iset 9985 10213 862718293047519590130783627714548701007576706064464912086123449155583 #f #f) #f) (%make-iset 10716 10749 4294967295 #f #f))) (%make-iset 12688 13054 300613450595050653137261935414156179889591998741512647513967970216935158771592840931503642564904187380807827395 (%make-iset 11904 12351 547258453716185545689710299454841531346882567525409776024515836385994490529377606833512566938465691840048809561654146263061905633443839 (%make-iset 11493 11498 #f (%make-iset 11088 11097 #f #f #f) #f) (%make-iset 12443 12444 #f #f #f)) (%make-iset 19904 19967 #f (%make-iset 13056 13311 #f #f #f) (%make-iset 42128 42182 #f #f #f)))) (%make-iset 119296 119365 664082786653543858175 (%make-iset 65020 65129 796084576943328064139929612976131 (%make-iset 64297 64297 #f (%make-iset 43639 43641 #f (%make-iset 43048 43065 245775 #f #f) #f) (%make-iset 64434 64449 #f #f #f)) (%make-iset 65847 66044 401734511064736150903948875408776876244564738538201663144447 (%make-iset 65504 65533 805339007 (%make-iset 65284 65374 1547425050547877224499904641 #f #f) #f) (%make-iset 118784 119261 780437137578995458467560908739391556888996158179266522929460546508236933653296437157060350808521225678016835714111230592247297551268494937423871 #f #f))) (%make-iset 127462 127569 244021541289521102071576548868095 (%make-iset 126704 126705 #f (%make-iset 120513 120771 463168363851011130091785795673740600836767278013411671357985905734243019915265 (%make-iset 119552 119638 #f #f #f) #f) (%make-iset 126976 127386 5288447750321425141395456744287458546996189758388629186172721346534510152156602991240248150625623449590204448175840041107455 #f #f)) (%make-iset 128256 128359 5104235524096485346957782767918670413823 (%make-iset 127744 128252 1623601741516486367526542089626489179499454454837360135582644525057721907975405279813447049733043276512275822980244041212191896116171460908759068350349311 #f #f) (%make-iset 128507 128883 307828173409331868845930000782371979146838607456393061394578876014578854359990151589006733868359031372480153387007 #f #f)))))))))

;; char-set:printing
(define char-set:printing (immutable-char-set (%make-iset 4347 4347 #f (%make-iset 63744 64109 #f (%make-iset 6688 6809 5311800736730066244218093126239125503 (%make-iset 4349 4680 #f (%make-iset 1869 2380 13407424329480734270447878660048428920496373804417168083627602288254107168259292949124979141882146787383731347613928779568711247970208345158244457521348607 (%make-iset 452 1366 276978483139049986878383159513059937866295390192563056831002732490712977617729827250930061495547874753339425272845057761345036295330752004396560217460615349388256052740008771052267223259379816261947173385923045218076729795326919802994234467957919553429350144124989345512816639 (%make-iset 160 160 #f (%make-iset 9 451 22669347419131782291913114369553852359296309528272676318593841051105143812618789434640033841431908014736263332293412376088380325232671 #f #f) #f) (%make-iset 1377 1855 1560874275157973934343822231147075518302721156252056432767839474782185051280962423908807488297855721715644480587704321413018649007858524599877631 #f #f)) (%make-iset 3424 3911 796045881074145379721101485003658612742377112762910063541249941107066206101891013710754591976857025636790244447628442609572802972081506968078974927 (%make-iset 2908 3404 381991200485141231019756222408812876448756014237186533546277447507183436269917901262081454044646810274583365631168335787645676728618713947476107197691 (%make-iset 2382 2892 5366736463561891048904088864332422319078538891026511232750792789353571719231492410784884055633496549297705163924592108787908229198392583314950938978942851 #f #f) #f) (%make-iset 3913 4346 44362715105927999221712262984621806339048726122702370012163096018033725502663463203116646689073826286574787756247207860776650932223 #f #f))) (%make-iset 6158 6158 #f (%make-iset 5121 5740 #f (%make-iset 4824 5108 62165404551223330269422779455378792455782943721961461362086716517957521327837304324095 (%make-iset 4682 4822 2787528182814337039150675927861957382578127 #f #f) #f) (%make-iset 5760 5760 #f #f #f)) (%make-iset 5743 6210 762145642145155178562790324783619807494011846352632466837216562044788852063159421730556579887606746611010843054583947091606179550442951671807 (%make-iset 12288 12288 #f (%make-iset 8192 8287 39614081257132312832795215871 #f #f) #f) (%make-iset 6212 6683 12194330229244424385524038642855360947889231407969113621412693927197786728086255496979946034430370000318048005765115268416095504239842568437759 #f #f)))) (%make-iset 40960 40980 #f (%make-iset 9398 9449 #f (%make-iset 7680 8188 1669429210027032353070387959902572074068251569912541634239543664469254840701605815586298160569854604812755249439701457169906905863833481177213265564925951 (%make-iset 7424 7615 6277101735386680763834460195211881500229451637403754168319 (%make-iset 6912 7414 22886562555891042693710382458146756289377006471936556892838923982807328844367070294241793956553485968351753386046618718102707539530518625959993520685039 #f #f) #f) (%make-iset 8336 8584 904625697166121400702423284964750605108746128179460890055734500600385118207 #f #f)) (%make-iset 13312 19893 #f (%make-iset 12321 12799 1560850458106678397246853318509506420346053090363696722427379182288726125506853871807416126725592575693831523564009034418563951096328109074350591 (%make-iset 11264 11775 1716199415031085457304815023196129625190876140284840059163076939411632061379695825768761320243048559913035261692194332965927453391792248614786550156348096511 #f #f) #f) (%make-iset 19968 40908 #f #f #f))) (%make-iset 43648 43822 47701954761756259097387504798417463778755529815359487 (%make-iset 42656 43137 9366007796590143684266426014173832021882860391206691228341429856634888413055477646498624449482500722743196759142345085250473767233032902320062463 (%make-iset 42192 42647 186070703019498633361408888448075519920530856307050957164988653405500459175263525083868751559444797946410782900983767246458201399646748671 (%make-iset 40982 42124 #f #f #f) #f) (%make-iset 43138 43638 224726016208531273348937437899872290007502680726266932355584409924411794087837267452460956059789185107995855861761463319664142696520594339463520992995707994505215 #f #f)) (%make-iset 44032 55203 #f (%make-iset 43968 44025 287956460317442047 #f #f) (%make-iset 55216 55291 75557863725914197590015 #f #f))))) (%make-iset 110592 110593 #f (%make-iset 67840 68220 4925250765375315437575115447282545225619899143486530057386523691675827454339457238250572167562730571287653355880447 (%make-iset 65008 65500 23166459242184795109519745412560813317707843523172326996035291982829335841807197632365519235915051181023523126849199870616098935821672668804369354751 (%make-iset 64467 64829 #f (%make-iset 64256 64433 383123885216472214589586756787576615644966064332734591 (%make-iset 64112 64217 #f #f #f) #f) (%make-iset 64848 64967 341611594916723379280938182270919901183 #f #f)) (%make-iset 66640 66729 1237033344920669303018094591 (%make-iset 66176 66639 878680692688788100968217104054132723536510135400456683066998889497980605885632024127229627367624962058724496859707859793938161524087860595782141042536975695871 (%make-iset 65536 65908 354901720847464262643270080013918741494457029505007323037992842993478140487429303646626346434630199938330987804055257434518162763775 #f #f) #f) (%make-iset 67584 67669 77371243358065019892792383 #f #f))) (%make-iset 73728 74606 #f (%make-iset 69635 70105 204586912993508730593563550625432944389072422914203271855910203047007904292292283148049105766861891958292943578471947333866751571791177989246645436415 (%make-iset 68608 68680 #f (%make-iset 68352 68466 1427247352465131255837309846865400673685471231 #f #f) #f) (%make-iset 71296 71369 348108861360120048141903260542929609949183 #f #f)) (%make-iset 92160 92728 #f (%make-iset 77824 78894 #f (%make-iset 74752 74850 #f #f #f) #f) (%make-iset 93952 94111 1461323231539455856679019361440445717580125044735 #f #f)))) (%make-iset 1370 1805 177444091211903494854164183597562195186987239759942234703242934973005962356878807556430406995673757716803475823941853280674043134015 (%make-iset 126464 126651 6421867392636242726356536395708148792154285362342779204665327 (%make-iset 120488 120654 187072206790762423064706648907459429699768891211775 (%make-iset 120146 120485 #f (%make-iset 119808 120144 1221462192088229133428742507380976417683660481320862010013722843488511299179635651402650638514783282651558855669972991 #f #f) #f) (%make-iset 120656 120831 95780971304117989802914516033683783778383003373273087 #f #f)) (%make-iset 177984 178205 #f (%make-iset 173824 177972 #f (%make-iset 131072 173782 #f #f #f) #f) (%make-iset 194560 195101 #f #f #f))) (%make-iset 3059 3066 #f (%make-iset 2546 2555 771 (%make-iset 2404 2416 4099 (%make-iset 2038 2142 20282409613096115159310390001679 #f #f) #f) (%make-iset 2800 2928 340282366920938463463374607431768211459 #f #f)) (%make-iset 3449 3675 161786008477555489129424138914539858559159520266627551066615690821633 (%make-iset 3199 3199 #f #f #f) (%make-iset 3844 4175 8612299728833109452216727519275634166367255279803428156814546022481552546661143084834195942383124479 #f #f)))))) (%make-iset 6464 6464 #f (%make-iset 43742 43761 786435 (%make-iset 8208 8334 127607834706674478748244504138880122879 (%make-iset 6468 6469 #f (%make-iset 5741 5942 4820814132776970826626481771165599449877669887122490332807171 (%make-iset 5120 5120 #f (%make-iset 4960 4968 #f #f #f) #f) (%make-iset 6100 6154 36011204832919671 #f #f)) (%make-iset 7002 7008 #f (%make-iset 6816 6829 16255 (%make-iset 6686 6687 #f #f #f) #f) (%make-iset 7164 7379 52681756409358971006475467946070306489686807156907791211684691983 #f #f))) (%make-iset 11776 11835 1152780767118491647 (%make-iset 10627 10749 7975367975289779630837864365545226239 (%make-iset 10088 10223 87027215340059722591700904977272299077631 (%make-iset 9001 9002 #f #f #f) #f) (%make-iset 11513 11632 664613997892457936451903530140172399 #f #f)) (%make-iset 42509 42743 54351252480975689826048702415431575448442147475312362296571857733681159 (%make-iset 42238 42239 #f (%make-iset 12289 12539 1809251394333065553493296641491499378872794969502476229475819322195851214727 #f #f) #f) (%make-iset 43124 43615 11987514433213410168505333362405758614102799522152940711615041872404225459959956214682136066587259816913167135759024198010248565942507088814987542543 #f #f)))) (%make-iset 68409 68415 #f (%make-iset 65792 65794 #f (%make-iset 65040 65131 4037812089938908849547248639 (%make-iset 64830 64831 #f (%make-iset 44011 44011 #f #f #f) #f) (%make-iset 65281 65381 2521683860030948918624327334903 #f #f)) (%make-iset 67871 67903 4294967297 (%make-iset 67671 67671 #f (%make-iset 66463 66512 562949953421313 #f #f) #f) (%make-iset 68176 68223 140737488355839 #f #f))) (%make-iset 4030 4056 126058239 (%make-iset 74864 74867 #f (%make-iset 70085 70088 #f (%make-iset 69703 69955 13569385457497991651199724805705614201565294768222350139146883642703225028735 #f #f) #f) (%make-iset 3841 3896 47287798208921607 #f #f)) (%make-iset 5008 5017 #f (%make-iset 4254 4255 #f #f #f) (%make-iset 6107 6107 #f #f #f))))) (%make-iset 42752 42890 522673715590561479879743397015208866086911 (%make-iset 10716 10749 4294967295 (%make-iset 9003 9449 363419362147803445274660701490199886974208000930090554402992578672453439413725018135787913021374683400778402767997805117095404640403455 (%make-iset 8125 8527 15180504508302547082559792549452134039979727921597050291198905168453617261872958515620728168035045459212134851764818477085 (%make-iset 7009 7036 267912191 (%make-iset 6622 6655 #f #f #f) #f) (%make-iset 8592 9000 #f #f #f)) (%make-iset 10224 10626 #f (%make-iset 9985 10213 862718293047519590130783627714548701007576706064464912086123449155583 (%make-iset 9472 9983 #f #f #f) #f) (%make-iset 10649 10711 #f #f #f))) (%make-iset 12443 12444 #f (%make-iset 11493 11498 #f (%make-iset 11088 11097 #f (%make-iset 10750 11084 #f #f #f) #f) (%make-iset 11904 12351 547258453716185545689710299454841531346882567525409776024515836385994490529377606833512566938465691840048809561654146263061905633443839 #f #f)) (%make-iset 19904 19967 #f (%make-iset 13056 13311 #f (%make-iset 12688 13054 300613450595050653137261935414156179889591998741512647513967970216935158771592840931503642564904187380807827395 #f #f) #f) (%make-iset 42128 42182 #f #f #f)))) (%make-iset 119296 119365 664082786653543858175 (%make-iset 65020 65129 796084576943328064139929612976131 (%make-iset 64297 64297 #f (%make-iset 43639 43641 #f (%make-iset 43048 43065 245775 #f #f) #f) (%make-iset 64434 64449 #f #f #f)) (%make-iset 65847 66044 401734511064736150903948875408776876244564738538201663144447 (%make-iset 65504 65533 805339007 (%make-iset 65284 65374 1547425050547877224499904641 #f #f) #f) (%make-iset 118784 119261 780437137578995458467560908739391556888996158179266522929460546508236933653296437157060350808521225678016835714111230592247297551268494937423871 #f #f))) (%make-iset 127462 127569 244021541289521102071576548868095 (%make-iset 126704 126705 #f (%make-iset 120513 120771 463168363851011130091785795673740600836767278013411671357985905734243019915265 (%make-iset 119552 119638 #f #f #f) #f) (%make-iset 126976 127386 5288447750321425141395456744287458546996189758388629186172721346534510152156602991240248150625623449590204448175840041107455 #f #f)) (%make-iset 128256 128359 5104235524096485346957782767918670413823 (%make-iset 127744 128252 1623601741516486367526542089626489179499454454837360135582644525057721907975405279813447049733043276512275822980244041212191896116171460908759068350349311 #f #f) (%make-iset 128507 128883 307828173409331868845930000782371979146838607456393061394578876014578854359990151589006733868359031372480153387007 #f #f)))))))))

;; char-set:lower-case
(define char-set:lower-case (immutable-char-set (%make-iset 97 122 #f #f #f)))

;; char-set:upper-case
(define char-set:upper-case (immutable-char-set (%make-iset 65 90 #f #f #f)))

;; char-set:title-case
(define char-set:title-case (immutable-char-set (%make-iset 0 0 0 #f #f)))

;; char-set:letter
(define char-set:letter (immutable-char-set (%make-iset 97 122 #f (%make-iset 65 90 #f #f #f) #f)))

;; char-set:punctuation
(define char-set:punctuation (immutable-char-set (%make-iset 63 64 #f (%make-iset 44 47 #f (%make-iset 37 42 #f (%make-iset 33 35 #f #f #f) #f) (%make-iset 58 59 #f #f #f)) (%make-iset 123 123 #f (%make-iset 95 95 #f (%make-iset 91 93 #f #f #f) #f) (%make-iset 125 125 #f #f #f)))))

;; char-set:symbol
(define char-set:symbol (immutable-char-set (%make-iset 94 94 #f (%make-iset 43 43 #f (%make-iset 36 36 #f #f #f) (%make-iset 60 62 #f #f #f)) (%make-iset 124 124 #f (%make-iset 96 96 #f #f #f) (%make-iset 126 126 #f #f #f)))))

;; char-set:blank
(define char-set:blank (immutable-char-set (%make-iset 32 32 #f (%make-iset 9 9 #f #f #f) #f)))

;; char-set:whitespace
(define char-set:whitespace (immutable-char-set (%make-iset 32 32 #f (%make-iset 9 13 #f #f #f) #f)))

;; char-set:digit
(define char-set:digit (immutable-char-set (%make-iset 48 57 #f #f #f)))

;; char-set:letter+digit
(define char-set:letter+digit (immutable-char-set (%make-iset 65 90 #f (%make-iset 48 57 #f #f #f) (%make-iset 97 122 #f #f #f))))

;; char-set:hex-digit
(define char-set:hex-digit (immutable-char-set (%make-iset 65 70 #f (%make-iset 48 57 #f #f #f) (%make-iset 97 102 #f #f #f))))

;; char-set:iso-control
(define char-set:iso-control (immutable-char-set (%make-iset 127 127 #f (%make-iset 0 31 #f #f #f) #f)))

;; char-set:graphic
(define char-set:graphic (immutable-char-set (%make-iset 33 126 #f #f #f)))

;; char-set:printing
(define char-set:printing (immutable-char-set (%make-iset 32 126 #f (%make-iset 9 13 #f #f #f) #f)))


(define-library (chibi char-set full)
  (import (chibi) (chibi iset base) (chibi char-set base))
  (export char-set:lower-case  char-set:upper-case  char-set:title-case
          char-set:letter      char-set:digit       char-set:letter+digit
          char-set:graphic     char-set:printing    char-set:whitespace
          char-set:iso-control char-set:punctuation char-set:symbol
          char-set:hex-digit   char-set:blank)
  (include "full.scm"))

(define-library (chibi char-set extras)
  (import (chibi) (chibi iset) (chibi char-set base))
  (include "extras.scm")
  (export
   char-set ucs-range->char-set char-set-copy char-set-size
   char-set-fold char-set-for-each
   list->char-set char-set->list string->char-set char-set->string
   char-set-adjoin! char-set-adjoin char-set-union char-set-union!
   char-set-intersection char-set-intersection!
   char-set-difference char-set-difference!
   char-set-complement char-set:empty char-set:ascii char-set:full))
;; Control
(define char-set:control (immutable-char-set (char-set-union (ucs-range->char-set 0 10) (ucs-range->char-set 11 13) (ucs-range->char-set 14 32) (ucs-range->char-set 127 160) (ucs-range->char-set 1536 1541) (ucs-range->char-set 8206 8208) (ucs-range->char-set 8234 8239) (ucs-range->char-set 8288 8293) (ucs-range->char-set 8294 8304) (ucs-range->char-set 55296 57344) (ucs-range->char-set 65520 65529) (ucs-range->char-set 65529 65532) (ucs-range->char-set 119155 119163) (ucs-range->char-set 917506 917536) (ucs-range->char-set 917536 917632) (ucs-range->char-set 917632 917760) (ucs-range->char-set 918000 921600))))

;; Extend,SpacingMark
(define char-set:extend-or-spacing-mark (immutable-char-set (char-set-union (char-set-union (ucs-range->char-set 768 880) (ucs-range->char-set 1155 1160) (ucs-range->char-set 1160 1162) (ucs-range->char-set 1425 1470) (ucs-range->char-set 1473 1475) (ucs-range->char-set 1476 1478) (ucs-range->char-set 1552 1563) (ucs-range->char-set 1611 1632) (ucs-range->char-set 1750 1757) (ucs-range->char-set 1759 1765) (ucs-range->char-set 1767 1769) (ucs-range->char-set 1770 1774) (ucs-range->char-set 1840 1867) (ucs-range->char-set 1958 1969) (ucs-range->char-set 2027 2036) (ucs-range->char-set 2070 2074) (ucs-range->char-set 2075 2084) (ucs-range->char-set 2085 2088) (ucs-range->char-set 2089 2094) (ucs-range->char-set 2137 2140) (ucs-range->char-set 2276 2303) (ucs-range->char-set 2304 2307) (ucs-range->char-set 2369 2377) (ucs-range->char-set 2385 2392) (ucs-range->char-set 2402 2404) (ucs-range->char-set 2497 2501) (ucs-range->char-set 2530 2532) (ucs-range->char-set 2561 2563) (ucs-range->char-set 2625 2627) (ucs-range->char-set 2631 2633) (ucs-range->char-set 2635 2638) (ucs-range->char-set 2672 2674) (ucs-range->char-set 2689 2691) (ucs-range->char-set 2753 2758) (ucs-range->char-set 2759 2761) (ucs-range->char-set 2786 2788) (ucs-range->char-set 2881 2885) (ucs-range->char-set 2914 2916) (ucs-range->char-set 3134 3137) (ucs-range->char-set 3142 3145) (ucs-range->char-set 3146 3150) (ucs-range->char-set 3157 3159) (ucs-range->char-set 3170 3172) (ucs-range->char-set 3276 3278) (ucs-range->char-set 3285 3287) (ucs-range->char-set 3298 3300) (ucs-range->char-set 3393 3397) (ucs-range->char-set 3426 3428) (ucs-range->char-set 3538 3541) (ucs-range->char-set 3636 3643) (ucs-range->char-set 3655 3663) (ucs-range->char-set 3764 3770) (ucs-range->char-set 3771 3773) (ucs-range->char-set 3784 3790) (ucs-range->char-set 3864 3866) (ucs-range->char-set 3953 3967) (ucs-range->char-set 3968 3973) (ucs-range->char-set 3974 3976) (ucs-range->char-set 3981 3992) (ucs-range->char-set 3993 4029) (ucs-range->char-set 4141 4145) (ucs-range->char-set 4146 4152) (ucs-range->char-set 4153 4155) (ucs-range->char-set 4157 4159) (ucs-range->char-set 4184 4186) (ucs-range->char-set 4190 4193) (ucs-range->char-set 4209 4213) (ucs-range->char-set 4229 4231) (ucs-range->char-set 4957 4960) (ucs-range->char-set 5906 5909) (ucs-range->char-set 5938 5941) (ucs-range->char-set 5970 5972) (ucs-range->char-set 6002 6004) (ucs-range->char-set 6068 6070) (ucs-range->char-set 6071 6078) (ucs-range->char-set 6089 6100) (ucs-range->char-set 6155 6158) (ucs-range->char-set 6432 6435) (ucs-range->char-set 6439 6441) (ucs-range->char-set 6457 6460) (ucs-range->char-set 6679 6681) (ucs-range->char-set 6744 6751) (ucs-range->char-set 6757 6765) (ucs-range->char-set 6771 6781) (ucs-range->char-set 6912 6916) (ucs-range->char-set 6966 6971) (ucs-range->char-set 7019 7028) (ucs-range->char-set 7040 7042) (ucs-range->char-set 7074 7078) (ucs-range->char-set 7080 7082) (ucs-range->char-set 7144 7146) (ucs-range->char-set 7151 7154) (ucs-range->char-set 7212 7220) (ucs-range->char-set 7222 7224) (ucs-range->char-set 7376 7379) (ucs-range->char-set 7380 7393) (ucs-range->char-set 7394 7401) (ucs-range->char-set 7616 7655) (ucs-range->char-set 7676 7680) (ucs-range->char-set 8204 8206) (ucs-range->char-set 8400 8413) (ucs-range->char-set 8413 8417) (ucs-range->char-set 8418 8421) (ucs-range->char-set 8421 8433) (ucs-range->char-set 11503 11506) (ucs-range->char-set 11744 11776) (ucs-range->char-set 12330 12334) (ucs-range->char-set 12334 12336) (ucs-range->char-set 12441 12443) (ucs-range->char-set 42608 42611) (ucs-range->char-set 42612 42622) (ucs-range->char-set 42736 42738) (ucs-range->char-set 43045 43047) (ucs-range->char-set 43232 43250) (ucs-range->char-set 43302 43310) (ucs-range->char-set 43335 43346) (ucs-range->char-set 43392 43395) (ucs-range->char-set 43446 43450) (ucs-range->char-set 43561 43567) (ucs-range->char-set 43569 43571) (ucs-range->char-set 43573 43575) (ucs-range->char-set 43698 43701) (ucs-range->char-set 43703 43705) (ucs-range->char-set 43710 43712) (ucs-range->char-set 43756 43758) (ucs-range->char-set 65024 65040) (ucs-range->char-set 65056 65063) (ucs-range->char-set 65438 65440) (ucs-range->char-set 68097 68100) (ucs-range->char-set 68101 68103) (ucs-range->char-set 68108 68112) (ucs-range->char-set 68152 68155) (ucs-range->char-set 69688 69703) (ucs-range->char-set 69760 69762) (ucs-range->char-set 69811 69815) (ucs-range->char-set 69817 69819) (ucs-range->char-set 69888 69891) (ucs-range->char-set 69927 69932) (ucs-range->char-set 69933 69941) (ucs-range->char-set 70016 70018) (ucs-range->char-set 70070 70079) (ucs-range->char-set 71344 71350) (ucs-range->char-set 94095 94099) (ucs-range->char-set 119143 119146) (ucs-range->char-set 119150 119155) (ucs-range->char-set 119163 119171) (ucs-range->char-set 119173 119180) (ucs-range->char-set 119210 119214) (ucs-range->char-set 119362 119365) (ucs-range->char-set 917760 918000)) (char-set-union (ucs-range->char-set 2366 2369) (ucs-range->char-set 2377 2381) (ucs-range->char-set 2382 2384) (ucs-range->char-set 2434 2436) (ucs-range->char-set 2495 2497) (ucs-range->char-set 2503 2505) (ucs-range->char-set 2507 2509) (ucs-range->char-set 2622 2625) (ucs-range->char-set 2750 2753) (ucs-range->char-set 2763 2765) (ucs-range->char-set 2818 2820) (ucs-range->char-set 2887 2889) (ucs-range->char-set 2891 2893) (ucs-range->char-set 3009 3011) (ucs-range->char-set 3014 3017) (ucs-range->char-set 3018 3021) (ucs-range->char-set 3073 3076) (ucs-range->char-set 3137 3141) (ucs-range->char-set 3202 3204) (ucs-range->char-set 3264 3266) (ucs-range->char-set 3267 3269) (ucs-range->char-set 3271 3273) (ucs-range->char-set 3274 3276) (ucs-range->char-set 3330 3332) (ucs-range->char-set 3391 3393) (ucs-range->char-set 3398 3401) (ucs-range->char-set 3402 3405) (ucs-range->char-set 3458 3460) (ucs-range->char-set 3536 3538) (ucs-range->char-set 3544 3551) (ucs-range->char-set 3570 3572) (ucs-range->char-set 3902 3904) (ucs-range->char-set 4155 4157) (ucs-range->char-set 4182 4184) (ucs-range->char-set 6078 6086) (ucs-range->char-set 6087 6089) (ucs-range->char-set 6435 6439) (ucs-range->char-set 6441 6444) (ucs-range->char-set 6448 6450) (ucs-range->char-set 6451 6457) (ucs-range->char-set 6581 6584) (ucs-range->char-set 6681 6683) (ucs-range->char-set 6765 6771) (ucs-range->char-set 6973 6978) (ucs-range->char-set 6979 6981) (ucs-range->char-set 7078 7080) (ucs-range->char-set 7084 7086) (ucs-range->char-set 7146 7149) (ucs-range->char-set 7154 7156) (ucs-range->char-set 7204 7212) (ucs-range->char-set 7220 7222) (ucs-range->char-set 7410 7412) (ucs-range->char-set 43043 43045) (ucs-range->char-set 43136 43138) (ucs-range->char-set 43188 43204) (ucs-range->char-set 43346 43348) (ucs-range->char-set 43444 43446) (ucs-range->char-set 43450 43452) (ucs-range->char-set 43453 43457) (ucs-range->char-set 43567 43569) (ucs-range->char-set 43571 43573) (ucs-range->char-set 43758 43760) (ucs-range->char-set 44003 44005) (ucs-range->char-set 44006 44008) (ucs-range->char-set 44009 44011) (ucs-range->char-set 69808 69811) (ucs-range->char-set 69815 69817) (ucs-range->char-set 70067 70070) (ucs-range->char-set 70079 70081) (ucs-range->char-set 71342 71344) (ucs-range->char-set 94033 94079)))))

;; Regional_Indicator
(define char-set:regional-indicator (immutable-char-set (char-set-union (ucs-range->char-set 127462 127488))))

;; :L
(define char-set:hangul-l (immutable-char-set (char-set-union (ucs-range->char-set 4352 4448) (ucs-range->char-set 43360 43389))))

;; :V
(define char-set:hangul-v (immutable-char-set (char-set-union (ucs-range->char-set 4448 4520) (ucs-range->char-set 55216 55239))))

;; :T
(define char-set:hangul-t (immutable-char-set (char-set-union (ucs-range->char-set 4520 4608) (ucs-range->char-set 55243 55292))))

;; :LV
(define char-set:hangul-lv (immutable-char-set (char-set-union)))

;; :LVT
(define char-set:hangul-lvt (immutable-char-set (char-set-union (ucs-range->char-set 44033 44060) (ucs-range->char-set 44061 44088) (ucs-range->char-set 44089 44116) (ucs-range->char-set 44117 44144) (ucs-range->char-set 44145 44172) (ucs-range->char-set 44173 44200) (ucs-range->char-set 44201 44228) (ucs-range->char-set 44229 44256) (ucs-range->char-set 44257 44284) (ucs-range->char-set 44285 44312) (ucs-range->char-set 44313 44340) (ucs-range->char-set 44341 44368) (ucs-range->char-set 44369 44396) (ucs-range->char-set 44397 44424) (ucs-range->char-set 44425 44452) (ucs-range->char-set 44453 44480) (ucs-range->char-set 44481 44508) (ucs-range->char-set 44509 44536) (ucs-range->char-set 44537 44564) (ucs-range->char-set 44565 44592) (ucs-range->char-set 44593 44620) (ucs-range->char-set 44621 44648) (ucs-range->char-set 44649 44676) (ucs-range->char-set 44677 44704) (ucs-range->char-set 44705 44732) (ucs-range->char-set 44733 44760) (ucs-range->char-set 44761 44788) (ucs-range->char-set 44789 44816) (ucs-range->char-set 44817 44844) (ucs-range->char-set 44845 44872) (ucs-range->char-set 44873 44900) (ucs-range->char-set 44901 44928) (ucs-range->char-set 44929 44956) (ucs-range->char-set 44957 44984) (ucs-range->char-set 44985 45012) (ucs-range->char-set 45013 45040) (ucs-range->char-set 45041 45068) (ucs-range->char-set 45069 45096) (ucs-range->char-set 45097 45124) (ucs-range->char-set 45125 45152) (ucs-range->char-set 45153 45180) (ucs-range->char-set 45181 45208) (ucs-range->char-set 45209 45236) (ucs-range->char-set 45237 45264) (ucs-range->char-set 45265 45292) (ucs-range->char-set 45293 45320) (ucs-range->char-set 45321 45348) (ucs-range->char-set 45349 45376) (ucs-range->char-set 45377 45404) (ucs-range->char-set 45405 45432) (ucs-range->char-set 45433 45460) (ucs-range->char-set 45461 45488) (ucs-range->char-set 45489 45516) (ucs-range->char-set 45517 45544) (ucs-range->char-set 45545 45572) (ucs-range->char-set 45573 45600) (ucs-range->char-set 45601 45628) (ucs-range->char-set 45629 45656) (ucs-range->char-set 45657 45684) (ucs-range->char-set 45685 45712) (ucs-range->char-set 45713 45740) (ucs-range->char-set 45741 45768) (ucs-range->char-set 45769 45796) (ucs-range->char-set 45797 45824) (ucs-range->char-set 45825 45852) (ucs-range->char-set 45853 45880) (ucs-range->char-set 45881 45908) (ucs-range->char-set 45909 45936) (ucs-range->char-set 45937 45964) (ucs-range->char-set 45965 45992) (ucs-range->char-set 45993 46020) (ucs-range->char-set 46021 46048) (ucs-range->char-set 46049 46076) (ucs-range->char-set 46077 46104) (ucs-range->char-set 46105 46132) (ucs-range->char-set 46133 46160) (ucs-range->char-set 46161 46188) (ucs-range->char-set 46189 46216) (ucs-range->char-set 46217 46244) (ucs-range->char-set 46245 46272) (ucs-range->char-set 46273 46300) (ucs-range->char-set 46301 46328) (ucs-range->char-set 46329 46356) (ucs-range->char-set 46357 46384) (ucs-range->char-set 46385 46412) (ucs-range->char-set 46413 46440) (ucs-range->char-set 46441 46468) (ucs-range->char-set 46469 46496) (ucs-range->char-set 46497 46524) (ucs-range->char-set 46525 46552) (ucs-range->char-set 46553 46580) (ucs-range->char-set 46581 46608) (ucs-range->char-set 46609 46636) (ucs-range->char-set 46637 46664) (ucs-range->char-set 46665 46692) (ucs-range->char-set 46693 46720) (ucs-range->char-set 46721 46748) (ucs-range->char-set 46749 46776) (ucs-range->char-set 46777 46804) (ucs-range->char-set 46805 46832) (ucs-range->char-set 46833 46860) (ucs-range->char-set 46861 46888) (ucs-range->char-set 46889 46916) (ucs-range->char-set 46917 46944) (ucs-range->char-set 46945 46972) (ucs-range->char-set 46973 47000) (ucs-range->char-set 47001 47028) (ucs-range->char-set 47029 47056) (ucs-range->char-set 47057 47084) (ucs-range->char-set 47085 47112) (ucs-range->char-set 47113 47140) (ucs-range->char-set 47141 47168) (ucs-range->char-set 47169 47196) (ucs-range->char-set 47197 47224) (ucs-range->char-set 47225 47252) (ucs-range->char-set 47253 47280) (ucs-range->char-set 47281 47308) (ucs-range->char-set 47309 47336) (ucs-range->char-set 47337 47364) (ucs-range->char-set 47365 47392) (ucs-range->char-set 47393 47420) (ucs-range->char-set 47421 47448) (ucs-range->char-set 47449 47476) (ucs-range->char-set 47477 47504) (ucs-range->char-set 47505 47532) (ucs-range->char-set 47533 47560) (ucs-range->char-set 47561 47588) (ucs-range->char-set 47589 47616) (ucs-range->char-set 47617 47644) (ucs-range->char-set 47645 47672) (ucs-range->char-set 47673 47700) (ucs-range->char-set 47701 47728) (ucs-range->char-set 47729 47756) (ucs-range->char-set 47757 47784) (ucs-range->char-set 47785 47812) (ucs-range->char-set 47813 47840) (ucs-range->char-set 47841 47868) (ucs-range->char-set 47869 47896) (ucs-range->char-set 47897 47924) (ucs-range->char-set 47925 47952) (ucs-range->char-set 47953 47980) (ucs-range->char-set 47981 48008) (ucs-range->char-set 48009 48036) (ucs-range->char-set 48037 48064) (ucs-range->char-set 48065 48092) (ucs-range->char-set 48093 48120) (ucs-range->char-set 48121 48148) (ucs-range->char-set 48149 48176) (ucs-range->char-set 48177 48204) (ucs-range->char-set 48205 48232) (ucs-range->char-set 48233 48260) (ucs-range->char-set 48261 48288) (ucs-range->char-set 48289 48316) (ucs-range->char-set 48317 48344) (ucs-range->char-set 48345 48372) (ucs-range->char-set 48373 48400) (ucs-range->char-set 48401 48428) (ucs-range->char-set 48429 48456) (ucs-range->char-set 48457 48484) (ucs-range->char-set 48485 48512) (ucs-range->char-set 48513 48540) (ucs-range->char-set 48541 48568) (ucs-range->char-set 48569 48596) (ucs-range->char-set 48597 48624) (ucs-range->char-set 48625 48652) (ucs-range->char-set 48653 48680) (ucs-range->char-set 48681 48708) (ucs-range->char-set 48709 48736) (ucs-range->char-set 48737 48764) (ucs-range->char-set 48765 48792) (ucs-range->char-set 48793 48820) (ucs-range->char-set 48821 48848) (ucs-range->char-set 48849 48876) (ucs-range->char-set 48877 48904) (ucs-range->char-set 48905 48932) (ucs-range->char-set 48933 48960) (ucs-range->char-set 48961 48988) (ucs-range->char-set 48989 49016) (ucs-range->char-set 49017 49044) (ucs-range->char-set 49045 49072) (ucs-range->char-set 49073 49100) (ucs-range->char-set 49101 49128) (ucs-range->char-set 49129 49156) (ucs-range->char-set 49157 49184) (ucs-range->char-set 49185 49212) (ucs-range->char-set 49213 49240) (ucs-range->char-set 49241 49268) (ucs-range->char-set 49269 49296) (ucs-range->char-set 49297 49324) (ucs-range->char-set 49325 49352) (ucs-range->char-set 49353 49380) (ucs-range->char-set 49381 49408) (ucs-range->char-set 49409 49436) (ucs-range->char-set 49437 49464) (ucs-range->char-set 49465 49492) (ucs-range->char-set 49493 49520) (ucs-range->char-set 49521 49548) (ucs-range->char-set 49549 49576) (ucs-range->char-set 49577 49604) (ucs-range->char-set 49605 49632) (ucs-range->char-set 49633 49660) (ucs-range->char-set 49661 49688) (ucs-range->char-set 49689 49716) (ucs-range->char-set 49717 49744) (ucs-range->char-set 49745 49772) (ucs-range->char-set 49773 49800) (ucs-range->char-set 49801 49828) (ucs-range->char-set 49829 49856) (ucs-range->char-set 49857 49884) (ucs-range->char-set 49885 49912) (ucs-range->char-set 49913 49940) (ucs-range->char-set 49941 49968) (ucs-range->char-set 49969 49996) (ucs-range->char-set 49997 50024) (ucs-range->char-set 50025 50052) (ucs-range->char-set 50053 50080) (ucs-range->char-set 50081 50108) (ucs-range->char-set 50109 50136) (ucs-range->char-set 50137 50164) (ucs-range->char-set 50165 50192) (ucs-range->char-set 50193 50220) (ucs-range->char-set 50221 50248) (ucs-range->char-set 50249 50276) (ucs-range->char-set 50277 50304) (ucs-range->char-set 50305 50332) (ucs-range->char-set 50333 50360) (ucs-range->char-set 50361 50388) (ucs-range->char-set 50389 50416) (ucs-range->char-set 50417 50444) (ucs-range->char-set 50445 50472) (ucs-range->char-set 50473 50500) (ucs-range->char-set 50501 50528) (ucs-range->char-set 50529 50556) (ucs-range->char-set 50557 50584) (ucs-range->char-set 50585 50612) (ucs-range->char-set 50613 50640) (ucs-range->char-set 50641 50668) (ucs-range->char-set 50669 50696) (ucs-range->char-set 50697 50724) (ucs-range->char-set 50725 50752) (ucs-range->char-set 50753 50780) (ucs-range->char-set 50781 50808) (ucs-range->char-set 50809 50836) (ucs-range->char-set 50837 50864) (ucs-range->char-set 50865 50892) (ucs-range->char-set 50893 50920) (ucs-range->char-set 50921 50948) (ucs-range->char-set 50949 50976) (ucs-range->char-set 50977 51004) (ucs-range->char-set 51005 51032) (ucs-range->char-set 51033 51060) (ucs-range->char-set 51061 51088) (ucs-range->char-set 51089 51116) (ucs-range->char-set 51117 51144) (ucs-range->char-set 51145 51172) (ucs-range->char-set 51173 51200) (ucs-range->char-set 51201 51228) (ucs-range->char-set 51229 51256) (ucs-range->char-set 51257 51284) (ucs-range->char-set 51285 51312) (ucs-range->char-set 51313 51340) (ucs-range->char-set 51341 51368) (ucs-range->char-set 51369 51396) (ucs-range->char-set 51397 51424) (ucs-range->char-set 51425 51452) (ucs-range->char-set 51453 51480) (ucs-range->char-set 51481 51508) (ucs-range->char-set 51509 51536) (ucs-range->char-set 51537 51564) (ucs-range->char-set 51565 51592) (ucs-range->char-set 51593 51620) (ucs-range->char-set 51621 51648) (ucs-range->char-set 51649 51676) (ucs-range->char-set 51677 51704) (ucs-range->char-set 51705 51732) (ucs-range->char-set 51733 51760) (ucs-range->char-set 51761 51788) (ucs-range->char-set 51789 51816) (ucs-range->char-set 51817 51844) (ucs-range->char-set 51845 51872) (ucs-range->char-set 51873 51900) (ucs-range->char-set 51901 51928) (ucs-range->char-set 51929 51956) (ucs-range->char-set 51957 51984) (ucs-range->char-set 51985 52012) (ucs-range->char-set 52013 52040) (ucs-range->char-set 52041 52068) (ucs-range->char-set 52069 52096) (ucs-range->char-set 52097 52124) (ucs-range->char-set 52125 52152) (ucs-range->char-set 52153 52180) (ucs-range->char-set 52181 52208) (ucs-range->char-set 52209 52236) (ucs-range->char-set 52237 52264) (ucs-range->char-set 52265 52292) (ucs-range->char-set 52293 52320) (ucs-range->char-set 52321 52348) (ucs-range->char-set 52349 52376) (ucs-range->char-set 52377 52404) (ucs-range->char-set 52405 52432) (ucs-range->char-set 52433 52460) (ucs-range->char-set 52461 52488) (ucs-range->char-set 52489 52516) (ucs-range->char-set 52517 52544) (ucs-range->char-set 52545 52572) (ucs-range->char-set 52573 52600) (ucs-range->char-set 52601 52628) (ucs-range->char-set 52629 52656) (ucs-range->char-set 52657 52684) (ucs-range->char-set 52685 52712) (ucs-range->char-set 52713 52740) (ucs-range->char-set 52741 52768) (ucs-range->char-set 52769 52796) (ucs-range->char-set 52797 52824) (ucs-range->char-set 52825 52852) (ucs-range->char-set 52853 52880) (ucs-range->char-set 52881 52908) (ucs-range->char-set 52909 52936) (ucs-range->char-set 52937 52964) (ucs-range->char-set 52965 52992) (ucs-range->char-set 52993 53020) (ucs-range->char-set 53021 53048) (ucs-range->char-set 53049 53076) (ucs-range->char-set 53077 53104) (ucs-range->char-set 53105 53132) (ucs-range->char-set 53133 53160) (ucs-range->char-set 53161 53188) (ucs-range->char-set 53189 53216) (ucs-range->char-set 53217 53244) (ucs-range->char-set 53245 53272) (ucs-range->char-set 53273 53300) (ucs-range->char-set 53301 53328) (ucs-range->char-set 53329 53356) (ucs-range->char-set 53357 53384) (ucs-range->char-set 53385 53412) (ucs-range->char-set 53413 53440) (ucs-range->char-set 53441 53468) (ucs-range->char-set 53469 53496) (ucs-range->char-set 53497 53524) (ucs-range->char-set 53525 53552) (ucs-range->char-set 53553 53580) (ucs-range->char-set 53581 53608) (ucs-range->char-set 53609 53636) (ucs-range->char-set 53637 53664) (ucs-range->char-set 53665 53692) (ucs-range->char-set 53693 53720) (ucs-range->char-set 53721 53748) (ucs-range->char-set 53749 53776) (ucs-range->char-set 53777 53804) (ucs-range->char-set 53805 53832) (ucs-range->char-set 53833 53860) (ucs-range->char-set 53861 53888) (ucs-range->char-set 53889 53916) (ucs-range->char-set 53917 53944) (ucs-range->char-set 53945 53972) (ucs-range->char-set 53973 54000) (ucs-range->char-set 54001 54028) (ucs-range->char-set 54029 54056) (ucs-range->char-set 54057 54084) (ucs-range->char-set 54085 54112) (ucs-range->char-set 54113 54140) (ucs-range->char-set 54141 54168) (ucs-range->char-set 54169 54196) (ucs-range->char-set 54197 54224) (ucs-range->char-set 54225 54252) (ucs-range->char-set 54253 54280) (ucs-range->char-set 54281 54308) (ucs-range->char-set 54309 54336) (ucs-range->char-set 54337 54364) (ucs-range->char-set 54365 54392) (ucs-range->char-set 54393 54420) (ucs-range->char-set 54421 54448) (ucs-range->char-set 54449 54476) (ucs-range->char-set 54477 54504) (ucs-range->char-set 54505 54532) (ucs-range->char-set 54533 54560) (ucs-range->char-set 54561 54588) (ucs-range->char-set 54589 54616) (ucs-range->char-set 54617 54644) (ucs-range->char-set 54645 54672) (ucs-range->char-set 54673 54700) (ucs-range->char-set 54701 54728) (ucs-range->char-set 54729 54756) (ucs-range->char-set 54757 54784) (ucs-range->char-set 54785 54812) (ucs-range->char-set 54813 54840) (ucs-range->char-set 54841 54868) (ucs-range->char-set 54869 54896) (ucs-range->char-set 54897 54924) (ucs-range->char-set 54925 54952) (ucs-range->char-set 54953 54980) (ucs-range->char-set 54981 55008) (ucs-range->char-set 55009 55036) (ucs-range->char-set 55037 55064) (ucs-range->char-set 55065 55092) (ucs-range->char-set 55093 55120) (ucs-range->char-set 55121 55148) (ucs-range->char-set 55149 55176) (ucs-range->char-set 55177 55204))))


(define-library (chibi char-set base)
  (import (chibi) (chibi iset base))
  (export (rename Integer-Set Char-Set)
          (rename iset? char-set?)
          immutable-char-set
          char-set-contains?)
  (begin
    (define-syntax immutable-char-set
      (sc-macro-transformer
       (lambda (expr use-env)
         (eval (cadr expr) use-env))))
    (define (char-set-contains? cset ch)
      (iset-contains? cset (char->integer ch)))))
;; Character sets for Unicode boundaries, TR29.

(define-library (chibi char-set boundary)
  (cond-expand
   (chibi
    (import (chibi) (chibi char-set)))
   (else
    (import (scheme base) (srfi 14))
    (begin (define (immutable-char-set cs) cs))))
  (export char-set:regional-indicator
          char-set:extend-or-spacing-mark
          char-set:hangul-l
          char-set:hangul-v
          char-set:hangul-t
          char-set:hangul-lv
          char-set:hangul-lvt)
  ;; generated with:
  ;; tools/extract-unicode-props.scm --derived GraphemeBreakProperty.txt
  ;;   Control extend-or-spacing-mark=Extend,SpacingMark Regional_Indicator
  ;;   hangul-l=:L hangul-v=:V hangul-t=:T hangul-lv=:LV hangul-lvt=:LVT
  (include "boundary.scm"))
;; ast.scm -- ast utilities
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Abstract Syntax Tree.  Interface to the types used by
;;> the compiler, and other core types less commonly
;;> needed in user code, plus related utilities.

;;> \section{Analysis and Expansion}

;;> \procedure{(analyze x [env])}

;;> Expands and analyzes the expression \var{x} and returns the
;;> resulting AST.

;;> \procedure{(optimize ast)}

;;> Runs an optimization pass on \var{ast} and returns the
;;> resulting simplified expression.

(define (ast-renames ast)
  (define i 0)
  (define renames '())
  (define (rename-symbol id)
    (set! i (+ i 1))
    (string->symbol
     (string-append (symbol->string (identifier->symbol id))
                    "." (number->string i))))
  (define (rename-lambda lam)
    (or (assq lam renames)
        (let ((res (list lam)))
          (set! renames (cons res renames))
          res)))
  (define (rename! id lam)
    (let ((cell (rename-lambda lam)))
      (set-cdr! cell (cons (cons id (rename-symbol id)) (cdr cell)))))
  (define (check-ref id lam env)
    (let ((sym (identifier->symbol id)))
      (let lp1 ((ls env))
        (cond
         ((pair? ls)
          (let lp2 ((ls2 (car ls)) (found? #f))
            (cond
             ((null? ls2)
              (if (not found?) (lp1 (cdr ls))))
             ((and (eq? id (caar ls2)) (eq? lam (cdar ls2)))
               (lp2 (cdr ls2) #t))
             ((eq? sym (identifier->symbol (caar ls2)))
              (rename! (caar ls2) (cdar ls2))
              (lp2 (cdr ls2) found?))
             (else
              (lp2 (cdr ls2) found?)))))))))
  (define (extend-env lam env)
    (cons (map (lambda (x) (cons x lam)) (flatten-dot (lambda-params lam))) env))
  (let lp ((x ast) (env '()))
    (cond
     ((lambda? x) (lp (lambda-body x) (extend-env x env)))
     ((ref? x) (check-ref (ref-name x) (cdr (ref-cell x)) env))
     ((cnd? x) (lp (cnd-test x) env) (lp (cnd-pass x) env) (lp (cnd-fail x) env))
     ((set? x) (lp (set-var x) env) (lp (set-value x) env))
     ((seq? x) (for-each (lambda (x) (lp x env)) (seq-ls x)))
     ((pair? x) (for-each (lambda (x) (lp x env)) x))))
  renames)

(define (flatten-dot x)
  (cond ((pair? x) (cons (car x) (flatten-dot (cdr x))))
        ((null? x) x)
        (else (list x))))

(define (get-rename id lam renames)
  (let ((ls (assq lam renames)))
    (if (not ls)
        (identifier->symbol id)
        (cond ((assq id (cdr ls)) => cdr) (else (identifier->symbol id))))))

(define (map* f ls)
  (cond ((pair? ls) (cons (f (car ls)) (map* f (cdr ls))))
        ((null? ls) '())
        (else (f ls))))

;;> Performs a full syntax expansion of the form \var{x} and
;;> returns the resulting s-expression.

(define (macroexpand x)
  (ast->sexp (analyze x)))

;;> Convert \var{ast} to a s-expression, renaming variables if
;;> necessary.

(define (ast->sexp ast)
  (let ((renames (ast-renames ast)))
    (let a2s ((x ast))
      (cond
       ((lambda? x)
        `(lambda ,(map* (lambda (id) (get-rename id x renames)) (lambda-params x))
           ,@(map (lambda (d) `(define ,(identifier->symbol (caar d)) #f))
                  (lambda-defs x))
           ,@(if (seq? (lambda-body x))
                 (map a2s (seq-ls (lambda-body x)))
                 (list (a2s (lambda-body x))))))
       ((cnd? x) `(if ,(a2s (cnd-test x)) ,(a2s (cnd-pass x)) ,(a2s (cnd-fail x))))
       ((set? x) `(set! ,(a2s (set-var x)) ,(a2s (set-value x))))
       ((ref? x) (get-rename (ref-name x) (cdr (ref-cell x)) renames))
       ((seq? x) `(begin ,@(map a2s (seq-ls x))))
       ((lit? x)
        (let ((v (lit-value x)))
          (if (or (pair? v) (null? v) (symbol? v)) `',v v)))
       ((pair? x) (cons (a2s (car x)) (a2s (cdr x))))
       ((opcode? x) (cond ((opcode-name x) => string->symbol) (else x)))
       (else x)))))

;;> \section{Types}

;;> All objects have an associated type, and types may have parent
;;> types.  When using
;;> \hyperlink["http://srfi.schemers.org/srfi-9/srfi-9/html"]{SRFI-9}
;;> \scheme{define-record-type}, the name is bound to a first class
;;> type object.

;;> The following core types are also available by name, and may be
;;> used in the \scheme{match} \scheme{($ ...)} syntax.

;;> \itemlist[
;;> \item{\scheme{<object>} - the parent of all types}
;;> \item{\scheme{<number>} - abstract numeric type}
;;> \item{\scheme{<bignum>} - arbitrary precision exact integers}
;;> \item{\scheme{<flonum>} - inexact real numbers}
;;> \item{\scheme{<integer>} - abstract integer type}
;;> \item{\scheme{<symbol>} - symbols}
;;> \item{\scheme{<char>} - character}
;;> \item{\scheme{<boolean>} - \scheme{#t} or \scheme{#f}}
;;> \item{\scheme{<string>} - strings of characters}
;;> \item{\scheme{<byte-vector>} - uniform vector of octets}
;;> \item{\scheme{<pair>} - a \var{car} and \var{cdr}, the basis for lists}
;;> \item{\scheme{<vector>} - vectors}
;;> \item{\scheme{<opcode>} - a primitive opcode or C function}
;;> \item{\scheme{<procedure>} - a closure}
;;> \item{\scheme{<bytecode>} - the compiled code for a closure}
;;> \item{\scheme{<env>} - an environment structure}
;;> \item{\scheme{<macro>} - a macro object, usually not first-class}
;;> \item{\scheme{<lam>} - a lambda AST type}
;;> \item{\scheme{<cnd>} - an conditional AST type (i.e. \scheme{if})}
;;> \item{\scheme{<ref>} - a reference AST type}
;;> \item{\scheme{<set>} - a mutation AST type (i.e. \scheme{set!})}
;;> \item{\scheme{<seq>} - a sequence AST type}
;;> \item{\scheme{<lit>} - a literal AST type}
;;> \item{\scheme{<sc>} - a syntactic closure}
;;> \item{\scheme{<context>} - a context object (including threads)}
;;> \item{\scheme{<exception>} - an exception object}
;;> ]

;;> The following extended type predicates may also be used to test
;;> individual objects for their type:

;;> \itemlist[
;;> \item{\scheme{environment?}}
;;> \item{\scheme{bytecode?}}
;;> \item{\scheme{macro?}}
;;> \item{\scheme{syntactic-closure?}}
;;> \item{\scheme{lambda?}}
;;> \item{\scheme{cnd?}}
;;> \item{\scheme{ref?}}
;;> \item{\scheme{set?}}
;;> \item{\scheme{seq?}}
;;> \item{\scheme{lit?}}
;;> \item{\scheme{opcode?}}
;;> \item{\scheme{type?}}
;;> \item{\scheme{context?}}
;;> \item{\scheme{exception?}}
;;> ]

;;> \procedure{(type-of x)}

;;> Returns the type of any object \var{x}.

;;> \procedure{(type-name type)}

;;> Returns the name of type \var{type}.

;;> \procedure{(type-parent type)}

;;> Returns the immediate parent of type \var{type},
;;> or \scheme{#f} for a type with no parent.

(define (type-parent type)
  (let ((v (type-cpl type)))
    (and (vector? v)
         (> (vector-length v) 1)
         (vector-ref v (- (vector-length v) 2)))))

;;> \procedure{(type-cpl type)}

;;> Returns the class precedence list of type \var{type} as a
;;> vector, or \scheme{#f} for a type with no parent.

;;> \procedure{(type-slots type)}

;;> Returns the slot list of type \var{type}.

;;> \section{Accessors}

;;> This section describes additional accessors on AST and other core
;;> types.

;;> \subsection{Procedures}

;;> \itemlist[
;;> \item{\scheme{(procedure-code f)} - the compiled bytecode object}
;;> \item{\scheme{(procedure-vars f)} - the variables closed over by \var{f}}
;;> \item{\scheme{(procedure-name f)} - the name of \var{f} if known, else \scheme{#f}}
;;> ]

(define (procedure-name x)
  (bytecode-name (procedure-code x)))

(define (procedure-name-set! x name)
  (bytecode-name-set! (procedure-code x) name))

;;> \subsection{Macros}

;;> \itemlist[
;;> \item{\scheme{(macro-procedure f)} - the macro procedure}
;;> \item{\scheme{(macro-env f)} - the environment the macro was defined in}
;;> \item{\scheme{(macro-source f)} - the source location the macro was defined in}
;;> ]

;;> \subsection{Bytecode Objects}

;;> \itemlist[
;;> \item{\scheme{(bytecode-name bc)} - the macro procedure}
;;> \item{\scheme{(bytecode-literals bc)} - literals the bytecode references}
;;> \item{\scheme{(bytecode-source bc)} - the source location the procedure was defined in}
;;> ]

;;> \subsection{Syntactic Closures}

;;> \itemlist[
;;> \item{\scheme{(syntactic-closure-env sc)}}
;;> \item{\scheme{(syntactic-closure-vars sc)}}
;;> \item{\scheme{(syntactic-closure-expr sc)}}
;;> ]

;;> Return the environment, free variables, and expression
;;> associated with \var{sc} respectively.

;;> \subsection{Exceptions}

;;> \itemlist[
;;> \item{\scheme{(exception-kind exn)}}
;;> \item{\scheme{(exception-message exn)}}
;;> \item{\scheme{(exception-irritants exn)}}
;;> ]

;;> Return the kind, message, and irritants
;;> associated with \var{exn} respectively.

;;> \subsection{Lambdas}

;;> \itemlist[
;;> \item{\scheme{(lambda-name lam)} - the name of the lambda, if known}
;;> \item{\scheme{(lambda-name-set! lam x)}}
;;> \item{\scheme{(lambda-params lam)} - the lambda parameter list}
;;> \item{\scheme{(lambda-params-set! lam x)}}
;;> \item{\scheme{(lambda-body lam)} - the body of the lambda}
;;> \item{\scheme{(lambda-body-set! lam x)}}
;;> \item{\scheme{(lambda-defs lam)} - internal definitions of the lambda}
;;> \item{\scheme{(lambda-defs-set! lam x)}}
;;> \item{\scheme{(lambda-locals lam)} - local variables as a list of identifiers}
;;> \item{\scheme{(lambda-locals-set! lam x)}}
;;> \item{\scheme{(lambda-flags lam)} - various flags describing the lambda}
;;> \item{\scheme{(lambda-flags-set! lam x)}}
;;> \item{\scheme{(lambda-free-vars lam)} - free variables the lambda will need to close over}
;;> \item{\scheme{(lambda-free-vars-set! lam x)}}
;;> \item{\scheme{(lambda-set-vars lam)} - variables the lambda mutates}
;;> \item{\scheme{(lambda-set-vars-set! lam x)}}
;;> \item{\scheme{(lambda-return-type lam)} - the return type of the lambda}
;;> \item{\scheme{(lambda-return-type-set! lam x)}}
;;> \item{\scheme{(lambda-param-types lam)} - the types of the input parameters}
;;> \item{\scheme{(lambda-param-types-set! lam x)}}
;;> \item{\scheme{(lambda-source lam)} - the source code of the lambda}
;;> \item{\scheme{(lambda-source-set! lam x)}}
;;> ]

;;> \subsection{Conditionals}

;;> \itemlist[
;;> \item{\scheme{(cnd-test cnd)} - the test for the conditional}
;;> \item{\scheme{(cnd-test-set! cnd x)}}
;;> \item{\scheme{(cnd-pass cnd)} - the success branch}
;;> \item{\scheme{(cnd-pass-set! cnd x)}}
;;> \item{\scheme{(cnd-fail cnd)} - the failure branch}
;;> \item{\scheme{(cnd-fail-set! cnd x)}}
;;> ]

;;> \subsection{Sequences}

;;> \itemlist[
;;> \item{\scheme{(seq-ls seq)} - the list of sequence expressions}
;;> \item{\scheme{(seq-ls-set! seq x)}}
;;> ]

;;> \subsection{References}

;;> \itemlist[
;;> \item{\scheme{(ref-name ref)} - the name of the referenced variable}
;;> \item{\scheme{(ref-name-set! ref x)}}
;;> \item{\scheme{(ref-cell ref)} - the environment cell the reference resolves to}
;;> \item{\scheme{(ref-cell-set! ref x)}}
;;> ]

;;> \subsection{Mutations}

;;> \itemlist[
;;> \item{\scheme{(set-var set)} - a reference to the mutated variable}
;;> \item{\scheme{(set-var-set! set x)}}
;;> \item{\scheme{(set-value set)} - the value to set the variable to}
;;> \item{\scheme{(set-value-set! set x)}}
;;> ]

;;> \subsection{Literals}

;;> \itemlist[
;;> \item{\scheme{(lit-value lit)} - the literal value}
;;> \item{\scheme{(lit-value-set! lit x)}}
;;> ]

;;> \subsection{Pairs}

;;> \itemlist[
;;> \item{\scheme{(pair-source x)}}
;;> \item{\scheme{(pair-source-set! x source)}}
;;> ]

;;> Set or return the source code info associated with a pair x.
;;> Source info is represented as another pair whose \var{car} is
;;> the source file name and whose \var{cdr} is the line number.

;;> \section{Miscellaneous Utilities}

;;> \procedure{(gc)}

;;> Force a garbage collection.

;;> \procedure{(object-size x)}

;;> Returns the heap space directly used by \var{x}, not
;;> counting any elements of \var{x}.

;;> \procedure{(integer->immediate n)}

;;> Returns the interpretation of the integer \var{n} as
;;> an immediate object, useful for debugging.

;;> \procedure{(string-contains str pat)}

;;> Returns the first string cursor of \var{pat} in \var{str},
;;> of \scheme{#f} if it's not found.

;;> \procedure{(safe-setenv name value)}

;;> Equivalent to \scheme{setenv} but does nothing and returns
;;> \scheme{#f} if \var{value} is a function definition.  Used to
;;> circumvent the vulnerability of the shellshock bug.

(define (safe-setenv name value)
  (define (function-def? str)
    (and (> (string-size value) 5)
         (equal? "() {" (substring value 0 4))))
  (and (not (function-def? value))
       (setenv name value)))

;;> \procedure{(atomically expr)}

;;> Run \var{expr} atomically, disabling yields.  Ideally should only be
;;> used for brief, deterministic expressions.  If used incorrectly (e.g.
;;> running an infinite loop) can render the system unusable.
;;> Never expose to a sandbox.

(cond-expand
 (threads
  (define-syntax atomically
    (syntax-rules ()
      ((atomically . body)
       (let* ((atomic? (%set-atomic! #t))
              (res (begin . body)))
         (%set-atomic! atomic?)
         res)))))
 (else
  (define-syntax atomically
    (syntax-rules () ((atomically . body) (begin . body))))))

;;> \subsubsubsection{(trace proc)}

;;> Write a trace of all calls to the procedure \var{proc} to
;;> \scheme{(current-error-port)}.

;;> \subsubsubsection{(untrace proc)}

;;> Remove any active traces on the procedure \var{proc}.

;;> \subsubsubsection{(untrace-all)}

;;> Remove all active procedure traces.

(define-library (chibi trace)
  (export trace untrace untrace-all trace-cell untrace-cell)
  (import (chibi) (chibi ast) (srfi 38) (srfi 39) (srfi 69))
  (include "trace.scm"))

(define-library (chibi config)
  (export make-conf conf? conf-load conf-load-in-path conf-load-cascaded
          conf-verify conf-extend conf-append conf-set conf-unfold-key
          conf-get conf-get-list conf-get-cdr conf-get-multi
          conf-specialize read-from-file conf-source conf-head conf-parent
          assoc-get assoc-get-list)
  (import (scheme base) (scheme read) (scheme write) (scheme file)
          (scheme time) (srfi 1))
  ;; This is only used for config verification, it's acceptable to
  ;; substitute file existence for the stronger directory check.
  (cond-expand
   (chibi (import (only (chibi filesystem) file-directory?)))
   (else (begin (define file-directory? file-exists?))))
  (include "config.scm"))
;; environment.scm - the environment (reader) monad for Scheme
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A Scheme take on the environment (reader) monad, focusing more on
;;> being efficient and convenient than pure.

;;> \macro{(define-environment-monad name keyword: value ...)}
;;>
;;> Define a new environment monad.  This syntax hides the
;;> implementation, allowing the use of records, dynamic parameters,
;;> or explicit value passing.
;;>
;;> The \var{name} is used for description and may or may not be bound
;;> to a value representing the monad.  All other parameters are
;;> keywords, and with the exception of \scheme{fields} simply provide
;;> binding names for the monad operators described below.
;;>
;;> The \scheme{fields:} keyword takes a list of field name
;;> identifiers known to be used by the monad.  This is an
;;> optimization hint, as the monad can be used to store and query
;;> values for any identifier at runtime.
;;>
;;> The following keywords obey the definition of a monad:
;;>
;;> sequence: sequence (>>) - Essentially a semi-colon, this joins two
;;>  operations together.
;;>
;;> bind: (>>=) - Runs a normal function.  As a syntactic convenience,
;;>  \scheme{bind} looks and behaves like a lambda, but the parameters
;;>  of the \scheme{bind} are bound as Scheme variables with the
;;>  values of the corresponding environment variables.  Thus you
;;>  fetch the values of foo and bar with:
;;>
;;>    \scheme{(bind (foo bar) ...)}
;;>
;;>  hiding the need for an explicit \scheme{ask}.  If you want to
;;>  bind the values to some other name, you can use it like a
;;>  \scheme{let}:
;;>
;;>    \scheme{(bind ((my-foo foo) (my-bar bar)) ...)}
;;>
;;> return: Returns a pure (non-monadic) value.
;;>
;;> run: Start the monad.
;;>
;;> The following are specific to the environment monad:
;;>
;;> ask: Ask the current value of an environment variable.  This is not
;;>  meant to be used directly - use the `bind' syntax to query bindings.
;;>
;;> local: Shadow the value one or more environment variables,
;;>  analogous to `let'.
;;>
;;> In addition, support for optional mutation is provided:
;;>
;;> local!: (local! (var val) ...) will update the environment with
;;>  the corresponding variable bindings.  In a sequence, successive
;;>  operations will see the result of the update, unlike with `local'.
;;>  This is allowed, but not required, to perform mutation.
;;>
;;> bind-fork: \scheme{(bind-fork a b)} runs `a' followed by `b',
;;>   passing `b' the original state before `a' was run.

(define-syntax define-environment-monad
  (syntax-rules ()
    ((define-environment-monad name clauses ...)
     (dem name (ask %ask) (tell %tell) c f! f s r w u z () clauses ...))))

(define-syntax dem
  (syntax-rules (fields: sequence: bind: bind-fork:
                 local: local!: run: return: ask: tell: copy:)
    ((dem n ask tell c f! f s r w u z (fls ...)
          (fields: (fl get put) . fl-r) . x)
     (dem n ask tell c f! f s r w u z (fls ... (fl #f get put))
          (fields: . fl-r) . x))
    ((dem n ask tell c f! f s r w u z (fls ...) (fields:) . x)
     (dem n ask tell c f! f s r w u z (fls ...) . x))
    ((dem n ask tell c f! f s r w u z ())
     (syntax-error "missing fields clause in define-state-monad"))
    ((dem n ask tell c f! f s r w u z fls (bind: fn!) . x)
     (dem n ask tell c fn! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (bind-fork: fn) . x)
     (dem n ask tell c f! fn s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (sequence: seq) . x)
     (dem n ask tell c f! f seq r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (run: run) . x)
     (dem n ask tell c f! f s run w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (return: return) . x)
     (dem n ask tell c f! f s r w u return fls . x))
    ((dem n ask tell c f! f s r w u z fls (local: local) . x)
     (dem n ask tell c f! f s r local u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (local!: local!) . x)
     (dem n ask tell c f! f s r w local! z fls . x))
    ((dem n ask tell c f! f s r w u z fls (ask: a %a) . x)
     (dem n (a %a) tell c f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (tell: t %t) . x)
     (dem n ask (t %t) c f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (copy: copy) . x)
     (dem n ask tell copy f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls clause . x)
     (syntax-error "unknown clause" 'clause))
    ((dem n (ask %ask) (tell %tell) c f! f s r w u z ((field init get put) ...))
     (begin
       ;; Internals
       (define-record-type n
         (make-state field ... %props)
         state?
         (field get put) ...
         (%props get-props set-props!))
       (define (%ask st x)
         (case x
           ((field) (get st)) ...
           (else (cond ((assq x (get-props st)) => cdr) (else #f)))))
       (define-syntax ask
         (syntax-rules (quote field ...)
           ((ask st 'field) (get st)) ...
           ((ask st x) (%ask st x))))
       (define (%tell st x val)
         (case x
           ((field) (put st val)) ...
           (else
            (cond
             ((assq x (get-props st))
              => (lambda (cell) (set-cdr! cell val)))
             (else
              (set-props! st (cons (cons x val) (get-props st))))))))
       (define-syntax tell
         (syntax-rules (quote field ...)
           ((tell st 'field val) (put st val)) ...
           ((tell st x val) (%tell st x val))))
       ;; External API
       ;;
       ;; copy
       (define (c st)
         (make-state
          (get st) ...
          (map (lambda (x) (cons (car x) (cdr x))) (get-props st))))
       ;; bind - a function
       (define-syntax f!
         (syntax-rules ::: ()
           ((f! ("step") (params :::) ((p param) . rest) . body)
            (f! ("step") (params ::: (p param)) rest . body))
           ((f! ("step") (params :::) ((param) . rest) . body)
            (f! ("step") (params ::: (param param)) rest . body))
           ((f! ("step") (params :::) (param . rest) . body)
            (f! ("step") (params ::: (param param)) rest . body))
           ((f! ("step") ((p param) :::) () . body)
            (lambda (st)
              (let ((p (ask st 'param)) :::)
                ((let () . body) st))))
           ((f! params . body)
            (f! ("step") () params . body))))
       ;; fork - run on a copy of the state
       (define-syntax f
         (syntax-rules ()
           ((f a) a)
           ((f a b) (lambda (st) (a (c st)) (b st)))
           ((f a b . c) (f a (f b . c)))))
       ;; sequence
       (define-syntax s
         (syntax-rules ()
           ((s f) f)
           ((s f . g) (lambda (st) ((s . g) (f st))))))
       ;; update in place
       (define-syntax u
         (syntax-rules ::: ()
           ((u (prop value) :::)
            (lambda (st)
              (tell st 'prop value) :::
              st))))
       ;; local binding - update temporarily
       (define-syntax w
         (syntax-rules ::: ()
           ((w ("step") ((p tmp v) :::) () . b)
            (lambda (st)
              (let ((tmp (ask st 'p)) :::)
                (tell st 'p v) :::
                (let ((st ((begin . b) st)))
                  (tell st 'p tmp) :::
                  st))))
           ((w ("step") (props :::) ((p v) . rest) . b)
            (w ("step") (props ::: (p tmp v)) rest . b))
           ((w ((prop value) :::) . body)
            (w ("step") () ((prop value) :::) . body))))
       ;; run
       (define (r proc)
         (proc (make-state init ... '())))
       ;; return
       (define (z x)
         (lambda (st) x))))))

(define-library (chibi monad environment)
  (export define-environment-monad)
  (import (scheme base))
  (include "environment.scm"))

(define-library (chibi optimize)
  (import (chibi) (chibi ast) (chibi match) (srfi 1))
  (export register-lambda-optimization!
          replace-references
          fold-every join-seq dotted-tail)
  (include "optimize.scm"))

(define-library (chibi time)
  (export current-seconds get-time-of-day
          seconds->time seconds->string time->seconds time->string
          make-timeval make-tm timeval-seconds timeval-microseconds
          timezone-offset timezone-dst-time
          time-second time-minute time-hour time-day time-month time-year
          time-day-of-week time-day-of-year time-dst? time-timezone-name
          time-offset
          tm? timeval? timezone?)
  (cond-expand
    (emscripten)
    (else
      (export set-time-of-day!)))
  (cond-expand
   ((or bsd linux)
    (export rusage? resource-usage-time resource-usage-system-time
            resource-usage-max-rss resource-usage/self
            resource-usage/children get-resource-usage))
   (else))
  (import (chibi))
  (include-shared "time"))

(define-library (chibi scribble)
  (export scribble-parse scribble-read)
  (import (chibi))
  (include "scribble.scm"))
;; base.scm - base integer set operations
;; Copyright (c) 2004-2012 Alex Shinn. All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; An integer set (iset) is a set of exact integers optimized for
;; minimal space usage and fast membership lookup.  General set
;; operations are provided based on the character set operations found
;; in SRFI-14.
;;
;; Creating isets:
;;
;; (make-iset)     ; an empty integer set
;; (make-iset n)   ; a set of the single integer N
;; (make-iset n m) ; a set of the range of all integers from N-M inclusive
;;
;; The following procedures are provided as direct analogs of the
;; SRFI-14 procedures, accepting and returning isets and integers in
;; place of char-sets and characters:
;;
;; Creating isets:
;;
;; (iset-copy is)            ; a new copy of IS
;; (iset n ...)              ; an iset containing the elements N...
;; (list->iset ls [base-is]) ; an iset containing all the integers in
;;                           ; list LS, union BASE-IS if provided
;; (list->iset! ls base-is)  ; same as above, allowed but not required to
;;                           ; modify base-is
;;
;; Querying isets:
;;
;; (iset-size is)          ; return the # of elements in IS
;; (iset-contains? is n)   ; test N for membership in IS
;; (iset->list is)         ; returns a list of all integers in IS
;;
;; Predicates:
;;
;; (iset? obj)     ; #t iff obj is an integer set
;; (iset= is ...)  ; #t iff all arguments are equivalent integer sets
;; (iset<= is ...) ; #t iff the arguments are monotonically increasing sets
;; (iset>= is ...) ; #t iff the arguments are monotonically decreasing sets
;;
;; Cursors:
;;
;; (iset-cursor iset)
;; (iset-ref iset cursor)
;; (iset-cursor-next iset cursor)
;; (end-of-iset? iset)
;;
;; Set operations:
;;
;; (iset-adjoin is n ...)         ; char-set-adjoin
;; (iset-delete is n ...)         ; char-set-delete
;;
;; (iset-adjoin! is n ...)        ; char-set-adjoin!
;; (iset-delete! is n ...)        ; char-set-delete!
;;
;; (iset-union is1 ...)                  ; char-set-union
;; (iset-intersection is1 ...)           ; char-set-intersection
;; (iset-difference is1 is2 ...)         ; char-set-difference
;;
;; (iset-union! is1 ...)                 ; char-set-union!
;; (iset-intersection! is1 ...)          ; char-set-intersection!
;; (iset-difference! is1 is2 ...)        ; char-set-difference!

(define-library (chibi iset)
  (import (chibi iset base)
          (chibi iset iterators)
          (chibi iset constructors))
  (export
   %make-iset make-iset iset? iset-contains? Integer-Set
   iset iset-copy list->iset list->iset! iset-map
   iset-adjoin iset-adjoin! iset-delete iset-delete!
   iset-union iset-union! iset-intersection iset-intersection!
   iset-difference iset-difference!
   iset-empty? iset-fold iset-fold-node iset-for-each iset-for-each-node
   iset-map iset->list iset-size iset= iset<= iset>=
   iset-cursor iset-cursor? iset-cursor-next iset-ref end-of-iset?))

(define-library (chibi loop)
  (export loop in-list in-lists in-port in-file up-from down-from
          listing listing-reverse appending appending-reverse
          summing multiplying in-string in-string-reverse
          in-vector in-vector-reverse)
  (import (chibi))
  (include "loop/loop.scm"))


(define-library (chibi quoted-printable)
  (export quoted-printable-encode quoted-printable-encode-string
          quoted-printable-encode-bytevector
          quoted-printable-encode-header
          quoted-printable-decode quoted-printable-decode-string
          quoted-printable-decode-bytevector)
  (import (scheme base) (srfi 33) (chibi io))
  (include "quoted-printable.scm"))
;;;; loop.scm - the chibi loop (aka foof-loop)
;;
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> The loop API is mostly compatible with Taylor Campbell's
;;> \hyperlink["http://mumble.net/~campbell/scheme/foof-loop.txt"]{foof-loop},
;;> but the iterator API is different and subject to change.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (assoc-pred equal elt ls)
  (and (pair? ls)
       (if (equal elt (car (car ls)))
           (car ls)
           (assoc-pred equal elt (cdr ls)))))

(define-syntax let-keyword-form
  (syntax-rules ()
    ((let-keyword-form
      ((labeled-arg-macro-name (positional-name . params)))
      . body)
     (let-syntax
         ((labeled-arg-macro-name
           (er-macro-transformer
            (lambda (expr rename compare)
              (let lp ((ls (cdr expr)) (named '()) (posns '()))
                (cond
                 ((pair? ls)
                  (if (and (list? (car ls)) (compare (caar ls) (rename '=>)))
                      (lp (cdr ls) (cons (cdar ls) named) posns)
                      (lp (cdr ls) named (cons (car ls) posns))))
                 (else
                  (let lp ((ls (syntax-quote params))
                           (posns (reverse posns))
                           (args '()))
                    (cond
                     ((null? ls)
                      (if (pair? posns)
                          (error "let-keyword-form: too many args" expr)
                          (cons (syntax-quote positional-name) (reverse args))))
                     ((assoc-pred compare (caar ls) named)
                      => (lambda (x) (lp (cdr ls) posns (cons (cadr x) args))))
                     ((pair? posns)
                      (lp (cdr ls) (cdr posns) (cons (car posns) args)))
                     (else
                      (lp (cdr ls) posns (cons (car (cdar ls)) args))))))))))))
       . body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \subsubsubsection{\scheme{(loop [name] (vars ...) [=> result] body ...)}}

(define-syntax loop
  (syntax-rules ()
    ;; unnamed, implicit recursion
    ((loop (vars ...) body ...)
     (%loop tmp-loop () () () () () (vars ...) body ... (tmp-loop)))
    ;; named, explicit recursion
    ((loop name (vars ...) body ...)
     (%loop name () () () () () (vars ...) body ...))))

;; Main LOOP macro. Separate the variables from the iterator and
;; parameters, then walk through each parameter expanding the
;; bindings, and build the final form.

(define-syntax %loop
  (syntax-rules (=> for with let while until)
    ;; automatic iteration
    ((_ name l v c r f ((for var1 (iterator source ...)) rest ...) . body)
     (iterator ((var1) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 var3 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2 var3) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 var3 var4 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2 var3 var4) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ;; do equivalents, with optional guards
    ((_ name l (vars ...) (checks ...) r f ((with var init step guard) rest ...) . body)
     (%loop name l (vars ... (var init step)) (checks ... (guard var)) r f (rest ...) . body))
    ((_ name l (vars ...) c r f ((with var init step) rest ...) . body)
     (%loop name l (vars ... (var init step)) c r f (rest ...) . body))
    ((_ name l (vars ...) c r f ((with var init) rest ...) . body)
     (%loop name l (vars ... (var init var)) c r f (rest ...) . body))
    ;; user-specified terminators
    ((_ name l vars (checks ...) r f ((until expr) rest ...) . body)
     (%loop name l vars (checks ... expr) r f (rest ...) . body))
    ((_ name l vars (checks ...) r f ((while expr) rest ...) . body)
     (%loop name l vars (checks ... (not expr)) r f (rest ...) . body))
    ;; specify a default done?
    ((_ name l v c r f ())
     (%loop name l v c r f () (#f #f)))
    ((_ name l v c r f () () . body)
     (%loop name l v c r f () (#f #f) . body))
    ;; final expansion
    ((_ name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
        => result
        . body)
     (let* (lets ...)
       (letrec ((tmp (lambda (var ...)
                       (if (or checks ...)
                           (let-keyword-form ((name (tmp (var step) ...)))
                             (let (finals ...) result))
                           (let (refs ...)
                             (let-keyword-form ((name (tmp (var step) ...)))
                               (if #f #f)
                               . body))))))
         (tmp init ...))))
    ;; unspecified return value case
    ((_ name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
        . body)
     (%loop name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
            => (if #f #f) . body))
    ))

(define-syntax %loop-next
  (syntax-rules ()
    ((_ (new-lets ...) (new-vars ...) (new-checks ...) (new-refs ...) (new-finals ...)
        name (lets ...) (vars ...) (checks ...) (refs ...) (finals ...)
        . rest)
     (%loop name (lets ... new-lets ...) (vars ... new-vars ...)
                 (checks ... new-checks ...) (refs ... new-refs ...)
                 (finals ... new-finals ...)
        . rest))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;> \section{Iterators}

;; Each gets passed two lists, those items left of the macro and those to
;; the right, followed by a NEXT and REST continuation.
;;
;; Should finish with
;;
;; \schemeblock{
;;  (next (outer-vars ...) (cursor-vars ...) (done?-tests ...)
;;        (loop-vars ...) (final-vars ...) . rest)
;; }
;;
;; \itemlist[
;; \item{\var{outer-vars} - bound once outside the loop in a LET*}
;; \item{\var{cursor-vars} - DO-style bindings of the form (name init update)}
;; \item{\var{done?-tests} - possibly empty list of forms that terminate the loop on #t}
;; \item{\var{loop-vars} - inner variables, updated in parallel after the cursors}
;; \item{\var{final-vars} - final variables, bound only in the => result}
;; ]

;;> \subsubsubsection{\scheme{(for var [pair] (in-list ls [cdr]))}}

;;> Basic list iterator.

(define-syntax in-list                  ; called just "IN" in ITER
  (syntax-rules ()
    ((in-list ((var) source) next . rest)
     (in-list ((var cursor) source) next . rest))
    ((in-list ((var cursor) source) next . rest)
     (in-list ((var cursor succ) source) next . rest))
    ((in-list ((var cursor succ) (source)) next . rest)
     (next ()                         ; outer let bindings
           ((cursor source succ))     ; iterator, init, step
           ((not (pair? cursor)))     ; finish tests for iterator vars
           ;; step variables and values
           ((var (car cursor))
            (succ (cdr cursor)))
           ()                           ; final result bindings
           . rest))
    ((in-list ((var cursor succ) (source step)) next . rest)
     (next ()
           ((cursor source succ))
           ((not (pair? cursor)))
           ((var (car cursor))
            (succ (step cursor)))
           ()
           . rest))))

;;> \macro{(for elts [pairs] (in-lists lol [cdr [done?]]))}

;;> Iterator from Taylor R. Campbell.  If you know the number of lists
;;> ahead of time it's much more efficient to iterate over each one
;;> separately.

(define-syntax in-lists
  (syntax-rules ()
    ((in-lists ((elts) lol) next . rest)
     (in-lists ((elts pairs) lol) next . rest))
    ((in-lists ((elts pairs) lol) next . rest)
     (in-lists ((elts pairs succ) lol) next . rest))
    ((in-lists ((elts pairs succ) (lol)) next . rest)
     (in-lists ((elts pairs succ) (lol cdr)) next . rest))
    ((in-lists ((elts pairs succ) (lol)) next . rest)
     (in-lists ((elts pairs succ) (lol cdr)) next . rest))
    ((in-lists ((elts pairs succ) (lol step)) next . rest)
     (in-lists ((elts pairs succ) (lol step null?)) next . rest))
    ((in-lists ((elts pairs succ) (lol step done?)) next . rest)
     (next ()
           ((pairs lol succ))
           ((let lp ((ls pairs)) ; an in-lined ANY
              (and (pair? ls) (if (done? (car ls)) #t (lp (cdr ls))))))
           ((elts (map car pairs))
            (succ (map step pairs)))
           ()
           . rest))
    ))

(define-syntax define-in-indexed
  (syntax-rules ()
    ((define-in-indexed in-type in-type-reverse length ref)
     (begin
       (define-syntax in-type
         (syntax-rules ()
           ((in-type seq next . rest)
            (%in-idx >= (lambda (x i) (+ i 1)) (lambda (x) 0) length ref tmp seq next . rest))))
       (define-syntax in-type-reverse
         (syntax-rules ()
           ((in-type-reverse seq next . rest)
            (%in-idx < (lambda (x i) (- i 1)) (lambda (x) (- (length x) 1)) (lambda (x) 0) ref tmp seq next . rest))))
       ))))

;;> \macro{(for var [index] (in-vector vec))}
;;> \macro{(for var [index] (in-vector-reverse vec))}

(define-in-indexed in-vector in-vector-reverse vector-length vector-ref)

;;> \macro{(for ch [cursor] (in-string str))}

(define-syntax in-string
  (syntax-rules ()
    ((in-string s next . rest)
     (%in-idx string-cursor>=? string-cursor-next
              string-cursor-start string-cursor-end string-cursor-ref
              tmp s next . rest))))

;;> \macro{(for ch [cursor] (in-string-reverse str))}

(define-syntax in-string-reverse
  (syntax-rules ()
    ((in-string-reverse s next . rest)
     (%in-idx string-cursor<? string-cursor-prev
              (lambda (x) (string-cursor-prev x (string-cursor-end x)))
              string-cursor-start string-cursor-ref
              tmp s next . rest))))

;; helper for the above string and vector iterators
(define-syntax %in-idx
  (syntax-rules ()
    ;;   cmp inc start end ref
    ((%in-idx ge + s e r tmp ((var) (seq ...)) next . rest)
     (%in-idx ge + s e r tmp ((var seq-index) (seq ...)) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq)) next . rest)
     (%in-idx ge + s e r tmp ((var index) (seq (s tmp) (e tmp))) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq from)) next . rest)
     (%in-idx ge + s e r tmp ((var index) (seq from (e tmp))) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq from to)) next . rest)
     (next ((tmp seq) (end to))
           ((index from (+ tmp index)))
           ((ge index end))
           ((var (r tmp index)))
           ()
       . rest))
    ))

;;> \macro{(for ch (in-port [input-port [reader [eof?]]]))}

(define-syntax in-port
  (syntax-rules ()
    ((in-port ((var) source) next . rest)
     (in-port ((var p) source) next . rest))
    ((in-port ((var p) ()) next . rest)
     (in-port ((var p) ((current-input-port))) next . rest))
    ((in-port ((var p) (port)) next . rest)
     (in-port ((var p) (port read-char)) next . rest))
    ((in-port ((var p) (port read-char)) next . rest)
     (in-port ((var p) (port read-char eof-object?)) next . rest))
    ((in-port ((var p) (port reader eof?)) next . rest)
     (next ((p port) (r reader) (e? eof?))
           ((var (r p) (r p)))
           ((e? var))
           ()
           ()
       . rest))))

;;> \macro{(for ch (in-file [input-port [reader [eof?]]]))}

(define-syntax in-file
  (syntax-rules ()
    ((in-file ((var) source) next . rest)
     (in-file ((var p) source) next . rest))
    ((in-file ((var p) (file)) next . rest)
     (in-file ((var p) (file read-char)) next . rest))
    ((in-file ((var p) (file reader)) next . rest)
     (in-file ((var p) (file reader eof-object?)) next . rest))
    ((in-file ((var p) (file reader eof?)) next . rest)
     (next ((p (open-input-file file)) (r reader) (e? eof?))
           ((var (r p) (r p)))
           ((e? var))
           ()
           ((dummy (close-input-port p)))
       . rest))))

;;> \macro{(for x (up-from [start] [(to limit)] [(by step)]))}

(define-syntax up-from
  (syntax-rules (to by)
    ((up-from (() . args) next . rest)
     (up-from ((var) . args) next . rest))
    ((up-from ((var) (start (to limit) (by step))) next . rest)
     (next ((s start) (l limit) (e step))
           ((var s (+ var e)))
           ((>= var l))
           ()
           ()
           . rest))
    ((up-from ((var) (start (to limit))) next . rest)
     (next ((s start) (l limit))
           ((var s (+ var 1)))
           ((>= var l))
           ()
           ()
           . rest))
    ((up-from ((var) (start (by step))) next . rest)
     (next ((s start) (e step)) ((var s (+ var e))) () () () . rest))
    ((up-from ((var) (start)) next . rest)
     (next ((s start)) ((var s (+ var 1))) () () () . rest))
    ))

;;> \macro{(for x (down-from [start] [(to limit)] [(by step)]))}

(define-syntax down-from
  (syntax-rules (to by)
    ((down-from (() . args) next . rest)
     (down-from ((var) . args) next . rest))
    ((down-from ((var) (start (to limit) (by step))) next . rest)
     (next ((s start) (l limit) (e step))
           ((var (- s e) (- var e)))
           ((< var l))
           ()
           ()
           . rest))
    ((down-from ((var) (start (to limit))) next . rest)
     (next ((s start) (l limit))
           ((var (- s 1) (- var 1)))
           ((< var l))
           ()
           ()
           . rest))
    ((down-from ((var) (start (by step))) next . rest)
     (next ((s start) (e step)) ((var (- s e) (- var e))) () () ()
           . rest))
    ((down-from ((var) (start)) next . rest)
     (next ((s start)) ((var (- s 1) (- var 1))) () () ()
           . rest))
    ))

(define-syntax accumulating
  (syntax-rules (initial if)
    ((accumulating (kons final init) ((var) . x) next . rest)
     (accumulating (kons final init) ((var cursor) . x) next . rest))
    ((accumulating (kons final init) ((var cursor) ((initial i) . x)) n . rest)
     (accumulating (kons final i) ((var cursor) x) n . rest))
    ((accumulating (kons final init) ((var cursor) (expr (if check))) n . rest)
     (n ((tmp-kons kons))
        ((cursor '() (if check (tmp-kons expr cursor) cursor)))
        ()
        ()
        ((var (final cursor)))
        . rest))
    ((accumulating (kons final init) ((var cursor) (expr)) n . rest)
     (n ((tmp-kons kons))
        ((cursor '() (tmp-kons expr cursor)))
        ()
        ()
        ((var (final cursor)))
        . rest))))

;;> \macro{(for x [pair] (listing expr))}

(define-syntax listing
  (syntax-rules ()
    ((listing args next . rest)
     (accumulating (cons reverse '()) args next . rest))))

;;> \macro{(for x [pair] (listing-reverse expr))}

(define-syntax listing-reverse
  (syntax-rules ()
    ((listing-reverse args next . rest)
     (accumulating (cons (lambda (x) x) '()) args next . rest))))

(define (append-reverse rev tail)
  (if (null? rev) tail (append-reverse (cdr rev) (cons (car rev) tail))))

;;> \macro{(for x [pair] (appending expr))}

(define-syntax appending
  (syntax-rules ()
    ((appending args next . rest)
     (accumulating (append-reverse reverse '()) args next . rest))))

;;> \macro{(for x [pair] (appending-reverse expr))}

(define-syntax appending-reverse
  (syntax-rules ()
    ((appending-reverse args next . rest)
     (accumulating (append-reverse (lambda (x) x) '()) args next . rest))))

;;> \macro{(for x (summing expr))}

(define-syntax summing
  (syntax-rules ()
    ((summing args next . rest)
     (accumulating (+ (lambda (x) x) 0) args next . rest))))

;;> \macro{(for x (multiplying expr))}

(define-syntax multiplying
  (syntax-rules ()
    ((multiplying args next . rest)
     (accumulating (* (lambda (x) x) 1) args next . rest))))
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> \procedure{(make-address-info family socktype proto [hints])}

(define (make-address-info family socktype proto . o)
  (%make-address-info family socktype proto (if (pair? o) (car o) 0)))

;;> \procedure{(get-address-info host service [addrinfo])}

;;> Create and return a new addrinfo structure for the given host
;;> and service.  \var{host} should be a string and \var{service} a
;;> string or integer.  The optional \var{addrinfo} defaults to
;;> a TCP/IP stream setting.

(define (get-address-info host service . o)
  (%get-address-info host
                     (if (integer? service) (number->string service) service)
                     (if (and (pair? o) (car o))
                         (car o)
                         (make-address-info address-family/unspecified
                                            socket-type/stream
                                            ip-proto/ip
                                            ai/passive))))

;;> Opens a client net connection to \var{host}, a string,
;;> on port \var{service}, which can be a string such as
;;> \scheme{"http"} or an integer.  Returns a list of three
;;> values on success - the socket, an input port, and an
;;> output port - or \scheme{#f} on failure.

(define (open-net-io host service)
  (let lp ((addr (get-address-info host service)))
    (if (not addr)
        (error "couldn't find address" host service)
        (let ((sock (socket (address-info-family addr)
                            (address-info-socket-type addr)
                            (address-info-protocol addr))))
          (if (not (fileno? sock))
              (lp (address-info-next addr))
              (cond
               ((negative?
                 (connect sock
                          (address-info-address addr)
                          (address-info-address-length addr)))
                (lp (address-info-next addr)))
               (else
                (cond-expand
                 (threads (set-file-descriptor-status! sock open/non-block))
                 (else #f))
                (list sock
                      (open-input-file-descriptor sock #t)
                      (open-output-file-descriptor sock #t)))))))))

;;> Convenience wrapper around \scheme{open-net-io}, opens
;;> the connection then calls \var{proc} with two arguments,
;;> the input port and the output port connected to the
;;> service, then closes the connection.  Returns the result
;;> of \var{proc}.  Raises an error if a connection can't
;;> be made.

(define (with-net-io host service proc)
  (let ((io (open-net-io host service)))
    (if (not (pair? io))
        (error "couldn't find address" host service)
        (let ((res (proc (cadr io) (car (cddr io)))))
          (close-input-port (cadr io))
          (close-output-port (car (cddr io)))
          (close-file-descriptor (car io))
          res))))

;;> \procedure{(make-listener-socket addrinfo [max-conn])}

;;> Convenience wrapper to call socket, bind and listen to return
;;> a socket suitable for accepting connections on the given
;;> \var{addrinfo}.  \var{max-conn} is the maximum number of pending
;;> connections, and defaults to 128.  Automatically specifies
;;> \scheme{socket-opt/reuseaddr}.

(define (make-listener-socket addrinfo . o)
  (let* ((max-connections (if (pair? o) (car o) 128))
         (sock (socket (address-info-family addrinfo)
                       (address-info-socket-type addrinfo)
                       (address-info-protocol addrinfo))))
    (cond
     ((not sock)
      (error "couldn't create socket for: " addrinfo))
     ((not (set-socket-option! sock level/socket socket-opt/reuseaddr 1))
      (error "couldn't set the socket to be reusable" addrinfo))
     ((not (bind sock
                 (address-info-address addrinfo)
                 (address-info-address-length addrinfo)))
      (close-file-descriptor sock)
      (error "couldn't bind socket" sock addrinfo))
     ((not (listen sock max-connections))
      (close-file-descriptor sock)
      (error "couldn't listen on socket" sock addrinfo))
     (else
      sock))))

;;> Returns the socket option of the given \var{name} for \var{socket}.
;;> \var{socket} should be a file descriptor, level the constant
;;> \scheme{level/socket}, and name one of the constants beginning with
;;> "socket-opt/".

(define (get-socket-option socket level name)
  (let ((res (getsockopt socket level name)))
    (and (pair? res) (car res))))

;;> Sends the bytevector \var{bv} to \var{socket} with sendto and
;;> returns the number of bytes sent, or a negative value on error.
;;> If \var{addrinfo} is unspecified, \var{socket} must previously
;;> have had a default address specified with \scheme{connect}.

(define (send socket bv . o)
  (apply send/non-blocking socket bv #f o))

;;> Equivalent to \scheme{send} but gives up and returns false if the
;;> packet can't be sent within \var{timeout} seconds.

(define (send/non-blocking socket bv timeout . o)
  (let* ((flags (if (pair? o) (car o) 0))
         (addrinfo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (sockaddr (and addrinfo (address-info-address addrinfo)))
         (sockaddr-len (if addrinfo (address-info-address-length addrinfo) 0)))
    (%send socket bv flags sockaddr sockaddr-len timeout)))

;;> Recieves data from \var{socket} to fill the bytevector \var{bv} by
;;> calling recvfrom.  Returns the number of bytes read, or a negative
;;> value on error.  If \var{addrinfo} is unspecified, \var{socket}
;;> must previously have had a default address specified with
;;> \scheme{connect}.

(define (receive! socket bv . o)
  (apply receive!/non-blocking socket bv #f o))

;;> Equivalent to \scheme{receive!} but gives up and returns false if
;;> no packets are received within \var{timeout} seconds.

(define (receive!/non-blocking socket bv timeout . o)
  (let* ((flags (if (pair? o) (car o) 0))
         (addrinfo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (sockaddr (and addrinfo (address-info-address addrinfo)))
         (sockaddr-len (if addrinfo (address-info-address-length addrinfo) 0)))
    (%receive! socket bv flags sockaddr sockaddr-len timeout)))

;;> Shortcut for \scheme{receive}, returning a newly created
;;> bytevector of length \var{n} on success and \scheme{#f} on
;;> failure.

(define (receive socket n . o)
  (let* ((bv (make-bytevector n))
         (m (apply receive! socket bv o)))
    (and (>= m 0)
         (subbytes bv 0 m))))

;;> Equivalent to \scheme{receive} but gives up and returns false if
;;> no packets are received within \var{timeout} seconds.

(define (receive/non-blocking socket n timeout . o)
  (let* ((bv (make-bytevector n))
         (m (apply receive!/non-blocking socket bv timeout o)))
    (and (>= m 0)
         (subbytes bv 0 m))))

(define-library (chibi process)
  (export exit sleep alarm %fork fork kill execute waitpid system
          process-command-line  process-running?
          set-signal-action! make-signal-set
          signal-set? signal-set-contains?
          signal-set-fill! signal-set-add! signal-set-delete!
          current-signal-mask current-process-id parent-process-id
          signal-mask-block! signal-mask-unblock! signal-mask-set!
          signal/hang-up    signal/interrupt   signal/quit
          signal/illegal    signal/abort       signal/fpe
          signal/kill       signal/segv        signal/pipe
          signal/alarm      signal/term        signal/user1
          signal/user2      signal/child       signal/continue
          signal/stop       signal/tty-stop    signal/tty-input
          signal/tty-output wait/no-hang
          call-with-process-io
          process->string process->sexp
          process->string-list process->output+error)
  (import (chibi) (chibi io) (chibi string) (chibi filesystem))
  (cond-expand (threads (import (srfi 18) (srfi 33))) (else #f))
  (include-shared "process")
  (include "process.scm"))

(define-library (chibi bytevector)
  (export
   bytevector-u16-ref-le bytevector-u16-ref-be
   bytevector-u32-ref-le bytevector-u32-ref-be
   bytevector-pad-left
   integer->bytevector bytevector->integer
   integer->hex-string hex-string->integer
   bytevector->hex-string hex-string->bytevector)
  (import (scheme base) (srfi 33))
  (include "bytevector.scm"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The most basic set interface.  We provide a data type, low-level
;; constructor, and membership test.  This allows libraries to provide
;; an iset API without needing to include the full iset library.

(define-record-type Integer-Set
  (%make-iset start end bits left right)
  iset?
  (start iset-start iset-start-set!)
  (end   iset-end   iset-end-set!)
  (bits  iset-bits  iset-bits-set!)
  (left  iset-left  iset-left-set!)
  (right iset-right iset-right-set!))

(define (make-iset . opt)
  (if (null? opt)
      (%make-iset 0 0 0 #f #f)
      (let ((end (if (pair? (cdr opt)) (cadr opt) (car opt))))
        (%make-iset (car opt) end #f #f #f))))

(define (iset-contains? iset n)
  (let lp ((is iset))
    (let ((start (iset-start is)))
      (if (< n start)
          (let ((left (iset-left is))) (and left (lp left)))
          (let ((end (iset-end is)))
            (if (> n end)
                (let ((right (iset-right is))) (and right (lp right)))
                (let ((bits (iset-bits is)))
                  (or (not bits)
                      (bit-set? (- n start) bits)))))))))

(define-library (chibi iset optimize)
  (import (chibi) (srfi 9) (srfi 33)
          (chibi iset base)
          (chibi iset iterators)
          (chibi iset constructors))
  (include "optimize.scm")
  (export
   iset-balance iset-balance! iset-optimize iset-optimize! iset->code))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Cursors

(define (iset-empty? iset)
  (and (iset? iset)
       (cond ((iset-bits iset) => zero?) (else #f))
       (let ((l (iset-left iset))) (or (not l) (iset-empty? l)))
       (let ((r (iset-right iset))) (or (not r) (iset-empty? r)))))

(define-record-type Iset-Cursor
  (make-iset-cursor node pos stack)
  iset-cursor?
  (node iset-cursor-node iset-cursor-node-set!)
  (pos iset-cursor-pos iset-cursor-pos-set!)
  (stack iset-cursor-stack iset-cursor-stack-set!))

;; Create a new iset cursor pointing to the first element of iset,
;; with an optional stack argument.
(define (%iset-cursor iset . o)
  (iset-cursor-advance
   (make-iset-cursor iset
                     (or (iset-bits iset) (iset-start iset))
                     (if (pair? o) (car o) '()))))

(define (iset-cursor iset . o)
  (let ((stack (if (pair? o) (car o) '())))
    (if (iset-left iset)
        (iset-cursor (iset-left iset) (cons iset stack))
        (%iset-cursor iset stack))))

;; Continue to the next node in the search stack.
(define (iset-cursor-pop cur)
  (let ((node (iset-cursor-node cur))
        (stack (iset-cursor-stack cur)))
    (cond
     ((iset-right node)
      (iset-cursor (iset-right node) stack))
     ((pair? stack)
      (%iset-cursor (car stack) (cdr stack)))
     (else
      cur))))

;; Advance to the next node+pos that can be referenced if at the end
;; of this node's range.
(define (iset-cursor-advance cur)
  (let ((node (iset-cursor-node cur))
        (pos (iset-cursor-pos cur)))
    (cond
     ((if (iset-bits node) (zero? pos) (> pos (iset-end node)))
      (iset-cursor-pop cur))
     (else cur))))

(define (iset-cursor-next iset cur)
  (iset-cursor-advance
   (let ((node (iset-cursor-node cur))
         (pos (iset-cursor-pos cur))
         (stack (iset-cursor-stack cur)))
     (let ((pos (if (iset-bits node) (bitwise-and pos (- pos 1)) (+ pos 1))))
       (make-iset-cursor node pos stack)))))

(define (iset-ref iset cur)
  (let ((node (iset-cursor-node cur))
        (pos (iset-cursor-pos cur)))
    (cond
     ((iset-bits node)
      (if (zero? pos)
          (error "cursor reference past end of iset")
          (+ (iset-start node)
             (integer-length (- pos (bitwise-and pos (- pos 1))))
             -1)))
     (else
      (if (> pos (iset-end node))
          (error "cursor reference past end of iset")
          pos)))))

(define (end-of-iset? cur)
  (let ((node (iset-cursor-node cur)))
    (and (if (iset-bits node)
             (zero? (iset-cursor-pos cur))
             (> (iset-cursor-pos cur) (iset-end node)))
         (not (iset-right node))
         (null? (iset-cursor-stack cur)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Equality

(define (iset2= is1 is2)
  (let lp ((cur1 (iset-cursor is1))
           (cur2 (iset-cursor is2)))
    (cond ((end-of-iset? cur1) (end-of-iset? cur2))
          ((end-of-iset? cur2) #f)
          ((= (iset-ref is1 cur1) (iset-ref is2 cur2))
           (lp (iset-cursor-next is1 cur1) (iset-cursor-next is2 cur2)))
          (else
           #f))))

(define (iset2<= is1 is2)
  (let lp ((cur1 (iset-cursor is1))
           (cur2 (iset-cursor is2)))
    (cond ((end-of-iset? cur1))
          ((end-of-iset? cur2) #f)
          (else
           (let ((i1 (iset-ref is1 cur1))
                 (i2 (iset-ref is1 cur2)))
             (cond ((> i1 i2)
                    (lp cur1 (iset-cursor-next is2 cur2)))
                   ((= i1 i2)
                    (lp (iset-cursor-next is1 cur1)
                        (iset-cursor-next is2 cur2)))
                   (else
                    ;; (< i1 i2) - i1 won't occur in is2
                    #f)))))))

(define (iset= . o)
  (or (null? o)
      (let lp ((a (car o)) (ls (cdr o)))
        (or (null? ls) (and (iset2= a (car ls)) (lp (car ls) (cdr ls)))))))

(define (iset<= . o)
  (or (null? o)
      (let lp ((a (car o)) (ls (cdr o)))
        (or (null? ls) (and (iset2<= a (car ls)) (lp (car ls) (cdr ls)))))))

(define (iset>= . o)
  (apply iset<= (reverse o)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Folding

(define (iset-fold-node kons knil iset)
  (let lp ((is iset) (acc knil))
    (let* ((left (iset-left is))
           (acc (kons is (if left (lp left acc) acc)))
           (right (iset-right is)))
      (if right (lp right acc) acc))))

(define (iset-fold kons knil iset)
  (iset-fold-node
   (lambda (is acc)
     (let ((start (iset-start is))
           (end (iset-end is))
           (bits (iset-bits is)))
       (if bits
           (let ((limit (+ 1 (- end start))))
             (do ((n1 bits n2)
                  (n2 (bitwise-and bits (- bits 1)) (bitwise-and n2 (- n2 1)))
                  (acc acc (kons (+ start (integer-length (- n1 n2)) -1) acc)))
                 ((zero? n1) acc)))
           (do ((i start (+ i 1))
                (acc acc (kons i acc)))
               ((> i end) acc)))))
   knil
   iset))

(define (iset-for-each-node proc iset)
  (iset-fold-node (lambda (node acc) (proc node)) #f iset))

(define (iset-for-each proc iset)
  (iset-fold (lambda (i acc) (proc i)) #f iset))

(define (iset->list iset)
  (reverse (iset-fold cons '() iset)))

(define (iset-size iset)
  (iset-fold-node
   (lambda (is acc)
     (let ((bits (iset-bits is)))
       (+ acc (if bits
                  (bit-count bits)
                  (+ 1 (- (iset-end is) (iset-start is)))))))
   0
   iset))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for constructing and joining isets.

(define bits-thresh 128)  ; within 128 we join into a bitmap
;;(define bits-max 512)     ; don't make bitmaps larger than this

(define (bit-set n index)
  (bitwise-ior n (arithmetic-shift 1 index)))

(define (bit-clear n index)
  (if (bit-set? index n)
      (- n (arithmetic-shift 1 index))
      n))

(define (iset . args)
  (list->iset args))

(define (list->iset! ls iset)
  (for-each (lambda (i) (iset-adjoin1! iset i)) ls)
  iset)

(define (list->iset ls . opt)
  (list->iset! ls (if (pair? opt) (iset-copy (car opt)) (make-iset))))

(define (iset-copy iset)
  (and iset
       (%make-iset
        (iset-start iset)
        (iset-end iset)
        (iset-bits iset)
        (iset-copy (iset-left iset))
        (iset-copy (iset-right iset)))))

(define (iset-copy-node iset)
  (%make-iset (iset-start iset) (iset-end iset) (iset-bits iset) #f #f))

(define (iset-max-end iset)
  (cond ((iset-right iset) => iset-max-end)
        (else (iset-end iset))))

(define (iset-min-start iset)
  (cond ((iset-left iset) => iset-min-start)
        (else (iset-start iset))))

(define (iset-insert-left! iset new)
  (let ((left (iset-left iset)))
    (if (and left (< (iset-end new) (iset-start left)))
        (iset-right-set! new left)
        (iset-left-set! new left)))
  (iset-left-set! iset new))

(define (iset-insert-right! iset new)
  (let ((right (iset-right iset)))
    (if (and right (< (iset-end new) (iset-start right)))
        (iset-right-set! new right)
        (iset-left-set! new right)))
  (iset-right-set! iset new))

(define (range->bits start end)
  (- (arithmetic-shift 1 (+ 1 (- end start))) 1))

(define (iset-squash-bits! iset)
  (let ((bits (iset-bits iset)))
    (if (and bits (= bits (range->bits (iset-start iset) (iset-end iset))))
        (iset-bits-set! iset #f))))

(define (iset-should-merge-left? a b)
  (and (< (- (iset-start a) (iset-end b))
          bits-thresh)
       (or (not (iset-left a))
           (> (iset-start b) (iset-max-end (iset-left a))))))

(define (iset-should-merge-right? a b)
  (and (< (- (iset-start b) (iset-end a))
          bits-thresh)
       (or (not (iset-right a))
           (< (iset-end b) (iset-min-start (iset-right a))))))

(define (iset-merge-left! a b)
  (if (or (iset-bits a) (iset-bits b)
          (< (+ 1 (iset-end b)) (iset-start a)))
      (let* ((a-bits (or (iset-bits a)
                         (range->bits (iset-start a) (iset-end a))))
             (b-bits (or (iset-bits b)
                         (range->bits (iset-start b) (iset-end b))))
             (shift (- (iset-start a) (iset-start b)))
             (bits (bitwise-ior b-bits (arithmetic-shift a-bits shift))))
        (iset-bits-set! a bits)))
  (iset-start-set! a (iset-start b)))

(define (iset-merge-right! a b)
  (if (or (iset-bits a) (iset-bits b)
          (< (+ 1 (iset-end a)) (iset-start b)))
      (let* ((a-bits (or (iset-bits a)
                         (range->bits (iset-start a) (iset-end a))))
             (b-bits (or (iset-bits b)
                         (range->bits (iset-start b) (iset-end b))))
             (shift (- (iset-start b) (iset-start a)))
             (bits (bitwise-ior a-bits (arithmetic-shift b-bits shift))))
        (iset-bits-set! a bits)))
  (iset-end-set! a (iset-end b)))

(define (iset-adjoin1! is n)
  (iset-adjoin-node! is (%make-iset n n #f #f #f)))

;; adjoin just the node b (ignoring left/right) to the full iset a
(define (iset-adjoin-node! a b)
  (cond
   ((iset-empty? a)
    (iset-start-set! a (iset-start b))
    (iset-end-set! a (iset-end b))
    (iset-bits-set! a (iset-bits b)))
   ((not (iset-empty? b))
    (let ((a-start (iset-start a))
          (a-end (iset-end a))
          (a-bits (iset-bits a))
          (b-start (iset-start b))
          (b-end (iset-end b))
          (b-bits (iset-bits b)))
      (cond
       ;;         aaaa...
       ;; ...bbbb
       ((<= b-end a-start)
        (if (iset-should-merge-left? a b)
            (iset-merge-left! a b)
            (iset-adjoin-node-left! a b)))
       ;; ...aaaa
       ;;         bbbb...
       ((>= b-start a-end)
        (if (iset-should-merge-right? a b)
            (iset-merge-right! a b)
            (iset-adjoin-node-right! a b)))
       ;; ...aaaaa...
       ;;  ...bb...
       ((and (>= b-start a-start) (<= b-end a-end))
        (if a-bits
            (let ((b-bits (arithmetic-shift
                           (or b-bits (range->bits b-start b-end))
                           (- b-start a-start))))
              (iset-bits-set! a (bitwise-ior a-bits b-bits))
              (iset-squash-bits! a))))
       (else
        ;; general case: split, recurse, join sides
        (let ((ls (iset-node-split b a-start a-end)))
          (if (car ls)
              (iset-adjoin-node-left! a (car ls)))
          (iset-adjoin-node! a (cadr ls))
          (if (car (cddr ls))
              (iset-adjoin-node-right! a (car (cddr ls)))))))))))

(define (iset-adjoin-node-left! iset node)
  (if (iset-left iset)
      (iset-adjoin-node! (iset-left iset) node)
      (iset-left-set! iset node)))

(define (iset-adjoin-node-right! iset node)
  (if (iset-right iset)
      (iset-adjoin-node! (iset-right iset) node)
      (iset-right-set! iset node)))

;; start and/or end are inside the node, split into:
;;   1. node before start, if any
;;   2. node between start and end
;;   3. node after end, if any
(define (iset-node-split node start end)
  (list (and (< (iset-start node) start)
             (iset-node-extract node (iset-start node) (- start 1)))
        (iset-node-extract node start end)
        (and (> (iset-end node) end)
             (iset-node-extract node (+ end 1) (iset-end node)))))

(define (iset-node-extract node start end)
  (cond
   ((iset-bits node)
    => (lambda (node-bits)
         (let* ((bits
                 (bitwise-and
                  (arithmetic-shift node-bits (- (iset-start node) start))
                  (range->bits start end)))
                (new-end (min end (+ start (integer-length bits)))))
           (%make-iset start new-end bits #f #f))))
   (else
    (%make-iset (max start (iset-start node))
                (min end (iset-end node))
                #f #f #f))))

(define (iset-adjoin! iset . ls)
  (list->iset! ls iset))

(define (iset-adjoin iset . ls)
  (list->iset ls iset))

;; delete directly in this node
(define (%iset-delete1! iset n)
  (let ((start (iset-start iset))
        (end (iset-end iset))
        (bits (iset-bits iset)))
    (cond
     (bits
      (iset-bits-set! iset (bit-clear bits (- n start))))
     ((= n start)
      (if (= n end)
          (iset-bits-set! iset 0)
          (iset-start-set! iset (+ n 1))))
     ((= n end)
      (iset-end-set! iset (- n 1)))
     (else
      (iset-end-set! iset (- n 1))
      (iset-insert-right! iset (make-iset (+ n 1) end))))))

(define (iset-delete1! iset n)
  (let lp ((is iset))
    (let ((start (iset-start is)))
      (if (< n start)
          (let ((left (iset-left is)))
            (if left (lp left)))
          (let ((end (iset-end is)))
            (if (> n end)
                (let ((right (iset-right is)))
                  (if right (lp right)))
                (%iset-delete1! is n)))))))

(define (iset-delete! iset . args)
  (for-each (lambda (i) (iset-delete1! iset i)) args)
  iset)

(define (iset-delete iset . args)
  (apply iset-delete! (iset-copy iset) args))

(define (iset-map proc iset)
  (iset-fold (lambda (i is) (iset-adjoin! is (proc i))) (make-iset) iset))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; High-level set operations.
;;
;; Union is optimized to work at the node level.  Intersection and
;; difference iterate over individual elements and so have a lot of
;; room for improvement, at the expense of the complexity of
;; iset-adjoin-node!.

(define (iset-union2! a b)
  (iset-for-each-node
   (lambda (is)
     (iset-adjoin-node! a is))
   b))

(define (iset-union! . args)
  (let* ((a (and (pair? args) (car args)))
         (b (and (pair? args) (pair? (cdr args)) (cadr args))))
    (cond
     (b
      (iset-union2! a b)
      (apply iset-union! a (cddr args)))
     (a a)
     (else (make-iset)))))

(define (iset-union . args)
  (if (null? args)
    (make-iset)
    (apply iset-union! (iset-copy (car args)) (cdr args))))

(define (iset-intersection! a . args)
  (let ((b (and (pair? args) (car args))))
    (cond
     (b
      (iset-for-each
       (lambda (i) (if (not (iset-contains? b i)) (iset-delete1! a i)))
       a)
      (apply iset-intersection! a (cdr args)))
     (else a))))

(define (iset-intersection a . args)
  (apply iset-intersection! (iset-copy a) args))

(define (iset-difference! a . args)
  (if (null? args)
      a
      (begin
        (iset-for-each (lambda (i) (iset-delete1! a i)) (car args))
        (apply iset-difference! a (cdr args)))))

(define (iset-difference a . args)
  (apply iset-difference! (iset-copy a) args))

(define-library (chibi iset iterators)
  (import (chibi) (srfi 9) (srfi 33) (chibi iset base))
  (include "iterators.scm")
  (export
   iset-empty? iset-fold iset-fold-node iset-for-each iset-for-each-node
   iset->list iset-size iset= iset<= iset>=
   ;; low-level cursors
   iset-cursor iset-cursor? iset-cursor-next iset-ref end-of-iset?))

(define-library (chibi iset base)
  (import (chibi) (srfi 9) (srfi 33))
  (include "base.scm")
  (export
   %make-iset make-iset iset? iset-contains? Integer-Set
   iset-start iset-end iset-bits iset-left iset-right
   iset-start-set! iset-end-set! iset-bits-set! iset-left-set! iset-right-set!))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Optimizing Iset Representation

(define (iset-balance iset)
  (and iset
       (let ((nodes '()))
         (iset-for-each-node
          (lambda (is) (set! nodes (cons (iset-copy-node is) nodes)))
          iset)
         (let reduce ((nodes (reverse nodes)))
           (let ((len (length nodes)))
             (case len
               ((0) #f)
               ((1) (car nodes))
               (else
                (let ((mid (quotient len 2)))
                  (let lp ((i 0) (ls nodes) (left '()))
                    (if (= i mid)
                        (let ((res (car ls)))
                          (iset-left-set! res (reduce (reverse left)))
                          (iset-right-set! res (reduce (cdr ls)))
                          res)
                        (lp (+ i 1) (cdr ls) (cons (car ls) left))))))))))))

(define (iset-balance! iset)
  (iset-balance iset))

;; remove leading 0's in bits before squashing
(define (iset-trim-and-squash-bits! is)
  (if (iset-bits is)
      (let ((end (iset-end is)))
        (let lp ((bits (iset-bits is))
                 (start (iset-start is)))
          (cond
           ((zero? bits)
            (iset-start-set! is start)
            (iset-bits-set! is 0))
           ((>= start end)
            (iset-start-set! is start)
            (iset-bits-set! is #f)
            (if (even? (arithmetic-shift bits -1))
                (iset-end-set! is start)))
           ((even? bits)
            (lp (arithmetic-shift bits -1) (+ start 1)))
           (else
            (iset-start-set! is start)
            (iset-bits-set! is bits))))))
  (iset-squash-bits! is)
  is)

;; overwrite a node in place
(define (iset-set-node! a b)
  (iset-start-set! a (iset-start b))
  (iset-end-set! a (iset-end b))
  (iset-bits-set! a (iset-bits b)))

;; safe to insert left since we've already visited all left nodes
(define (iset-node-replace! is nodes)
  (cond
   ((pair? nodes)
    (iset-set-node! is (car nodes))
    (let loop ((is is) (ls (cdr nodes)))
      (cond
       ((pair? ls)
        (iset-insert-left! is (car ls))
        (loop (iset-left is) (cdr ls))))))))

;; compact a list of consecutive bit ranges for an iset
(define (iset-node-split-ranges! is ranges)
  (let ((start (iset-start is))
        (end (iset-end is))
        (bits (iset-bits is)))
    (let lp ((ls (reverse ranges)) (nodes '()) (last 0))
      (if (pair? ls)
          (let ((lo (caar ls)) (hi (cdar ls)))
            (lp (cdr ls)
                (cons (make-iset (+ start lo) (+ start hi -1))
                      (if (< last lo) ;; trailing bit range
                          (cons (iset-trim-and-squash-bits!
                                 (%make-iset
                                  (+ start last)
                                  (+ start lo -1)
                                  (extract-bit-field (- lo last) last bits)
                                  #f
                                  #f))
                                nodes)
                          nodes))
                hi))
          (let ((nodes
                 (if (< (+ start last) end) ;; trailing bit range
                     (cons (iset-trim-and-squash-bits!
                            (%make-iset (+ start last)
                                        end
                                        (arithmetic-shift bits (- last))
                                        #f
                                        #f))
                           nodes)
                     nodes)))
            (iset-node-replace! is nodes))))))

;; Compact bit ranges of long consecutive chars in a single node into
;; ranges.  Loop over the bits, and convert any consecutive bit
;; patterns longer than span into new start/end nodes.
(define (iset-optimize-node! is span)
  (iset-squash-bits! is)
  (let* ((bits (iset-bits is))
         (len (and bits (integer-length bits))))
    (cond
     (bits
      (letrec
          ((full  ;; in a full bit range from [since..i)
            (lambda (i since ranges)
              (cond
               ((or (>= i len) (not (bit-set? i bits)))
                ;; if the current span is long enough, push to ranges
                (if (>= (- i since) span)
                    (sparse (+ i 1) (cons (cons since i) ranges))
                    (sparse (+ i 1) ranges)))
               (else
                (full (+ i 1) since ranges)))))
           (sparse  ;; [i-1] is not set
            (lambda (i ranges)
              (cond
               ((>= i len)
                ;; done - if there are any ranges to compact, do so
                (if (pair? ranges)
                    (iset-node-split-ranges! is ranges)))
               ((bit-set? i bits)
                (full (+ i 1) i ranges))
               (else
                (sparse (+ i 1) ranges))))))
        (sparse 0 '()))))))

;; Remove empty nodes.
(define (%iset-prune! is)
  (cond
   ((not is)
    #f)
   (else
    (iset-left-set! is (%iset-prune! (iset-left is)))
    (iset-right-set! is (%iset-prune! (iset-right is)))
    (if (and (eq? 0 (iset-bits is))
             (not (iset-left is))
             (not (iset-right is)))
        #f
        is))))

(define (iset-prune! is)
  (or (%iset-prune! is) (iset)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (iset-optimize! is . opt)
  (let ((span (if (pair? opt) (car opt) (* 40 8)))
        (is (iset-prune! is)))
    (iset-for-each-node (lambda (node) (iset-optimize-node! node span)) is)
    (iset-prune! is)))

(define (iset-optimize iset . opt)
  (apply iset-optimize! (iset-copy iset) opt))

;; write an efficient expression which evaluates to the iset
(define (iset->code iset)
  (and iset
       `(%make-iset ,(iset-start iset)
                    ,(iset-end iset)
                    ,(iset-bits iset)
                    ,(iset->code (iset-left iset))
                    ,(iset->code (iset-right iset)))))

(define-library (chibi iset constructors)
  (import (chibi) (srfi 33) (chibi iset base) (chibi iset iterators))
  (include "constructors.scm")
  (export
   iset iset-copy list->iset list->iset! iset-map
   iset-adjoin iset-adjoin! iset-delete iset-delete!
   iset-union iset-union! iset-intersection iset-intersection!
   iset-difference iset-difference!
   ;; low-level
   iset-copy-node iset-squash-bits! iset-insert-left! iset-insert-right!))
;; highlight.scm -- source code highlighting library
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for highlighting source code in different
;;> languages.  Currently supports Scheme, C and Assembly.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (string-concatenate-reverse ls)
  (string-concatenate (reverse ls)))

(define (reverse-list->string ls)
  (list->string (reverse ls)))

;;> Returns an sxml structure representing the code from source
;;> with various language constructs wrapped in highlighting
;;> forms.  \var{source} should be a string or port.  The
;;> language to highlight for is auto-detected.

(define (highlight source)
  (let ((str (if (string? source) source (port->string source))))
    ((highlighter-for (highlight-detect-language str)) str)))

;;> Attempst to auto-detect which language \var{str} is code
;;> for, and returns a symbol representing that language.

(define (highlight-detect-language str)
  (cond
   ((protect (exn (else #f))
      (call-with-input-string str
        (lambda (in) (do ((x #f (read in))) ((eof-object? x)))))
      #t)
    'scheme)
   (else
    'c)))

;;> Return a procedure for highlighting the given language.

(define (highlighter-for language)
  (case language
    ((scheme) highlight-scheme)
    ((asm) highlight-assembly)
    ((none) (lambda (x) x))
    (else highlight-c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define highlight-themes
  '((light
     (keyword      . "#800080")
     (type         . "#008000")
     (function     . "#0000FF")
     (variable     . "#B8860B")
     (comment      . "#FF0000")
     (string       . "#BC8F8F")
     (attribute    . "#FF5000")
     (preprocessor . "#FF00FF")
     (builtin      . "#FF00FF")
     (character    . "#0055AA")
     (syntaxerror  . "#FF0000")
     (diff-deleted . "#5F2121")
     (diff-added   . "#215F21")
     )))

(define highlight-paren-styles
  ;;'("#BAFFFF" "#FFCACA" "#FFFFBA" "#CACAFF" "#CAFFCA" "FFBAFF")
  '("#AAAAAA" "#888888" "#666666" "#444444" "#222222" "#000000"))

;;> Returns a string representing the CSS needed for the output
;;> of \var{highlight}.  This should be included in a referenced
;;> CSS file, or in a \var{<script>} section in the generated in
;;> the generated HTML output.

(define (highlight-style . theme)
  (string-concatenate
   (append
    (map
     (lambda (x)
       (if (and (list? x) (= 3 (length x)))
           (string-append
            "." (symbol->string (car x)) " { color: " (cadr x)
            "; background-color: " (car (cddr x)) "; }\n")
           (string-append
            "." (symbol->string (car x)) " { color: "
            (if (pair? (cdr x)) (cadr x) (cdr x))
            "; background-color: inherit; }\n")))
     (cond ((assq (and (pair? theme) (car theme)) highlight-themes) => cdr)
           (else (cdar highlight-themes))))
    (map
     (lambda (s i)
       (string-append
        ;;"span.paren" (number->string i)
        ;;":hover { color: inherit; background-color: " s "; }\n"
        "span.paren" (number->string i)
        " { color: " s "; background-color: inherit; }\n"))
     highlight-paren-styles
     (cdr (iota (+ 1 (length highlight-paren-styles))))))))

(define (highlight-class class x)
  `(span (@ (class . ,class)) ,@(if (list? x) x (list x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (read-whitespace in)
  (let lp ((res '()))
    (if (char-whitespace? (peek-char in))
        (lp (cons (read-char in) res))
        (reverse-list->string res))))

(define (read-to-whitespace in res)
  (let ((c (peek-char in)))
    (cond
     ((or (eof-object? c) (char-whitespace? c))
      (reverse-list->string res))
     (else
      (read-to-whitespace in (cons (read-char in) res))))))

(define (read-escaped in term ls)
  (let ((c (read-char in)))
    (cond
     ((eof-object? c) (reverse-list->string ls))
     ((eqv? c term) (reverse-list->string (cons c ls)))
     ((eqv? c #\<) (read-escaped in term `(#\; #\t #\l #\& ,@ls)))
     ;;((eqv? c #\>) (read-escaped in term `(#\; #\t #\g #\& ,@ls)))
     ((eqv? c #\&) (read-escaped in term `(#\; #\p #\m #\a #\& ,@ls)))
     ;;((eqv? c #\\) (read-escaped in term (cons (read-char in) (cons c ls))))
     (else (read-escaped in term (cons c ls))))))

(define (read-to-eol in ls)
  (let ((c (read-char in)))
    (cond
     ((eof-object? c) (reverse-list->string ls))
     ((eqv? c #\newline) (reverse-list->string (cons c ls)))
     (else (read-to-eol in (cons c ls))))))

(define (html-escape str)
  (call-with-input-string str (lambda (in) (read-escaped in #f '()))))

(define (collect str res)
  (if (pair? str) (cons (reverse-list->string str) res) res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (highlight-scheme-delimiter? ch)
  (or (eof-object? ch)
      (char-whitespace? ch)
      (memq ch '(#\; #\# #\( #\) #\[ #\] #\{ #\} #\' #\` #\, #\"))))

(define (highlight-scheme-definition? id)
  (memq id '(define define-syntax define-module define-class
             define-record define-record-type)))

(define (highlight-scheme-syntax? id)
  (memq id '(if lambda define set! cond case let let* letrec letrec*
             let-values let-values* let-optionals let-optionals*
             let-keywords let-keywords* and-let* rec receive do
             loop rxmatch-cond rxmatch-case begin when unless
             match match-lambda match-let match-let* dotimes dolist
             quote quasiquote unquote unquote-splicing error errorf
             define-syntax let-syntax letrec-syntax syntax-rules
             syntax-case parameterize module library require
             require-extension use use-modules import import-immutable
             define-module select-module provide autoload export
             only except rename prefix include include-shared
             condition-case guard protect cond-expand for with to by
             in-list in-lists in-string in-string-reverse
             in-vector in-vector-reverse in-file listing appending
             summing multpliying up-from down-from else
             )))

;;> Highlighter for Scheme source code.

(define (highlight-scheme source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (read-identifier ls)
      (let ((c (peek-char in)))
        (cond
         ((highlight-scheme-delimiter? c)
          (reverse-list->string ls))
         (else
          (read-char in)
          (read-identifier (cons c ls))))))
    (define (hash-mark)
      (let ((c (read-char in)))
        (case c
          ((#\;)
           (highlight-class "comment" (highlight 0 '(#\; #\#) '())))
          ((#\\)
           (highlight-class "string"
                            (read-identifier (list (read-char in) #\\ #\#))))
          (else
           (string-append "#" (if (char? c) (string c) ""))))))
    (define (highlight n str res)
      (let ((c (read-char in)))
        (if (eof-object? c)
            (reverse (collect str res))
            (case c
              ((#\;)
               (let lp ((ls '()))
                 (let ((ls (cons (read-to-eol in (list #\;)) ls)))
                   (cond
                    ((eqv? #\; (peek-char in))
                     (lp ls))
                    (else
                     (highlight n
                                '()
                                (cons (highlight-class
                                       "comment"
                                       (string-concatenate-reverse ls))
                                      (collect str res))))))))
              ((#\")
               (let ((s (read-escaped in #\" (list #\"))))
                 (highlight n
                            '()
                            (cons (highlight-class "string" s)
                                  (collect str res)))))
              ((#\()
               ;;(highlight-start
               ;; (string->symbol
               ;;  (string-append
               ;;   "paren"
               ;;   (number->string
               ;;    (+ 1 (modulo n (length highlight-paren-styles))))))
               ;;out)
               (let ((res (collect (cons #\( str) res)))
                 (if (highlight-scheme-delimiter? (peek-char in))
                     (highlight (+ n 1) '() res)
                     (let* ((id (read-identifier '()))
                            (sym (string->symbol id)))
                       (cond
                        ((highlight-scheme-definition? sym)
                         (let* ((res (cons (highlight-class "keyword" id) res))
                                (res (cons (read-whitespace in) res))
                                (res (if (eqv? #\( (peek-char in))
                                         (cons (string (read-char in)) res)
                                         res)))
                           (highlight
                            (+ n 1)
                            '()
                            (cons
                             (highlight-class "function" (read-identifier '()))
                             res))))
                        ((highlight-scheme-syntax? sym)
                         (highlight (+ n 1)
                                    '()
                                    (cons (highlight-class "keyword" id) res)))
                        (else
                         (highlight (+ n 1) '() (cons id res))))))))
              ((#\))
               (cond
                ((zero? n)
                 (highlight n
                            '()
                            (cons (highlight-class "syntaxerror" ")")
                                  (collect str res))))
                (else
                 ;;(highlight-end 'paren
                 (highlight (- n 1) (cons c str) res))))
              ((#\#)
               (highlight n '() (cons (hash-mark) (collect str res))))
              (else
               (cond
                ((highlight-scheme-delimiter? c)
                 (highlight n (cons c str) res))
                (else
                 (let ((id (read-identifier (list c))))
                   (highlight n '() (cons `(span ,id) (collect str res)))))))))))
    (highlight 0 '() '())))

(define (highlight-c-keyword? id)
  (memq id '(asm break case catch const_cast continue default delete
             do dynamic_cast else explicit export false for friend goto
             if mutable namespace new operator private protected public
             register reinterpret_cast return sizeof static_cast switch
             template this throw true try typedef typeid typename using
             virtual while)))

(define (highlight-c-type? id)
  (memq id '(auto bool char class const double enum extern float inline int long
             short signed static struct union unsigned void volatile wchar_t
             sexp sexp_uint_t sexp_sint_t)))

;;> Highlighter for C source code.

(define (highlight-c source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (char-c-initial? c)
      (and (char? c) (or (char-alphabetic? c) (eqv? c #\_) (eqv? c #\$))))
    (define (char-c-identifier? c)
      (and (char? c) (or (char-c-initial? c) (char-numeric? c))))
    (define (read-identifier in ls)
      (let ((c (peek-char in)))
        (if (char-c-identifier? c)
            (read-identifier in (cons (read-char in) ls))
            (reverse-list->string ls))))
    (define (highlight-identifier id)
      (let ((sym (string->symbol id)))
        (cond
         ((highlight-c-keyword? sym)
          (highlight-class "keyword" id))
         ((highlight-c-type? sym)
          (highlight-class "type" id))
         (else
          id))))
    (define (highlight-line res)
      (highlight
       '()
       (cond
        ((eqv? #\# (peek-char in))
         (read-char in)
         (let* ((res (cons (read-whitespace in) (cons "#" res)))
                (id (read-identifier in '()))
                (res (cons (read-whitespace in)
                           (cons (highlight-class "preprocessor" id) res))))
           (case (string->symbol id)
            ((define)
             (cons (highlight-class "function" (read-to-whitespace in '())) res))
            ((include import)
             (cons (highlight-class "string" (read-to-whitespace in '())) res))
            (else
             res))))
        ((char-c-initial? (peek-char in))
         ;; line beginning w/ an identifier is probably a
         ;; function declaration
         (let ((id1 (read-identifier in '())))
           (cond
            ((eqv? #\: (peek-char in))
             (cons (highlight-class "function" id1) res))
            (else
             (let lp ((decls '())
                      (id id1))
               (let ((space (read-whitespace in)))
                 (cond
                  ((char-c-initial? (peek-char in))
                   (lp (cons space (cons id decls))
                       (read-identifier in '())))
                  ((eqv? #\( (peek-char in))
                   `(,space
                     ,(highlight-class "function" id)
                     ,(highlight-class "type" (reverse decls))
                     ,@res))
                  (else
                   `(,space ,id ,@decls ,@res)))))))))
        (else
         res))))
    (define (highlight str res)
      (let ((c (read-char in)))
        (if (eof-object? c)
            (reverse (collect str res))
            (case c
              ((#\/)
               (case (peek-char in)
                 ((#\/)
                  (highlight
                   '()
                   (cons (highlight-class "comment" (read-to-eol in '(#\/ #\/)))
                         (collect str res))))
                 ((#\*)
                  (let lp ((ls (cons (read-char in) '(#\/))))
                    (let ((c (read-char in)))
                      (if (not (and (eqv? (car ls) #\*) (eqv? c #\/)))
                          (lp (cons c ls))
                          (highlight
                           '()
                           (cons (highlight-class "comment"
                                                  (reverse-list->string ls))
                                 (collect str res)))))))
                 (else
                  (highlight (cons c str) res))))
              ((#\" #\')
               (let ((res (collect str res))
                     (s (read-escaped in c (list c))))
                 (highlight '() (cons (highlight-class "string" s) res))))
              ((#\newline)
               (highlight-line (collect (cons #\newline str) res)))
              (else
               (cond
                ((char-c-initial? c)
                 (highlight
                  '()
                  (cons
                   (let ((id (read-identifier in (list c))))
                     (if (eqv? #\: (peek-char in))
                         (highlight-class "function" id)
                         (highlight-identifier id)))
                   (collect str res))))
                (else
                 (highlight (cons c str) res))))))))
    (highlight-line '())))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Highlighter for Assembly source code.

(define (highlight-assembly source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (char-asm-initial? c)
      (and (char? c) (or (char-alphabetic? c) (memv c '(#\_ #\$ #\.)))))
    (define (char-asm-identifier? c)
      (and (char? c) (or (char-asm-initial? c) (char-numeric? c))))
    (define (read-identifier in ls)
      (let ((c (peek-char in)))
        (if (char-asm-identifier? c)
            (read-identifier (cons (read-char in) ls))
            (reverse-list->string ls))))
    (define (highlight str res)
      (let ((c (read-char in)))
        (cond
         ((eof-object? c)
          (reverse (collect str res)))
         (else
          (case c
            ((#\newline)
             (highlight-line (collect str res)))
            ((#\")
             (let ((s (read-escaped in c (list c))))
               (highlight
                '()
                (cons (highlight-class "string" s) (collect str res)))))
            ((#\%)
             (highlight
              '()
              (cons (highlight-class "variable" (read-identifier in (list c)))
                    (collect str res))))
            ((#\;)
             (highlight
              '()
              (cons (highlight-class "comment" (read-to-eol in (list c)))
                    (collect str res))))
            (else
             (highlight (cons c str) res)))))))
    (define (highlight-line res) 
      (cond
       ((eof-object? (peek-char in))
        (highlight '() res))
       ((char-asm-initial? (peek-char in))
        (let ((id (read-identifier in '())))
          (highlight
           '()
           (cons
            (if (eqv? #\: (peek-char in))
                (highlight-class "function" id)
                (highlight-class "keyword" id))
            res))))
       ((eqv? #\tab (peek-char in))
        (highlight
         '()
         (cons (highlight-class "keyword" (read-identifier in '()))
               (cons "\t" res))))
       (else
        (highlight '() res))))
    (highlight-line '())))
;; Copyright (c) 2010-2014 Alex Shinn. All rights reserved. 
;; BSD-style license: http://synthcode.com/license.txt

;;> Simple testing framework adapted from the Chicken \scheme{test}
;;> module.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; list utilities

;; Simplified version of SRFI-1 every.
(define (every pred ls)
  (or (null? ls)
      (if (null? (cdr ls))
          (pred (car ls))
          (if (pred (car ls)) (every pred (cdr ls)) #f))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; exception utilities

(define (warning msg . args)
  (display msg (current-error-port))
  (for-each (lambda (x)
              (write-char #\space (current-error-port))
              (write x (current-error-port)))
            args)
  (newline (current-error-port)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utilities

(define (string-search pat str)
  (let* ((pat-len (string-length pat))
         (limit (- (string-length str) pat-len)))
    (let lp1 ((i 0))
      (cond
       ((>= i limit) #f)
       (else
        (let lp2 ((j i) (k 0))
          (cond ((>= k pat-len) #t)
                ((not (eqv? (string-ref str j) (string-ref pat k)))
                 (lp1 (+ i 1)))
                (else (lp2 (+ j 1) (+ k 1))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test interface

;;> \macro{(test [name] expect expr)}

;;> Evaluate \var{expr} and check that it is \scheme{equal?}
;;> to \var{expect}.  \var{name} is used in reporting, and
;;> defaults to a printed summary of \var{expr}.

(define-syntax test
  (syntax-rules (quote)
    ((test expect expr)
     (test #f expect expr))
    ((test name expect (expr ...))
     (test-propagate-info name expect (expr ...) ()))
    ((test name 'expect expr)
     (test-propagate-info name 'expect expr ()))
    ((test name (expect ...) expr)
     (test-syntax-error
      'test
      "the test expression should come last: (test <expected> (<expr> ...)) "
      (test name (expect ...) expr)))
    ((test name expect expr)
     (test-propagate-info name expect expr ()))
    ((test a ...)
     (test-syntax-error 'test "test requires 2 or 3 arguments" (test a ...)))))

;;> \macro{(test-equal equal [name] expect expr)}

;;> Equivalent to test, using \var{equal} for comparison instead of
;;> \scheme{equal?}.

(define-syntax test-equal
  (syntax-rules ()
    ((test-equal equal . args)
     (parameterize ((current-test-comparator equal))
       (test . args)))))

;;> \macro{(test-assert [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it's true.

(define-syntax test-assert
  (syntax-rules ()
    ((_ expr)
     (test-assert #f expr))
    ((_ name expr)
     (test-propagate-info name #f expr ((assertion . #t))))
    ((test a ...)
     (test-syntax-error 'test-assert "1 or 2 arguments required"
                        (test a ...)))))

;;> \macro{(test-not [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it's false.

(define-syntax test-not
  (syntax-rules ()
    ((_ expr) (test-assert (not expr)))
    ((_ name expr) (test-assert name (not expr)))))

;;> \macro{(test-values [name] expect expr)}

;;> Like \scheme{test} but \var{expect} and \var{expr} can both
;;> return multiple values.

(define-syntax test-values
  (syntax-rules ()
    ((_ expect expr)
     (test-values #f expect expr))
    ((_ name expect expr)
     (test name (call-with-values (lambda () expect) (lambda results results))
       (call-with-values (lambda () expr) (lambda results results))))))

;;> \macro{(test-error [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it
;;> raises an error.

(define-syntax test-error
  (syntax-rules ()
    ((_ expr)
     (test-error #f expr))
    ((_ name expr)
     (test-propagate-info name #f expr ((expect-error . #t))))
    ((test a ...)
     (test-syntax-error 'test-error "1 or 2 arguments required"
                        (test a ...)))))

;; TODO: Extract interesting variables so we can show their values on
;; failure.
(define-syntax test-propagate-info
  (syntax-rules ()
    ((test-propagate-info name expect expr info)
     (test-vars () name expect expr info))))

(define-syntax test-vars
  (syntax-rules ()
    ((_ (vars ...) n expect expr ((key . val) ...))
     (test-run (lambda () expect)
               (lambda () expr)
               `((name . ,n)
                 (source . expr)
                 (var-names . (vars ...))
                 (var-values . ,(list vars ...))
                 (key . val) ...)))))

;;> \macro{(test-exit)}

;;> Exits with a failure status if any tests have failed,
;;> and a successful status otherwise.

(define (test-exit)
  (exit (zero? (test-failure-count))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; group interface

;;> Wraps \var{body} as a single test group, which can be filtered
;;> and summarized separately.

(define-syntax test-group
  (syntax-rules ()
    ((_ name-expr body ...)
     (let ((name name-expr)
           (old-group (current-test-group)))
       (if (not (string? name))
           (error "a name is required, got " 'name-expr name))
       (test-begin name)
       (guard
           (exn
            (else
             (warning "error in group outside of tests")
             (print-exception exn (current-error-port))
             (test-group-inc! (current-test-group) 'count)
             (test-group-inc! (current-test-group) 'ERROR)))
         body ...)
       (test-end name)
       (current-test-group old-group)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define-syntax test-syntax-error
  (syntax-rules ()
    ((_) (syntax-error "invalid use of test-syntax-error"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test-group representation

;; (name (prop value) ...)
(define (make-test-group name . o)
  (let ((parent (and (pair? o) (car o)))
        (group (list name (cons 'start-time (current-second)))))
    (test-group-set! group 'parent parent)
    (test-group-set! group 'verbose
                     (if parent
                         (test-group-ref parent 'verbose)
                         (current-test-verbosity)))
    (test-group-set! group 'level
                     (if parent
                         (+ 1 (test-group-ref parent 'level 0))
                         0))
    (test-group-set!
     group
     'skip-group?
     (or (and parent (test-group-ref parent 'skip-group?))
         (not (every (lambda (f) (f group)) (current-test-group-filters)))))
    group))

(define test-group-name car)

(define (test-group-ref group field . o)
  (if group
      (apply assq-ref (cdr group) field o)
      (and (pair? o) (car o))))

(define (test-group-set! group field value)
  (cond
   ((assq field (cdr group))
    => (lambda (x) (set-cdr! x value)))
   (else (set-cdr! group (cons (cons field value) (cdr group))))))

(define (test-group-inc! group field . o)
  (let ((amount (if (pair? o) (car o) 1)))
    (cond
     ((assq field (cdr group))
      => (lambda (x) (set-cdr! x (+ amount (cdr x)))))
     (else (set-cdr! group (cons (cons field amount) (cdr group)))))))

(define (test-group-push! group field value)
  (cond
   ((assq field (cdr group))
    => (lambda (x) (set-cdr! x (cons value (cdr x)))))
   (else (set-cdr! group (cons (cons field (list value)) (cdr group))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define (assq-ref ls key . o)
  (cond ((assq key ls) => cdr)
        ((pair? o) (car o))
        (else #f)))

(define (approx-equal? a b epsilon)
  (cond
   ((> (abs a) (abs b))
    (approx-equal? b a epsilon))
   ((zero? a)
    (< (abs b) epsilon))
   (else
    (< (abs (/ (- a b) b)) epsilon))))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

;; partial pretty printing to abbreviate `quote' forms and the like
(define (write-to-string x)
  (call-with-output-string
    (lambda (out)
      (let wr ((x x))
        (if (pair? x)
            (cond
             ((and (symbol? (car x)) (pair? (cdr x)) (null? (cddr x))
                   (assq (car x)
                         '((quote . "'") (quasiquote . "`")
                           (unquote . ",") (unquote-splicing . ",@"))))
              => (lambda (s) (display (cdr s) out) (wr (cadr x))))
             (else
              (display "(" out)
              (wr (car x))
              (let lp ((ls (cdr x)))
                (cond ((pair? ls)
                       (display " " out)
                       (wr (car ls))
                       (lp (cdr ls)))
                      ((not (null? ls))
                       (display " . " out)
                       (write ls out))))
              (display ")" out)))
            (write x out))))))

(define (display-to-string x)
  (if (string? x) x (call-with-output-string (lambda (out) (display x out)))))

;; if we need to truncate, try first dropping let's to get at the
;; heart of the expression
(define (truncate-source x width . o)
  (let* ((str (write-to-string x))
         (len (string-length str)))
    (cond
     ((<= len width)
      str)
     ((and (pair? x) (eq? 'let (car x)))
      (if (and (pair? o) (car o))
          (truncate-source (car (reverse x)) width #t)
          (string-append "..."
                         (truncate-source (car (reverse x)) (- width 3) #t))))
     ((and (pair? x) (eq? 'call-with-current-continuation (car x)))
      (truncate-source (cons 'call/cc (cdr x)) width (and (pair? o) (car o))))
     ((and (pair? x) (eq? 'call-with-values (car x)))
      (string-append
       "..."
       (truncate-source (if (and (pair? (cadr x)) (eq? 'lambda (car (cadr x))))
                            (car (reverse (cadr x)))
                            (cadr x))
                        (- width 3)
                        #t)))
     (else
      (string-append
       (substring str 0 (min (max 0 (- width 3)) (string-length str)))
       "...")))))

(define (test-get-name! info)
  (or
   (assq-ref info 'name)
   (assq-ref info 'gen-name)
   (let ((name
          (cond
           ((assq 'source info)
            => (lambda (src)
                 (truncate-source (cdr src) (- (current-column-width) 12))))
           ((current-test-group)
            => (lambda (g)
                 (display "no source in: " (current-error-port))
                 (write info (current-error-port))
                 (display "\n" (current-error-port))
                 (string-append
                  "test-"
                  (number->string (test-group-ref g 'count 0)))))
           (else ""))))
     (if (pair? info)
         (set-cdr! info (cons (cons 'gen-name name) (cdr info))))
     name)))

(define (test-print-name info . indent)
  (let ((width (- (current-column-width)
                  (or (and (pair? indent) (car indent)) 0)))
        (name (test-get-name! info)))
    (display name)
    (display " ")
    (let ((diff (- width 9 (string-length name))))
      (cond
       ((positive? diff)
        (display (make-string diff #\.)))))
    (display " ")
    (flush-output-port)))

(define (test-group-indent-width group)
  (let ((level (max 0 (+ 1 (- (test-group-ref group 'level 0)
                              (test-first-indentation))))))
    (* 4 (min level (test-max-indentation)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (test-expand-info info)
  (let ((expr (assq-ref info 'source)))
    (if (and (pair? expr)
             (pair-source expr)
             (not (assq-ref info 'line-number)))
        `((file-name . ,(car (pair-source expr)))
          (line-number . ,(cdr (pair-source expr)))
          ,@info)
        info)))

(define (test-run expect expr info)
  (let ((info (test-expand-info info)))
    (if (and (cond ((current-test-group)
                    => (lambda (g) (not (test-group-ref g 'skip-group?))))
                   (else #t))
             (every (lambda (f) (f info)) (current-test-filters)))
        ((current-test-applier) expect expr info)
        ((current-test-skipper) info))))

(define (test-default-applier expect expr info)
  (let* ((group (current-test-group))
         (indent (and group (test-group-indent-width group))))
    (cond
     ((test-group-ref group 'verbose)
      (if (and indent (positive? indent))
          (display (make-string indent #\space)))
      (test-print-name info indent)))
    (let ((expect-val
           (guard
               (exn
                (else
                 (warning "bad expect value")
                 (print-exception exn (current-error-port))
                 #f))
             (expect))))
      (guard
          (exn
           (else
            ((current-test-handler)
             (if (assq-ref info 'expect-error) 'PASS 'ERROR)
             (append `((exception . ,exn)) info))))
        (let ((res (expr)))
          (let ((status
                 (if (and (not (assq-ref info 'expect-error))
                          (if (assq-ref info 'assertion)
                              res
                              ((current-test-comparator) expect-val res)))
                     'PASS
                     'FAIL))
                (info `((result . ,res) (expected . ,expect-val) ,@info)))
            ((current-test-handler) status info)))))))

(define (test-default-skipper info)
  ((current-test-handler) 'SKIP info))

(define (test-status-color status)
  (case status
    ((ERROR) (lambda (x) (underline (red x))))
    ((FAIL) red)
    ((SKIP) yellow)
    (else (lambda (x) x))))

(define (test-status-message status)
  ((test-status-color status) status))

(define (test-status-code status)
  ((test-status-color status)
   (case status
     ((ERROR) "!")
     ((FAIL) "x")
     ((SKIP) "-")
     (else "."))))

(define (test-print-explanation indent status info)
  (cond
   ((eq? status 'ERROR)
    (display indent)
    (cond ((assq 'exception info)
           => (lambda (e)
                (print-exception (cdr e) (current-output-port))))))
   ((and (eq? status 'FAIL) (assq-ref info 'assertion))
    (display indent)
    (display "assertion failed\n"))
   ((and (eq? status 'FAIL) (assq-ref info 'expect-error))
    (display indent)
    (display "expected an error but got ")
    (write (assq-ref info 'result)) (newline))
   ((eq? status 'FAIL)
    (display indent)
    (display "expected ") (write (assq-ref info 'expected))
    (display " but got ") (write (assq-ref info 'result)) (newline)))
  ;; print variables
  (cond
   ((and (memq status '(FAIL ERROR)) (assq-ref info 'var-names))
    => (lambda (names)
         (let ((values (assq-ref info 'var-values)))
           (if (and (pair? names)
                    (pair? values)
                    (= (length names) (length values)))
               (let ((indent2
                      (string-append indent (make-string 2 #\space))))
                 (for-each
                  (lambda (name value)
                    (display indent2) (write name) (display ": ")
                    (write value) (newline))
                  names values))))))))

(define (test-print-source indent status info)
  (case status
    ((FAIL ERROR)
     (cond
      ((assq-ref info 'line-number)
       => (lambda (line)
            (display "    on line ")
            (write line)
            (cond ((assq-ref info 'file-name)
                   => (lambda (file) (display " of file ") (write file))))
            (newline))))
     (cond
      ((assq-ref info 'source)
       => (lambda (s)
            (cond
             ((or (assq-ref info 'name)
                  (> (string-length (write-to-string s))
                     (current-column-width)))
              (display (write-to-string s))
              (newline))))))
     (cond
      ((assq-ref info 'values)
       => (lambda (v)
            (for-each
             (lambda (v)
               (display "    ") (display (car v))
               (display ": ") (write (cdr v)) (newline))
             v)))))))

(define (test-print-failure indent status info)
  ;; display status explanation
  (test-print-explanation indent status info)
  ;; display line, source and values info
  (test-print-source indent status info))

(define (test-print-header-line str . indent)
  (let* ((header (string-append
                  (make-string (if (pair? indent) (car indent) 0) #\space)
                  "-- " str " "))
         (len (string-length header)))
    (display (bold header))
    (display (make-string (max 0 (- (current-column-width) len)) #\-))
    (newline)))

(define (test-default-handler status info)
  (define indent
    (make-string
     (+ 4 (cond ((current-test-group)
                 => (lambda (group) (or (test-group-indent-width group) 0)))
                (else 0)))
     #\space))
  ;; update group info
  (cond
   ((current-test-group)
    => (lambda (group)
         (if (not (eq? 'SKIP status))
             (test-group-inc! group 'count))
         (test-group-inc! group status)
         ;; maybe wrap long status lines
         (let ((width (max (- (current-column-width)
                              (or (test-group-indent-width group) 0))
                           4))
               (column
                (+ (string-length (or (test-group-name group) ""))
                   (or (test-group-ref group 'count) 0)
                   1)))
           (if (and (zero? (modulo column width))
                    (not (test-group-ref group 'verbose)))
               (display (string-append "\n" (string-copy indent 4))))))))
  ;; update global failure count for exit status
  (cond
   ((or (eq? status 'FAIL) (eq? status 'ERROR))
    (test-failure-count (+ 1 (test-failure-count)))))
  (cond
   ((eq? status 'SKIP))
   ((test-group-ref (current-test-group) 'verbose)
    ;; display status
    (display "[")
    (if (not (eq? status 'ERROR)) (display " ")) ; pad
    (display (test-status-message status))
    (display "]")
    (newline)
    (test-print-failure indent status info))
   (else
    (display (test-status-code status))
    (cond
     ((and (memq status '(FAIL ERROR)) (current-test-group))
      => (lambda (group)
           (test-group-push! group 'failures (list indent status info)))))
    (cond ((current-test-group)
           => (lambda (group) (test-group-set! group 'trailing #t))))))
  (flush-output-port)
  status)

(define (test-default-group-reporter group)
  (define (plural word n)
    (if (= n 1) word (string-append word "s")))
  (define (percent n d)
    (string-append " (" (number->string (/ (round (* 1000.0 (/ n d))) 10))
                   "%)"))
  (let* ((end-time (current-second))
         (start-time (test-group-ref group 'start-time))
         (duration (- end-time start-time))
         (base-count (or (test-group-ref group 'count) 0))
         (base-pass (or (test-group-ref group 'PASS) 0))
         (base-fail (or (test-group-ref group 'FAIL) 0))
         (base-err (or (test-group-ref group 'ERROR) 0))
         (skip (or (test-group-ref group 'SKIP) 0))
         (pass (+ base-pass (or (test-group-ref group 'total-pass) 0)))
         (fail (+ base-fail (or (test-group-ref group 'total-fail) 0)))
         (err (+ base-err (or (test-group-ref group 'total-error) 0)))
         (count (+ pass fail err))
         (subgroups-count (or (test-group-ref group 'subgroups-count) 0))
         (subgroups-pass (or (test-group-ref group 'subgroups-pass) 0))
         (indent (make-string (or (test-group-indent-width group) 0) #\space)))
    (if (and (not (test-group-ref group 'verbose))
             (test-group-ref group 'trailing))
        (newline))
    (cond
     ((or (positive? count) (positive? subgroups-count))
      (if (not (= base-count (+ base-pass base-fail base-err)))
          (warning "inconsistent count:"
                   base-count base-pass base-fail base-err))
      (cond
       ((positive? count)
        (display indent)
        (display
         ((if (= pass count) green (lambda (x) x))
          (string-append
           (number->string pass) " out of " (number->string count)
           (percent pass count))))
        (display
         (string-append
          (plural " test" pass) " passed in "
          (number->string duration) " seconds"
          (cond
           ((zero? skip) "")
           (else (string-append " (" (number->string skip)
                                (plural " test" skip) " skipped)")))
          ".\n"))))
      (cond ((positive? fail)
             (display indent)
             (display
              (red
               (string-append
                (number->string fail) (plural " failure" fail)
                (percent fail count) ".\n")))))
      (cond ((positive? err)
             (display indent)
             (display
              ((lambda (x) (underline (red x)))
               (string-append
                (number->string err) (plural " error" err)
                (percent err count) ".\n")))))
      (cond
       ((not (test-group-ref group 'verbose))
        (for-each
         (lambda (failure)
           (display indent)
           (display (red
                     (string-append (display-to-string (cadr failure)) ": ")))
           (display (test-get-name! (car (cddr failure))))
           (newline)
           (apply test-print-failure failure))
         (reverse (or (test-group-ref group 'failures) '())))))
      (cond
       ((positive? subgroups-count)
        (display indent)
        (display
         ((if (= subgroups-pass subgroups-count)
              green (lambda (x) x))
          (string-append
           (number->string subgroups-pass) " out of "
           (number->string subgroups-count)
           (percent subgroups-pass subgroups-count))))
        (display (plural " subgroup" subgroups-pass))
        (display " passed.\n")))))
    (cond
     ((test-group-ref group 'verbose)
      (test-print-header-line
       (string-append "done testing " (or (test-group-name group) ""))
       (or (test-group-indent-width group) 0))
      (newline)))
    (cond
     ((test-group-ref group 'parent)
      => (lambda (parent)
           (test-group-set! parent 'trailing #f)
           (test-group-inc! parent 'total-pass pass)
           (test-group-inc! parent 'total-fail fail)
           (test-group-inc! parent 'total-error err))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (test-equal? expect res)
  (or (equal? expect res)
      (if (real? expect)
          (and (inexact? expect)
               (real? res)
               (inexact? res)
               (approx-equal? expect res (current-test-epsilon)))
          (and (complex? res)
               (complex? expect)
               (test-equal? (real-part expect) (real-part res))
               (test-equal? (imag-part expect) (imag-part res))))))

;;> Begin testing a new group until the closing \scheme{(test-end)}.

(define (test-begin . o)
  (let* ((name (if (pair? o) (car o) ""))
         (parent (current-test-group))
         (group (make-test-group name parent)))
    (cond
     ((and parent
           ;; (zero? (test-group-ref parent 'count 0))
           (zero? (test-group-ref parent 'subgroups-count 0)))
      (newline)))
    (cond
     ((test-group-ref group 'verbose)
      (test-print-header-line
       (string-append "testing " name)
       (or (test-group-indent-width group) 0)))
     (else
      (display
       (make-string (or (test-group-indent-width group) 0)
                    #\space))
      (display (bold (string-append name ": ")))))
    (current-test-group group)))

;;> Ends testing group introduced with \scheme{(test-begin)}, and
;;> summarizes the results.

(define (test-end . o)
  (cond
   ((current-test-group)
    => (lambda (group)
         (if (and (pair? o) (not (equal? (car o) (test-group-name group))))
             (warning "mismatched test-end:" (car o) (test-group-name group)))
         (let ((parent (test-group-ref group 'parent)))
           (cond
            ((not (test-group-ref group 'skip-group?))
             ;; only report if there's something to say
             ((current-test-group-reporter) group)
             (cond
              (parent
               (test-group-inc! parent 'subgroups-count)
               (cond
                ((and (zero? (test-group-ref group 'FAIL 0))
                      (zero? (test-group-ref group 'ERROR 0))
                      (= (test-group-ref group 'subgroups-pass 0)
                         (test-group-ref group 'subgroups-count 0)))
                 (test-group-inc! parent 'subgroups-pass)))))))
           (current-test-group parent)
           group)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parameters

(define current-test-group (make-parameter #f))
(define current-test-verbosity
  (make-parameter
   (cond ((get-environment-variable "TEST_VERBOSE")
          => (lambda (s) (not (member s "" "0"))))
         (else #f))))
(define current-test-epsilon (make-parameter 1e-5))
(define current-test-comparator (make-parameter test-equal?))
(define current-test-applier (make-parameter test-default-applier))
(define current-test-handler (make-parameter test-default-handler))
(define current-test-skipper (make-parameter test-default-skipper))
(define current-test-group-reporter
  (make-parameter test-default-group-reporter))
(define test-failure-count (make-parameter 0))

(define test-first-indentation
  (make-parameter
   (or (cond ((get-environment-variable "TEST_FIRST_INDENTATION")
              => string->number)
             (else #f))
       1)))

(define test-max-indentation
  (make-parameter
   (or (cond ((get-environment-variable "TEST_MAX_INDENTATION")
              => string->number)
             (else #f))
       5)))

(define (string->info-matcher str)
  (lambda (info)
    (cond ((test-get-name! info)
           => (lambda (n) (string-search str n)))
          (else #f))))

(define (string->group-matcher str)
  (lambda (group) (string-search str (car group))))

(define (getenv-filter-list proc name . o)
  (cond
   ((get-environment-variable name)
    => (lambda (s)
         (guard
             (exn
              (else
               (warning
                (string-append "invalid filter '" s
                               "' from environment variable: " name))
               (print-exception exn (current-error-port))
               '()))
           (let ((f (proc s)))
             (list (if (and (pair? o) (car o))
                       (lambda (x) (not (f x)))
                       f))))))
   (else '())))

(define current-test-filters
  (make-parameter
   (append (getenv-filter-list string->info-matcher "TEST_FILTER")
           (getenv-filter-list string->info-matcher "TEST_REMOVE" #t))))

(define current-test-group-filters
  (make-parameter
   (append (getenv-filter-list string->group-matcher "TEST_GROUP_FILTER")
           (getenv-filter-list string->group-matcher "TEST_GROUP_REMOVE" #t))))

(define current-column-width
  (make-parameter
   (or (cond ((get-environment-variable "TEST_COLUMN_WIDTH")
              => string->number)
             (else #f))
       78)))
;; regexp.scm -- simple non-bactracking NFA implementation
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;; An rx represents a start state and meta-info such as the number
;;; and names of submatches.
(define-record-type Rx
  (make-rx start-state num-matches num-save-indexes match-rules match-names sre)
  regexp?
  (start-state rx-start-state rx-start-state-set!)
  (num-matches rx-num-matches rx-num-matches-set!)
  (num-save-indexes rx-num-save-indexes rx-num-save-indexes-set!)
  (match-rules rx-rules rx-rules-set!)
  (match-names rx-names rx-names-set!)
  (sre regexp->sre))

;; Syntactic sugar.
(define-syntax rx
  (syntax-rules ()
    ((rx sre ...)
     (regexp `(: sre ...)))))

;;; A state is a single nfa state with transition rules.
(define-record-type State
  (%make-state accept? chars match match-rule next1 next2)
  state?
  ;; A boolean indicating if this is an accepting state.
  (accept? state-accept? state-accept?-set!)
  ;; A char or char-set indicating when we can transition.
  ;; Alternately, #f indicates an epsilon transition, while a
  ;; procedure of the form (lambda (ch i matches) ...) is a predicate
  ;; which should return #t if the char matches.
  (chars state-chars state-chars-set!)
  ;; A single integer indicating the match position to record.
  (match state-match state-match-set!)
  ;; The rule for merging ambiguous matches.  Can be any of: left,
  ;; right, (list i j).  Posix semantics are equivalent to using left
  ;; for the beginning of a submatch and right for the end.  List is
  ;; used to capture a list of submatch data in the current match.
  (match-rule state-match-rule state-match-rule-set!)
  ;; The destination if the char match succeeds.
  (next1 state-next1 state-next1-set!)
  ;; An optional additional transition used for forking to two states.
  (next2 state-next2 state-next2-set!))

(define (make-state accept? chars match match-rule next1 next2)
  (if (and next1 (not (state? next1)))
      (error "expected a state" next1))
  (if (and next2 (not (state? next2)))
      (error "expected a state" next2))
  (%make-state accept? chars match match-rule next1 next2))

(define ~none 0)
(define ~ci? 1)
(define ~ascii? 2)
(define ~nocapture? 4)

(define (flag-set? flags i) (= i (bitwise-and flags i)))
(define (flag-join a b) (if b (bitwise-ior a b) a))
(define (flag-clear a b) (bitwise-and a (bitwise-not b)))

(define (char-set-ci cset)
  (let ((res (char-set)))
    (char-set-for-each
     (lambda (ch)
       (char-set-adjoin! res (char-upcase ch))
       (char-set-adjoin! res (char-downcase ch)))
     cset)
    res))

(define (make-char-state ch flags next)
  (if (flag-set? flags ~ci?)
      (let ((cset (cond ((char? ch) (char-set-ci (char-set ch)))
                        ((char-set? ch) (char-set-ci ch))
                        (else ch))))
        (make-state #f cset #f #f next #f))
      (make-state #f ch #f #f next #f)))
(define (make-fork-state next1 next2)
  (make-state #f #f #f #f next1 next2))
(define (make-epsilon-state next)
  (make-fork-state next #f))
(define (make-accept-state)
  (make-state #t #f #f #f #f #f))

;; A record holding the current match data - essentially a wrapper
;; around a vector, plus a reference to the RX for meta-info.
(define-record-type Regexp-Match
  (%make-regexp-match matches rx string)
  regexp-match?
  (matches regexp-match-matches regexp-match-matches-set!)
  (rx regexp-match-rx)
  (string regexp-match-string))

(define (regexp-match-rules md)
  (rx-rules (regexp-match-rx md)))
(define (regexp-match-names md)
  (rx-names (regexp-match-rx md)))
(define (make-regexp-match len rx str)
  (%make-regexp-match (make-vector len #f) rx str))
(define (make-regexp-match-for-rx rx str)
  (make-regexp-match (rx-num-save-indexes rx) rx str))
(define (regexp-match-count md)
  (- (quotient (vector-length (regexp-match-matches md)) 2) 1))

(define (regexp-match-name-offset md name)
  (let lp ((ls (regexp-match-names md)) (first #f))
    (cond
     ((null? ls) (or first (error "unknown match name" md name)))
     ((eq? name (caar ls))
      (if (regexp-match-submatch-start+end md (cdar ls))
          (cdar ls)
          (lp (cdr ls) (or first (cdar ls)))))
     (else (lp (cdr ls) first)))))

(define (regexp-match-ref md n)
  (vector-ref (regexp-match-matches md)
              (if (integer? n)
                  n
                  (regexp-match-name-offset md n))))

(define (regexp-match-set! md n val)
  (vector-set! (regexp-match-matches md) n val))

(define (copy-regexp-match md)
  (let* ((src (regexp-match-matches md))
         (len (vector-length src))
         (dst (make-vector len #f)))
    (do ((i 0 (+ i 1)))
        ((= i len)
         (%make-regexp-match dst (regexp-match-rx md) (regexp-match-string md)))
      (vector-set! dst i (vector-ref src i)))))

;;> Returns the matching result for the given named or indexed
;;> submatch \var{n}, possibly as a list for a submatch-list, or
;;> \scheme{#f} if not matched.

(define (regexp-match-submatch/list md n)
  (let ((n (if (integer? n) n (regexp-match-name-offset md n))))
    (cond
     ((>= n (vector-length (regexp-match-rules md)))
      #f)
     (else
      (let ((rule (vector-ref (regexp-match-rules md) n)))
        (cond
         ((pair? rule)
          (let ((start (regexp-match-ref md (car rule)))
                (end (regexp-match-ref md (cdr rule)))
                (str (regexp-match-string md)))
            (and start end (substring-cursor str start end))))
         (else
          (let ((res (regexp-match-ref md rule)))
            (if (pair? res)
                (reverse res)
                res)))))))))

;;> Returns the matching substring for the given named or indexed
;;> submatch \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch md n)
  (let ((res (regexp-match-submatch/list md n)))
    (if (pair? res) (car res) res)))

(define (regexp-match-submatch-start+end md n)
  (let ((n (if (string-cursor? n) n (regexp-match-name-offset md n))))
    (and (< n (vector-length (regexp-match-rules md)))
         (let ((rule (vector-ref (regexp-match-rules md) n)))
           (if (pair? rule)
               (let ((start (regexp-match-ref md (car rule)))
                     (end (regexp-match-ref md (cdr rule)))
                     (str (regexp-match-string md)))
                 (and start end
                      (cons (string-offset->index str start)
                            (string-offset->index str end))))
               #f)))))

;;> Returns the start index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch-start md n)
  (cond ((regexp-match-submatch-start+end md n) => car) (else #f)))

;;> Returns the end index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch-end md n)
  (cond ((regexp-match-submatch-start+end md n) => cdr) (else #f)))

(define (regexp-match-convert recurse? md str)
  (cond
   ((vector? md)
    (let lp ((i 0) (res '()))
      (cond
       ((>= i (vector-length md))
        (reverse res))
       ((string-cursor? (vector-ref md i))
        (lp (+ i 2)
            (cons (substring-cursor str
                                    (vector-ref md i)
                                    (vector-ref md (+ i 1)))
                  res)))
       (else
        (lp (+ i 1)
            (cons (regexp-match-convert recurse? (vector-ref md i) str)
                  res))))))
   ((list? md)
    (if recurse?
        (map (lambda (x) (regexp-match-convert recurse? x str)) (reverse md))
        (regexp-match-convert recurse? (car md) str)))
   ((and (pair? md) (string-cursor? (car md)) (string-cursor? (cdr md)))
    (substring-cursor str (car md) (cdr md)))
   ((regexp-match? md)
    (regexp-match-convert
     recurse? (regexp-match-matches md) (regexp-match-string md)))
   (else
    md)))

;;> Convert an regexp-match result to a list of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

(define (regexp-match->list md)
  (regexp-match-convert #f md #f))

;;> Convert an regexp-match result to a forest of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

(define (regexp-match->sexp md)
  (regexp-match-convert #t md #f))

;; Collect results from a list match.
(define (match-collect md spec)
  (define (match-extract md n)
    (let* ((vec (regexp-match-matches md))
           (rules (regexp-match-rules md))
           (n-rule (vector-ref rules n))
           (rule (vector-ref rules n-rule)))
      (if (pair? rule)
          (let ((start (regexp-match-ref md (car rule)))
                (end (regexp-match-ref md (cdr rule))))
            (and start end (cons start end)))
          (regexp-match-ref md rule))))
  (let ((end (cadr spec))
        (vec (regexp-match-matches md)))
    (let lp ((i (+ 1 (car spec)))
             (ls '()))
      (if (>= i end)
          (reverse ls)
          (lp (+ i 1) (cons (match-extract md i) ls))))))

;; A searcher represents a single rx state and match information.
(define-record-type Searcher
  (make-searcher state matches)
  searcher?
  (state searcher-state searcher-state-set!)
  (matches searcher-matches searcher-matches-set!))

;; Merge two regexp-matches, preferring the leftmost-longest of their
;; matches.
(define (regexp-match>=? m1 m2)
  (let ((end (- (vector-length (regexp-match-matches m1)) 1)))
    (let lp ((i 0))
      (cond
       ((>= i end)
        #t)
       ((and (eqv? (regexp-match-ref m1 i)
                   (regexp-match-ref m2 i))
             (eqv? (regexp-match-ref m1 (+ i 1))
                   (regexp-match-ref m2 (+ i 1))))
        (lp (+ i 2)))
       ((and (string-cursor? (regexp-match-ref m2 i))
             (or (not (string-cursor? (regexp-match-ref m1 i)))
                 (string-cursor<? (regexp-match-ref m2 i)
                                  (regexp-match-ref m1 i))
                 (and
                  (string-cursor=? (regexp-match-ref m2 i)
                                   (regexp-match-ref m1 i))
                  (or (not (string-cursor? (regexp-match-ref m2 (+ i 1))))
                      (and (string-cursor? (regexp-match-ref m1 (+ i 1)))
                           (string-cursor>? (regexp-match-ref m2 (+ i 1))
                                            (regexp-match-ref m1 (+ i 1))))))))
        #f)
       (else
        #t)))))

(define (regexp-match-max m1 m2)
  (if (regexp-match>=? m1 m2) m1 m2))

;; Merge match data from sr2 into sr1, preferring the leftmost-longest
;; match in the event of a conflict.
(define (searcher-merge! sr1 sr2)
  (let ((m (regexp-match-max (searcher-matches sr1) (searcher-matches sr2))))
    (searcher-matches-set! sr1 m)))

(define (searcher-max sr1 sr2)
  (if (or (not (searcher? sr2))
          (regexp-match>=? (searcher-matches sr1) (searcher-matches sr2)))
      sr1
      sr2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A posse is a group of searchers.

(define (make-posse . o)
  (make-hash-table eq?))

(define posse? hash-table?)
(define (posse-empty? posse) (zero? (hash-table-size posse)))

(define (posse-ref posse sr)
  (hash-table-ref/default posse (searcher-state sr) #f))
(define (posse-add! posse sr)
  (hash-table-set! posse (searcher-state sr) sr))
(define (posse-clear! posse)
  (hash-table-walk posse (lambda (key val) (hash-table-delete! posse key))))
(define (posse-for-each proc posse)
  (hash-table-walk posse (lambda (key val) (proc val))))

(define (posse->list posse)
  (hash-table-values posse))
(define (list->posse ls)
  (let ((searchers (make-posse)))
    (for-each (lambda (sr) (posse-add! searchers sr)) ls)
    searchers))
(define (posse . args)
  (list->posse args))

(define (make-start-searcher rx str)
  (make-searcher (rx-start-state rx) (make-regexp-match-for-rx rx str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Execution

;; A transition which doesn't advance the index.

(define (epsilon-state? st)
  (or (not (state-chars st))
      (procedure? (state-chars st))))

;; Match the state against a char and index.

(define (state-matches? st str i ch start end matches)
  (let ((matcher (state-chars st)))
    (cond
     ((char? matcher)
      (eqv? matcher ch))
     ((char-set? matcher)
      (char-set-contains? matcher ch))
     ((pair? matcher)
      (and (char<=? (car matcher) ch) (char<=? ch (cdr matcher))))
     ((procedure? matcher)
      (matcher str i ch start end matches))
     ((not matcher))
     (else
      (error "unknown state matcher" (state-chars st))))))

;; Advance epsilons together - if the State is newly added to the
;; group and is an epsilon state, recursively add the transition.

(define (posse-advance! new seen accept sr str i start end)
  (let advance! ((sr sr))
    (let ((st (searcher-state sr)))
      ;; Update match data.
      (cond
       ((state-match st)
        (let ((index (state-match st))
              (matches (searcher-matches sr)))
          (cond
           ((pair? index)
            ;; Submatch list, accumulate and push.
            (let* ((prev (regexp-match-ref matches (car index)))
                   (new (cons (match-collect matches (cdr index))
                              (if (pair? prev) prev '()))))
              (regexp-match-set! matches (car index) new)))
           (else
            (regexp-match-set! matches index i))))))
      ;; Follow transitions.
      (cond
       ((state-accept? st)
        (set-cdr! accept (searcher-max sr (cdr accept))))
       ((posse-ref seen sr)
        => (lambda (sr-prev) (searcher-merge! sr-prev sr)))
       ((epsilon-state? st)
        (let ((ch (and (string-cursor<? i end) (string-cursor-ref str i))))
          ;; Epsilon transition.  If there is a procedure matcher,
          ;; it's a guarded epsilon and needs to be checked.
          (cond
           ((state-matches? st str i ch start end (searcher-matches sr))
            (posse-add! seen sr)
            (let ((next1 (state-next1 st))
                  (next2 (state-next2 st)))
              (cond
               (next1
                (searcher-state-set! sr next1)
                (advance! sr))) 
              (cond
               (next2
                (let ((sr2 (make-searcher
                            next2
                            (copy-regexp-match (searcher-matches sr)))))
                  (advance! sr2)))))))))
       ;; Non-special, non-epsilon searcher, add to posse.
       ((posse-ref new sr)
        ;; Merge regexp-match for existing searcher.
        => (lambda (sr-prev) (searcher-merge! sr-prev sr)))
       (else
        ;; Add new searcher.
        (posse-add! new sr))))))

;; Run so long as there is more to match.

(define (regexp-run-offsets search? rx str start end)
  (let ((rx (regexp rx))
        (epsilons (posse))
        (accept (list #f)))
    (let lp ((i start)
             (searchers1 (posse))
             (searchers2 (posse)))
      ;; Advance initial epsilons once from the first index, or every
      ;; time when searching.
      (cond
       ((or search? (string-cursor=? i start))
        (posse-advance! searchers1 epsilons accept (make-start-searcher rx str)
                        str i start end)
        (posse-clear! epsilons))) 
      (cond
       ((or (string-cursor>=? i end)
            (and (or (not search?) (searcher? (cdr accept)))
                 (posse-empty? searchers1)))
        ;; Terminate when the string is done or there are no more
        ;; searchers.  If we terminate prematurely and are not
        ;; searching, return false.
        (and (searcher? (cdr accept))
             (let ((matches (searcher-matches (cdr accept))))
               (and (or search? (>= (regexp-match-ref matches 1) end))
                    (searcher-matches (cdr accept))))))
       (else
        ;; Otherwise advance normally.
        (let ((ch (string-cursor-ref str i))
              (i2 (string-cursor-next str i)))
          (posse-for-each  ;; NOTE: non-deterministic from hash order
           (lambda (sr)
             (cond
              ((state-matches? (searcher-state sr) str i ch
                               start end (searcher-matches sr))
               (searcher-state-set! sr (state-next1 (searcher-state sr)))
               ;; Epsilons are considered at the next position.
               (posse-advance! searchers2 epsilons accept sr str i2 start end)
               (posse-clear! epsilons))))
           searchers1)
          (posse-clear! searchers1)
          (lp i2 searchers2 searchers1)))))))

;; Wrapper to determine start and end offsets.

(define (regexp-run search? rx str . o)
  (let ((start (string-start-arg str o))
        (end (string-end-arg str (if (pair? o) (cdr o) o))))
    (regexp-run-offsets search? rx str start end)))

;;> Match the given regexp or SRE against the entire string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

(define (regexp-matches rx str . o)
  (apply regexp-run #f rx str o))

;;> Match the given regexp or SRE against the entire string and return
;;> the \scheme{#t} on success.  Returns \scheme{#f} on failure.

(define (regexp-matches? rx str . o)
  (and (apply regexp-matches rx str o) #t))

;;> Search for the given regexp or SRE within string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

(define (regexp-search rx str . o)
  (apply regexp-run #t rx str o))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiling

(define (parse-flags ls)
  (define (symbol->flag s)
    (case s ((i ci case-insensitive) ~ci?) (else ~none)))
  (let lp ((ls ls) (res ~none))
    (if (not (pair? ls))
        res
        (lp (cdr ls) (flag-join res (symbol->flag (car ls)))))))

(define char-set:nonl
  (char-set-difference char-set:full (char-set #\newline)))
(define char-set:control (ucs-range->char-set 0 32))
(define char-set:word-constituent
  (char-set-union char-set:letter char-set:digit (char-set #\_)))
(define %char-set:word-constituent
  (char-set-union %char-set:letter %char-set:digit (char-set #\_)))
(define (char-word-constituent? ch)
  (char-set-contains? char-set:word-constituent ch))
(define get-char-set:cased
  (let ((char-set:cased #f))
    (lambda ()
      (if (not char-set:cased)
          (set! char-set:cased
                (char-set-union char-set:upper-case
                                char-set:lower-case
                                char-set:title-case)))
      char-set:cased)))

(define (match/bos str i ch start end matches)
  (string-cursor=? i start))
(define (match/eos str i ch start end matches)
  (string-cursor>=? i end))
(define (match/bol str i ch start end matches)
  (or (string-cursor=? i start)
      (eqv? #\newline (string-cursor-ref str (string-cursor-prev str i)))))
(define (match/eol str i ch start end matches)
  (or (string-cursor>=? i end)
      (eqv? #\newline (string-cursor-ref str i))))
(define (match/bow str i ch start end matches)
  (and (string-cursor<? i end)
       (or (string-cursor=? i start)
           (not (char-word-constituent?
                 (string-cursor-ref str (string-cursor-prev str i)))))
       (char-word-constituent? ch)))
(define (match/eow str i ch start end matches)
  (and (or (string-cursor>=? i end)
           (not (char-word-constituent? ch)))
       (string-cursor>? i start)
       (char-word-constituent?
        (string-cursor-ref str (string-cursor-prev str i)))))
(define (match/nwb str i ch start end matches)
  (and (not (match/bow str i ch start end matches))
       (not (match/eow str i ch start end matches))))
(define (match/bog str i ch start end matches)
  (and (string-cursor<? i end)
       (or (string-cursor=? i start)
           (match/eog str (string-cursor-prev str i) ch start end matches))))
(define (match/eog str i ch start end matches)
  (and (string-cursor>? i start)
       (or (string-cursor>=? i end)
           (let ((m (regexp-search re:grapheme str
                                   (string-offset->index str i)
                                   (string-offset->index str end))))
             (and m (string-cursor<=? (regexp-match-submatch-end m 0) i))))))

(define (lookup-char-set name flags)
  (cond
   ((flag-set? flags ~ascii?)
    (case name
      ((any) char-set:full)
      ((nonl) char-set:nonl)
      ((lower-case lower)
       (if (flag-set? flags ~ci?) %char-set:letter %char-set:lower-case))
      ((upper-case upper)
       (if (flag-set? flags ~ci?) %char-set:letter %char-set:upper-case))
      ((title-case title)
       (if (flag-set? flags ~ci?) %char-set:letter (char-set)))
      ((alphabetic alpha) %char-set:letter)
      ((numeric num digit) %char-set:digit)
      ((alphanumeric alphanum alnum) %char-set:letter+digit)
      ((punctuation punct) %char-set:punctuation)
      ((graphic graph) %char-set:graphic)
      ((word-constituent) %char-set:word-constituent)
      ((whitespace white space) %char-set:whitespace)
      ((printing print) %char-set:printing)
      ((control cntrl) %char-set:iso-control)
      ((hex-digit xdigit hex) char-set:hex-digit)
      ((ascii) char-set:ascii)
      (else #f)))
   (else
    (case name
      ((any) char-set:full)
      ((nonl) char-set:nonl)
      ((lower-case lower)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:lower-case))
      ((upper-case upper)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:upper-case))
      ((title-case title)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:title-case))
      ((alphabetic alpha) char-set:letter)
      ((numeric num digit) char-set:digit)
      ((alphanumeric alphanum alnum) char-set:letter+digit)
      ((punctuation punct) char-set:punctuation)
      ((graphic graph) char-set:graphic)
      ((word-constituent) char-set:word-constituent)
      ((whitespace white space) char-set:whitespace)
      ((printing print) char-set:printing)
      ((control cntrl) char-set:control)
      ((hex-digit xdigit hex) char-set:hex-digit)
      ((ascii) char-set:ascii)
      (else #f)))))

(define (sre-flatten-ranges orig-ls)
  (let lp ((ls orig-ls) (res '()))
    (cond
     ((null? ls)
      (reverse res))
     ((string? (car ls))
      (lp (append (string->list (car ls)) (cdr ls)) res))
     ((null? (cdr ls))
      (error "unbalanced cset / range" orig-ls))
     ((string? (cadr ls))
      (lp (cons (car ls) (append (string->list (cadr ls)) (cddr ls))) res))
     (else
      (lp (cddr ls) (cons (cons (car ls) (cadr ls)) res))))))

(define (every pred ls)
  (or (null? ls) (and (pred (car ls)) (every pred (cdr ls)))))

(define (char-set-sre? sre)
  (or (char? sre)
      (and (string? sre) (= 1 (string-length sre)))
      (lookup-char-set sre ~none)
      (and (pair? sre)
           (or (string? (car sre))
               (memq (car sre)
                     '(char-set / char-range & and ~ complement - difference))
               (and (memq (car sre) '(|\|| or))
                    (every char-set-sre? (cdr sre)))))))

(define (valid-sre? x)
  (guard (exn (else #f)) (regexp x) #t))

(define (sre->char-set sre . o)
  (let ((flags (if (pair? o) (car o) ~none)))
    (define (->cs sre) (sre->char-set sre flags))
    (cond
     ((lookup-char-set sre flags))
     ((char-set? sre) (char-set-ci sre))
     ((char? sre) (char-set-ci (char-set sre)))
     ((string? sre)
      (if (= 1 (string-length sre))
          (string->char-set sre)
          (error "only single char strings can be char-sets")))
     ((pair? sre)
      (if (string? (car sre))
          (string->char-set (car sre))
          (case (car sre)
            ((char-set) (string->char-set (cadr sre)))
            ((/ char-range)
             (->cs
              `(or ,@(map (lambda (x)
                            (char-set-ci
                             (ucs-range->char-set
                              (char->integer (car x))
                              (+ 1 (char->integer (cdr x))))))
                          (sre-flatten-ranges (cdr sre))))))
            ((& and) (apply char-set-intersection (map ->cs (cdr sre))))
            ((|\|| or) (apply char-set-union (map ->cs (cdr sre))))
            ((~ complement) (char-set-complement (->cs `(or ,@(cdr sre)))))
            ((- difference) (char-set-difference (->cs (cadr sre))
                                                 (->cs `(or ,@(cddr sre)))))
            (else (error "invalid sre char-set" sre)))))
     (else (error "invalid sre char-set" sre)))))

(define (char-set->sre cset)
  (list (char-set->string cset)))

(define (strip-submatches sre)
  (if (pair? sre)
      (case (car sre)
        (($ submatch) (strip-submatches (cons ': (cdr sre))))
        ((-> => submatch-named) (strip-submatches (cons ': (cddr sre))))
        (else (cons (strip-submatches (car sre))
                    (strip-submatches (cdr sre)))))
      sre))

(define (sre-expand-reps from to sre)
  (let ((sre0 (strip-submatches sre)))
    (let lp ((i 0) (res '(:)))
      (if (= i from)
          (cond
           ((not to)
            (reverse (cons `(* ,sre) res)))
           ((= from to)
            (reverse (cons sre (cdr res))))
           (else
            (let lp ((i (+ i 1)) (res res))
              (if (>= i to)
                  (reverse (cons `(? ,sre) res))
                  (lp (+ i 1) (cons `(? ,sre0) res))))))
          (lp (+ i 1) (cons sre0 res))))))

;;> Compile an \var{sre} into a regexp.

(define (regexp sre . o)
  (define current-index 2)
  (define current-match 0)
  (define match-names '())
  (define match-rules (list (cons 0 1)))
  (define (make-submatch-state sre flags next index)
    (let* ((n3 (make-epsilon-state next))
           (n2 (->rx sre flags n3))
           (n1 (make-epsilon-state n2)))
      (state-match-set! n1 index)
      (state-match-rule-set! n1 'left)
      (state-match-set! n3 (+ index 1))
      (state-match-rule-set! n3 'right)
      n1))
  (define (->rx sre flags next)
    (cond
     ;; The base cases chars and strings match literally.
     ((char? sre)
      (make-char-state sre flags next))
     ((char-set? sre)
      (make-char-state sre flags next))
     ((string? sre)
      (->rx (cons 'seq (string->list sre)) flags next))
     ((and (symbol? sre) (lookup-char-set sre flags))
      => (lambda (cset) (make-char-state cset ~none next)))
     ((symbol? sre)
      (case sre
        ((epsilon) next)
        ((bos) (make-char-state match/bos flags next))
        ((eos) (make-char-state match/eos flags next))
        ((bol) (make-char-state match/bol flags next))
        ((eol) (make-char-state match/eol flags next))
        ((bow) (make-char-state match/bow flags next))
        ((eow) (make-char-state match/eow flags next))
        ((nwb) (make-char-state match/nwb flags next))
        ((bog) (make-char-state match/bog flags next))
        ((eog) (make-char-state match/eog flags next))
        ((grapheme)
         (->rx
          `(or (: (* ,char-set:hangul-l) (+ ,char-set:hangul-v)
                  (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-v
                  (* ,char-set:hangul-v) (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-lvt
                  (* ,char-set:hangul-t))
               (+ ,char-set:hangul-l)
               (+ ,char-set:hangul-t)
               (+ ,char-set:regional-indicator)
               (: "\r\n")
               (: (~ control ("\r\n"))
                  (+ ,char-set:extend-or-spacing-mark))
               control)
          flags
          next))
        ((word) (->rx '(word+ any) flags next))
        (else (error "unknown sre" sre))))
     ((pair? sre)
      (case (car sre)
        ((seq :)
         ;; Sequencing.  An empty sequence jumps directly to next,
         ;; otherwise we join the first element to the sequence formed
         ;; of the remaining elements followed by next.
         (if (null? (cdr sre))
             next
             ;; Make a dummy intermediate to join the states so that
             ;; we can generate n1 first, preserving the submatch order.
             (let* ((n2 (make-epsilon-state #f))
                    (n1 (->rx (cadr sre) flags n2))
                    (n3 (->rx (cons 'seq (cddr sre)) flags next)))
               (state-next1-set! n2 n3)
               n1)))
        ((or |\||)
         ;; Alternation.  An empty alternation always fails.
         ;; Otherwise we fork between any of the alternations, each
         ;; continuing to next.
         (cond
          ((null? (cdr sre))
           #f)
          ((char-set-sre? sre)
           (make-char-state (sre->char-set sre) flags next))
          ((null? (cddr sre))
           (->rx (cadr sre) flags next))
          (else
           (let* ((n1 (->rx (cadr sre) flags next))
                  (n2 (->rx (cons 'or (cddr sre)) flags next)))
             (make-fork-state n1 n2)))))
        ((? optional)
         ;; Optionality.  Either match the body or fork to the next
         ;; state directly.
         (make-fork-state (->rx (cons 'seq (cdr sre)) flags next) next))
        ((* zero-or-more)
         ;; Repetition.  Introduce two fork states which can jump from
         ;; the end of the loop to the beginning and from the
         ;; beginning to the end (to skip the first iteration).
         (let* ((n2 (make-fork-state next #f))
                (n1 (make-fork-state (->rx (cons 'seq (cdr sre)) flags n2) n2)))
           (state-next2-set! n2 n1)
           n1))
        ((+ one-or-more)
         ;; One-or-more repetition.  Same as above but the first
         ;; transition is required so the rx is simpler - we only
         ;; need one fork from the end of the loop to the beginning.
         (let* ((n2 (make-fork-state next #f))
                (n1 (->rx (cons 'seq (cdr sre)) flags n2)))
           (state-next2-set! n2 n1)
           n1))
        ((= exactly)
         ;; Exact repetition.
         (->rx (sre-expand-reps (cadr sre) (cadr sre) (cons 'seq (cddr sre)))
               flags next))
        ((>= at-least)
         ;; n-or-more repetition.
         (->rx (sre-expand-reps (cadr sre) #f (cons 'seq (cddr sre)))
               flags next))
        ((** repeated)
         ;; n-to-m repetition.
         (->rx (sre-expand-reps (cadr sre) (car (cddr sre))
                                (cons 'seq (cdr (cddr sre))))
               flags next))
        ((-> => submatch-named)
         ;; Named submatches just record the name for the current
         ;; match and rewrite as a non-named submatch.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cddr sre)) flags next))
          (else
           (set! match-names
                 (cons (cons (cadr sre) (+ 1 current-match)) match-names))
           (->rx (cons 'submatch (cddr sre)) flags next))))
        ((*-> *=> submatch-named-list)
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cddr sre)) flags next))
          (else
           (set! match-names (cons (cons (cadr sre) current-match) match-names))
           (->rx (cons 'submatch-list (cddr sre)) flags next))))
        (($ submatch)
         ;; A submatch wraps next with an epsilon transition before
         ;; next, setting the start and end index on the result and
         ;; wrapped next respectively.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cdr sre)) flags next))
          (else
           (let ((num current-match)
                 (index current-index))
             (set! current-match (+ current-match 1))
             (set! current-index (+ current-index 2))
             (set! match-rules `((,index . ,(+ index 1)) ,@match-rules))
             (make-submatch-state (cons 'seq (cdr sre)) flags next index)))))
        ((*$ submatch-list)
         ;; A submatch-list wraps a range of submatch results into a
         ;; single match value.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cdr sre)) flags next))
          (else
           (let* ((num current-match)
                  (index current-index))
             (set! current-match (+ current-match 1))
             (set! current-index (+ current-index 1))
             (set! match-rules `(,index ,@match-rules))
             (let* ((n2 (make-epsilon-state next))
                    (n1 (->rx (cons 'submatch (cdr sre)) flags n2)))
               (state-match-set! n2 (list index num current-match))
               (state-match-rule-set! n2 'list)
               n1)))))
        ((~ - & / complement difference and char-range char-set)
         (make-char-state (sre->char-set sre flags) ~none next))
        ((word)
         (->rx `(: bow ,@(cdr sre) eow) flags next))
        ((word+)
         (->rx `(word (+ ,(if (equal? '(any) (cdr sre))
                              'word-constituent
                              (char-set-intersection
                               char-set:word-constituent
                               (sre->char-set `(or ,@(cdr sre)) flags)))))
               flags
               next))
        ((w/case)
         (->rx `(: ,@(cdr sre)) (flag-clear flags ~ci?) next))
        ((w/nocase)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~ci?) next))
        ((w/unicode)
         (->rx `(: ,@(cdr sre)) (flag-clear flags ~ascii?) next))
        ((w/ascii)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~ascii?) next))
        ((w/nocapture)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~nocapture?) next))
        (else
         (if (string? (car sre))
             (make-char-state (sre->char-set sre flags) ~none next)
             (error "unknown sre" sre)))))))
  (let ((flags (parse-flags (and (pair? o) (car o)))))
    (if (regexp? sre)
        sre
        (let ((start (make-submatch-state sre flags (make-accept-state) 0)))
          (make-rx start current-match current-index
                   (list->vector (reverse match-rules)) match-names sre)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(define (regexp-fold rx kons knil str . o)
  (let* ((rx (regexp rx))
         (finish (if (pair? o) (car o) (lambda (from md str acc) acc)))
         (o (if (pair? o) (cdr o) o))
         (start (string-start-arg str o))
         (end (string-end-arg str (if (pair? o) (cdr o) o))))
    (let lp ((i start)
             (from start)
             (acc knil))
      (cond
       ((and (string-cursor<? i end) (regexp-run-offsets #t rx str i end))
        => (lambda (md)
             (let ((j (regexp-match-ref md 1)))
               (lp (if (and (string-cursor=? i j) (string-cursor<? j end))
                       (string-cursor-next str j)
                       j)
                   j
                   (kons (string-offset->index str from) md str acc)))))
       (else
        (finish (string-offset->index str from) #f str acc))))))

(define (regexp-extract rx str . o)
  (apply regexp-fold
         rx
         (lambda (from md str a)
           (let ((s (regexp-match-submatch md 0)))
             (if (equal? s "") a (cons s a))))
         '()
         str
         (lambda (from md str a) (reverse a))
         o))

(define (regexp-split rx str . o)
  ;; start and end in indices passed to regexp-fold
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (regexp-fold
     rx
     (lambda (from md str a)
       (let ((i (regexp-match-submatch-start md 0)))
         (if (< from i) (cons (substring str from i) a) a)))
     '()
     str
     (lambda (from md str a)
       (reverse (if (< from end) (cons (substring str from end) a) a)))
     start
     end)))

(define (regexp-replace rx str subst . o)
  (let* ((start (if (and (pair? o) (car o)) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (end (if (and (pair? o) (car o)) (car o) (string-length str)))
         (o (if (pair? o) (cdr o) '()))
         (count (if (pair? o) (car o) 0)))
    (let lp ((i start) (count count))
      (let ((m (regexp-search rx str i end)))
        (cond
         ((not m) str)
         ((positive? count)
          (lp (regexp-match-submatch-end m 0) (- count 1)))
         (else
          (string-concatenate
           (cons
            (substring-cursor str
                              (string-index->offset str start)
                              (regexp-match-submatch-start m 0))
            (append
             (reverse (regexp-apply-match m str subst))
             (list (substring-cursor str
                                     (regexp-match-submatch-end m 0)
                                     (string-index->offset str end))))))))))))

(define (regexp-replace-all rx str subst . o)
  (regexp-fold
   rx
   (lambda (i m str acc)
     (let ((m-start (regexp-match-submatch-start m 0)))
       (append (regexp-apply-match m str subst)
               (if (>= i m-start)
                   acc
                   (cons (substring str i m-start) acc)))))
   '()
   str
   (lambda (i m str acc)
     (let ((end (string-length str)))
       (string-concatenate-reverse
        (if (>= i end)
            acc
            (cons (substring str i end) acc)))))))

(define (regexp-apply-match m str ls)
  (let lp ((ls ls) (res '()))
    (cond
     ((null? ls)
      res)
     ((not (pair? ls))
      (lp (list ls) res))
     ((integer? (car ls))
      (lp (cdr ls) (cons (or (regexp-match-submatch m (car ls)) "") res)))
     ((procedure? (car ls))
      (lp (cdr ls) (cons ((car ls) m) res)))
     ((symbol? (car ls))
      (case (car ls)
        ((pre)
         (lp (cdr ls)
             (cons (substring-cursor str 0 (regexp-match-submatch-start m 0))
                   res)))
        ((post)
         (lp (cdr ls)
             (cons (substring str
                              (regexp-match-submatch-end m 0)
                              (string-length str))
                   res)))
        (else
         (cond
          ((assq (car ls) (regexp-match-names m))
           => (lambda (x) (lp (cons (cdr x) (cdr ls)) res)))
          (else
           (error "unknown match replacement" (car ls)))))))
     (else
      (lp (cdr ls) (cons (car ls) res))))))

(define re:grapheme (regexp 'grapheme))

(define-library (chibi stty)
  (export stty with-stty with-raw-io
          get-terminal-width get-terminal-dimensions
          TCSANOW TCSADRAIN TCSAFLUSH)
  (import (chibi) (srfi 33) (srfi 69))
  (include-shared "stty")
  (include "stty.scm"))

(define-library (chibi match)
  (export match match-lambda match-lambda* match-let match-letrec match-let*)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base))))
  (include "match/match.scm"))
;; modules.scm -- module introspection utilities
;; Copyright (c) 2011-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Module introspection library.

(define (file->sexp-list file)
  (call-with-input-file file
    (lambda (in)
      (let lp ((res '()))
        (let ((x (read in)))
          (if (eof-object? x)
              (reverse res)
              (lp (cons x res))))))))

(define (module? x)
  (and (vector? x)
       (>= (vector-length x) 4)
       (or (list? (vector-ref x 0)) (not (vector-ref x 0)))))

(define (module-ast mod) (vector-ref mod 3))
(define (module-ast-set! mod x) (vector-set! mod 3 x))

(define (module-name mod)
  (if (pair? mod)
      (car mod)
      (let lp ((ls *modules*))
        (and (pair? ls)
             (if (eq? mod (cdar ls))
                 (caar ls)
                 (lp (cdr ls)))))))

(define (module-dir mod)
  (let ((name (module-name mod)))
    (if (member name '((chibi) (meta)))
        ""
        (module-name-prefix name))))

(define (module-metas mod metas)
  (let ((mod (if (module? mod) mod (find-module mod))))
    (let lp ((ls (module-meta-data mod)) (res '()))
      (cond
       ((not (pair? ls)) (reverse res))
       ((and (pair? (car ls)) (memq (caar ls) metas))
        (lp (cdr ls) (append (reverse (cdar ls)) res)))
       (else (lp (cdr ls) res))))))

(define (module-extract-declaration-files mod decls)
  (let* ((mod (if (module? mod) mod (find-module mod)))
         (dir (module-dir mod)))
    (define (module-file f)
      (find-module-file (string-append dir f)))
    (map module-file (reverse (module-metas mod decls)))))

(define (module-includes mod)
  (module-extract-declaration-files mod '(include)))

(define (module-include-library-declarations mod)
  (module-extract-declaration-files mod '(include-library-declarations)))

(define (module-shared-includes mod)
  (let* ((mod (if (module? mod) mod (find-module mod)))
         (dir (module-dir mod)))
    (define (module-file f)
      (find-module-file (string-append dir f ".stub")))
    (let lp ((ls (reverse (module-metas mod '(include-shared)))) (res '()))
      (cond ((null? ls) (reverse res))
            ((module-file (car ls)) => (lambda (x) (lp (cdr ls) (cons x res))))
            (else (lp (cdr ls) res))))))

(define (analyze-module-source name mod recursive?)
  (let ((env (module-env mod))
        (dir (module-dir mod)))
    (define (include-source file)
      (cond ((find-module-file (string-append dir file))
             => (lambda (x) (cons 'body (file->sexp-list x))))
            (else (error "couldn't find include" file))))
    (let lp ((ls (module-meta-data mod)) (res '()))
      (cond
       ((not (pair? ls))
        (reverse res))
       (else
        (case (and (pair? (car ls)) (caar ls))
          ((import import-immutable)
           (for-each
            (lambda (m)
              (let* ((mod2-name+imports (resolve-import m))
                     (mod2-name (car mod2-name+imports)))
                (if recursive?
                    (analyze-module mod2-name #t))))
            (cdar ls))
           (lp (cdr ls) res))
          ((include)
           (lp (append (map include-source (cdar ls)) (cdr ls)) res))
          ((body begin)
           (let lp2 ((ls2 (cdar ls)) (res res))
             (cond
              ((pair? ls2)
               (lp2 (cdr ls2) (cons (analyze (car ls2) env) res)))
              (else
               (lp (cdr ls) res)))))
          (else
           (lp (cdr ls) res))))))))

(define (analyze-module name . o)
  (let ((recursive? (and (pair? o) (car o)))
        (res (load-module name)))
    (if (not (module-ast res))
        (module-ast-set! res (analyze-module-source name res recursive?)))
    res))

(define (module-ref mod var-name . o)
  (let ((cell (env-cell (module-env (if (module? mod) mod (load-module mod)))
                        var-name)))
    (if cell
        (cdr cell)
        (if (pair? o) (car o) (error "no binding in module" mod var-name)))))

(define (module-contains? mod var-name)
  (and (env-cell (module-env (if (module? mod) mod (load-module mod))) var-name)
       #t))

(define (module-defines? name mod var-name)
  (if (not (module-ast mod))
      (module-ast-set! mod (analyze-module-source name mod #f)))
  (let lp ((ls (module-ast mod)))
    (and (pair? ls)
         (or (and (set? (car ls))
                  (eq? var-name (ref-name (set-var (car ls)))))
             (lp (cdr ls))))))

(define (containing-module x)
  (let lp1 ((ls (reverse *modules*)))
    (and (pair? ls)
         (let ((env (module-env (cdar ls))))
           (let lp2 ((e-ls (if (environment? env) (env-exports env) '())))
             (if (null? e-ls)
                 (lp1 (cdr ls))
                 (let ((cell (env-cell env (car e-ls))))
                   (if (and (eq? x (cdr cell))
                            (module-defines? (caar ls) (cdar ls) (car cell)))
                       (car ls)
                       (lp2 (cdr e-ls))))))))))

(define (procedure-analysis x . o)
  (let ((name (if (procedure? x) (procedure-name x) x))
        (mod (or (and (pair? o) (car o)) (containing-module x))))
    (and mod
         (let lp ((ls (module-ast (analyze-module (module-name mod)))))
           (and (pair? ls)
                (cond
                 ((and (set? (car ls))
                       (eq? name (ref-name (set-var (car ls)))))
                  (set-value (car ls)))
                 ((seq? (car ls))
                  (lp (append (seq-ls (car ls)) (cdr ls))))
                 (else
                  (lp (cdr ls)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; finding all available modules

(define (module-file? file)
  (let ((len (string-length file)))
    (and (> len 4) (equal? ".sld" (substring file (- len 4))))))

(define (read-static-modules file)
  (protect (exn (else '()))
    (call-with-input-file file
      (lambda (in)
        (let lp ((res '()))
          (let ((expr (read in)))
            (cond
             ((eof-object? expr)
              res)
             ((and (pair? expr) (eq? 'define-library (car expr)))
              (let ((name (cadr expr))
                    (exports (cond ((assq 'export (cddr expr)) => cdr)
                                   (else '()))))
                (lp (cons (cons name (make-module exports #f #f)) res))))
             (else
              (lp res)))))))))

(define no-module-depth-limit 2)

(define (available-modules-in-directory dir depth res)
  (call-with-values
      (lambda ()
        (partition file-directory?
                   (map (lambda (f) (string-append dir "/" f))
                        (remove (lambda (f) (member f '("." "..")))
                                (directory-files dir)))))
    (lambda (dirs files)
      (let ((mods (append-map read-static-modules
                              (filter module-file? files))))
        (if (and (null? mods) (>= depth no-module-depth-limit))
            res
            (let ((depth (if (pair? mods) 0 (+ 1 depth))))
              (let lp ((ls dirs) (res (append mods res)))
                (if (null? ls)
                    res
                    (lp (cdr ls)
                        (available-modules-in-directory (car ls) depth res)
                        )))))))))

(define (available-modules)
  (let lp ((ls (current-module-path)) (res *modules*))
    (if (null? ls)
        res
        (lp (cdr ls)
            (available-modules-in-directory (car ls) 0 res)))))

(define (modules-exporting-identifier name)
  (let lp ((ls (available-modules))
           (res '()))
    (cond
     ((null? ls) (reverse res))
     ((and (memq name (module-exports (cdar ls)))
           (not (assoc (caar ls) res)))
      (lp (cdr ls) (cons (car ls) res)))
     (else (lp (cdr ls) res)))))

;;> \section{Additional accessors}

(define (bytevector-u16-ref-le str i)
  (+ (bytevector-u8-ref str i)
     (arithmetic-shift (bytevector-u8-ref str (+ i 1)) 8)))

(define (bytevector-u16-ref-be str i)
  (+ (arithmetic-shift (bytevector-u8-ref str i) 8)
     (bytevector-u8-ref str (+ i 1))))

(define (bytevector-u32-ref-le str i)
  (+ (bytevector-u8-ref str i)
     (arithmetic-shift (bytevector-u8-ref str (+ i 1)) 8)
     (arithmetic-shift (bytevector-u8-ref str (+ i 2)) 16)
     (arithmetic-shift (bytevector-u8-ref str (+ i 3)) 24)))

(define (bytevector-u32-ref-be str i)
  (+ (arithmetic-shift (bytevector-u8-ref str i) 24)
     (arithmetic-shift (bytevector-u8-ref str (+ i 1)) 16)
     (arithmetic-shift (bytevector-u8-ref str (+ i 2)) 8)
     (bytevector-u8-ref str (+ i 3))))

;;> \section{Integer conversion}

(define (integer->bytevector n)
  (cond
   ((zero? n)
    (make-bytevector 1 0))
   ((negative? n)
    (error "can't convert a negative integer to bytevector" n))
   (else
    (let lp ((n n) (res '()))
      (if (zero? n)
          (let* ((len (length res))
                 (bv (make-bytevector len 0)))
            (do ((i 0 (+ i 1))
                 (ls res (cdr ls)))
                ((= i len) bv)
              (bytevector-u8-set! bv i (car ls))))
          (lp (quotient n 256) (cons (remainder n 256) res)))))))

(define (bytevector->integer bv)
  (let ((len (bytevector-length bv)))
    (let lp ((i 0) (n 0))
      (if (>= i len)
          n
          (lp (+ i 1)
              (+ (arithmetic-shift n 8)
                 (bytevector-u8-ref bv i)))))))

(define (bytevector-pad-left bv len)
  (let ((diff (- len (bytevector-length bv))))
    (if (positive? diff)
        (bytevector-append bv (make-bytevector diff 0))
        bv)))

;;> \section{Hex string conversion}

;;> Big-endian conversion, guaranteed padded to even length.

(define (integer->hex-string n)
  (let* ((res (number->string n 16))
         (len (string-length res)))
    (if (even? len)
        res
        (string-append "0" res))))

(define (hex-string->integer str)
  (string->number str 16))

(define (bytevector->hex-string bv)
  (let ((out (open-output-string))
        (len (bytevector-length bv)))
    (let lp ((i 0))
      (cond
       ((>= i len)
        (get-output-string out))
       (else
        (write-string (integer->hex-string (bytevector-u8-ref bv i)) out)
        (lp (+ i 1)))))))

(define (hex-string->bytevector str)
  (integer->bytevector (hex-string->integer str)))
;;;; match.scm -- portable hygienic pattern matcher -*- coding: utf-8 -*-
;;
;; This code is written by Alex Shinn and placed in the
;; Public Domain.  All warranties are disclaimed.

;;> \example-import[(srfi 9)]

;;> A portable hygienic pattern matcher.

;;> This is a full superset of the popular \hyperlink[
;;> "http://www.cs.indiana.edu/scheme-repository/code.match.html"]{match}
;;> package by Andrew Wright, written in fully portable \scheme{syntax-rules}
;;> and thus preserving hygiene.

;;> The most notable extensions are the ability to use \emph{non-linear}
;;> patterns - patterns in which the same identifier occurs multiple
;;> times, tail patterns after ellipsis, and the experimental tree patterns.

;;> \section{Patterns}

;;> Patterns are written to look like the printed representation of
;;> the objects they match.  The basic usage is

;;> \scheme{(match expr (pat body ...) ...)}

;;> where the result of \var{expr} is matched against each pattern in
;;> turn, and the corresponding body is evaluated for the first to
;;> succeed.  Thus, a list of three elements matches a list of three
;;> elements.

;;> \example{(let ((ls (list 1 2 3))) (match ls ((1 2 3) #t)))}

;;> If no patterns match an error is signalled.

;;> Identifiers will match anything, and make the corresponding
;;> binding available in the body.

;;> \example{(match (list 1 2 3) ((a b c) b))}

;;> If the same identifier occurs multiple times, the first instance
;;> will match anything, but subsequent instances must match a value
;;> which is \scheme{equal?} to the first.

;;> \example{(match (list 1 2 1) ((a a b) 1) ((a b a) 2))}

;;> The special identifier \scheme{_} matches anything, no matter how
;;> many times it is used, and does not bind the result in the body.

;;> \example{(match (list 1 2 1) ((_ _ b) 1) ((a b a) 2))}

;;> To match a literal identifier (or list or any other literal), use
;;> \scheme{quote}.

;;> \example{(match 'a ('b 1) ('a 2))}

;;> Analogous to its normal usage in scheme, \scheme{quasiquote} can
;;> be used to quote a mostly literally matching object with selected
;;> parts unquoted.

;;> \example|{(match (list 1 2 3) (`(1 ,b ,c) (list b c)))}|

;;> Often you want to match any number of a repeated pattern.  Inside
;;> a list pattern you can append \scheme{...} after an element to
;;> match zero or more of that pattern (like a regexp Kleene star).

;;> \example{(match (list 1 2) ((1 2 3 ...) #t))}
;;> \example{(match (list 1 2 3) ((1 2 3 ...) #t))}
;;> \example{(match (list 1 2 3 3 3) ((1 2 3 ...) #t))}

;;> Pattern variables matched inside the repeated pattern are bound to
;;> a list of each matching instance in the body.

;;> \example{(match (list 1 2) ((a b c ...) c))}
;;> \example{(match (list 1 2 3) ((a b c ...) c))}
;;> \example{(match (list 1 2 3 4 5) ((a b c ...) c))}

;;> More than one \scheme{...} may not be used in the same list, since
;;> this would require exponential backtracking in the general case.
;;> However, \scheme{...} need not be the final element in the list,
;;> and may be succeeded by a fixed number of patterns.

;;> \example{(match (list 1 2 3 4) ((a b c ... d e) c))}
;;> \example{(match (list 1 2 3 4 5) ((a b c ... d e) c))}
;;> \example{(match (list 1 2 3 4 5 6 7) ((a b c ... d e) c))}

;;> \scheme{___} is provided as an alias for \scheme{...} when it is
;;> inconvenient to use the ellipsis (as in a syntax-rules template).

;;> The \scheme{..1} syntax is exactly like the \scheme{...} except
;;> that it matches one or more repetitions (like a regexp "+").

;;> \example{(match (list 1 2) ((a b c ..1) c))}
;;> \example{(match (list 1 2 3) ((a b c ..1) c))}

;;> The boolean operators \scheme{and}, \scheme{or} and \scheme{not}
;;> can be used to group and negate patterns analogously to their
;;> Scheme counterparts.

;;> The \scheme{and} operator ensures that all subpatterns match.
;;> This operator is often used with the idiom \scheme{(and x pat)} to
;;> bind \var{x} to the entire value that matches \var{pat}
;;> (c.f. "as-patterns" in ML or Haskell).  Another common use is in
;;> conjunction with \scheme{not} patterns to match a general case
;;> with certain exceptions.

;;> \example{(match 1 ((and) #t))}
;;> \example{(match 1 ((and x) x))}
;;> \example{(match 1 ((and x 1) x))}

;;> The \scheme{or} operator ensures that at least one subpattern
;;> matches.  If the same identifier occurs in different subpatterns,
;;> it is matched independently.  All identifiers from all subpatterns
;;> are bound if the \scheme{or} operator matches, but the binding is
;;> only defined for identifiers from the subpattern which matched.

;;> \example{(match 1 ((or) #t) (else #f))}
;;> \example{(match 1 ((or x) x))}
;;> \example{(match 1 ((or x 2) x))}

;;> The \scheme{not} operator succeeds if the given pattern doesn't
;;> match.  None of the identifiers used are available in the body.

;;> \example{(match 1 ((not 2) #t))}

;;> The more general operator \scheme{?} can be used to provide a
;;> predicate.  The usage is \scheme{(? predicate pat ...)} where
;;> \var{predicate} is a Scheme expression evaluating to a predicate
;;> called on the value to match, and any optional patterns after the
;;> predicate are then matched as in an \scheme{and} pattern.

;;> \example{(match 1 ((? odd? x) x))}

;;> The field operator \scheme{=} is used to extract an arbitrary
;;> field and match against it.  It is useful for more complex or
;;> conditional destructuring that can't be more directly expressed in
;;> the pattern syntax.  The usage is \scheme{(= field pat)}, where
;;> \var{field} can be any expression, and should result in a
;;> procedure of one argument, which is applied to the value to match
;;> to generate a new value to match against \var{pat}.

;;> Thus the pattern \scheme{(and (= car x) (= cdr y))} is equivalent
;;> to \scheme{(x . y)}, except it will result in an immediate error
;;> if the value isn't a pair.

;;> \example{(match '(1 . 2) ((= car x) x))}
;;> \example{(match 4 ((= square x) x))}

;;> The record operator \scheme{$} is used as a concise way to match
;;> records defined by SRFI-9 (or SRFI-99).  The usage is
;;> \scheme{($ rtd field ...)}, where \var{rtd} should be the record
;;> type descriptor specified as the first argument to
;;> \scheme{define-record-type}, and each \var{field} is a subpattern
;;> matched against the fields of the record in order.  Not all fields
;;> must be present.

;;> \example{
;;> (let ()
;;>   (define-record-type employee
;;>     (make-employee name title)
;;>     employee?
;;>     (name get-name)
;;>     (title get-title))
;;>   (match (make-employee "Bob" "Doctor")
;;>     (($ employee n t) (list t n))))
;;> }

;;> For records with more fields it can be helpful to match them by
;;> name rather than position.  For this you can use the \scheme{@}
;;> operator, originally a Gauche extension:

;;> \example{
;;> (let ()
;;>   (define-record-type employee
;;>     (make-employee name title)
;;>     employee?
;;>     (name get-name)
;;>     (title get-title))
;;>   (match (make-employee "Bob" "Doctor")
;;>     ((@ employee (title t) (name n)) (list t n))))
;;> }

;;> The \scheme{set!} and \scheme{get!} operators are used to bind an
;;> identifier to the setter and getter of a field, respectively.  The
;;> setter is a procedure of one argument, which mutates the field to
;;> that argument.  The getter is a procedure of no arguments which
;;> returns the current value of the field.

;;> \example{(let ((x (cons 1 2))) (match x ((1 . (set! s)) (s 3) x)))}
;;> \example{(match '(1 . 2) ((1 . (get! g)) (g)))}

;;> The new operator \scheme{***} can be used to search a tree for
;;> subpatterns.  A pattern of the form \scheme{(x *** y)} represents
;;> the subpattern \var{y} located somewhere in a tree where the path
;;> from the current object to \var{y} can be seen as a list of the
;;> form \scheme{(x ...)}.  \var{y} can immediately match the current
;;> object in which case the path is the empty list.  In a sense it's
;;> a 2-dimensional version of the \scheme{...} pattern.

;;> As a common case the pattern \scheme{(_ *** y)} can be used to
;;> search for \var{y} anywhere in a tree, regardless of the path
;;> used.

;;> \example{(match '(a (a (a b))) ((x *** 'b) x))}
;;> \example{(match '(a (b) (c (d e) (f g))) ((x *** 'g) x))}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Notes

;; The implementation is a simple generative pattern matcher - each
;; pattern is expanded into the required tests, calling a failure
;; continuation if the tests fail.  This makes the logic easy to
;; follow and extend, but produces sub-optimal code in cases where you
;; have many similar clauses due to repeating the same tests.
;; Nonetheless a smart compiler should be able to remove the redundant
;; tests.  For MATCH-LET and DESTRUCTURING-BIND type uses there is no
;; performance hit.

;; The original version was written on 2006/11/29 and described in the
;; following Usenet post:
;;   http://groups.google.com/group/comp.lang.scheme/msg/0941234de7112ffd
;; and is still available at
;;   http://synthcode.com/scheme/match-simple.scm
;; It's just 80 lines for the core MATCH, and an extra 40 lines for
;; MATCH-LET, MATCH-LAMBDA and other syntactic sugar.
;;
;; A variant of this file which uses COND-EXPAND in a few places for
;; performance can be found at
;;   http://synthcode.com/scheme/match-cond-expand.scm
;;
;; 2014/11/24 - adding Gauche's `@' pattern for named record field matching
;; 2012/12/26 - wrapping match-let&co body in lexical closure
;; 2012/11/28 - fixing typo s/vetor/vector in largely unused set! code
;; 2012/05/23 - fixing combinatorial explosion of code in certain or patterns
;; 2011/09/25 - fixing bug when directly matching an identifier repeated in
;;              the pattern (thanks to Stefan Israelsson Tampe)
;; 2011/01/27 - fixing bug when matching tail patterns against improper lists
;; 2010/09/26 - adding `..1' patterns (thanks to Ludovic Courts)
;; 2010/09/07 - fixing identifier extraction in some `...' and `***' patterns
;; 2009/11/25 - adding `***' tree search patterns
;; 2008/03/20 - fixing bug where (a ...) matched non-lists
;; 2008/03/15 - removing redundant check in vector patterns
;; 2008/03/06 - you can use `...' portably now (thanks to Taylor Campbell)
;; 2007/09/04 - fixing quasiquote patterns
;; 2007/07/21 - allowing ellipsis patterns in non-final list positions
;; 2007/04/10 - fixing potential hygiene issue in match-check-ellipsis
;;              (thanks to Taylor Campbell)
;; 2007/04/08 - clean up, commenting
;; 2006/12/24 - bugfixes
;; 2006/12/01 - non-linear patterns, shared variables in OR, get!/set!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; force compile-time syntax errors with useful messages

(define-syntax match-syntax-error
  (syntax-rules ()
    ((_) (match-syntax-error "invalid match-syntax-error usage"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Syntax}

;;> \macro{(match expr (pattern . body) ...)\br{}
;;> (match expr (pattern (=> failure) . body) ...)}

;;> The result of \var{expr} is matched against each \var{pattern} in
;;> turn, according to the pattern rules described in the previous
;;> section, until the the first \var{pattern} matches.  When a match is
;;> found, the corresponding \var{body}s are evaluated in order,
;;> and the result of the last expression is returned as the result
;;> of the entire \scheme{match}.  If a \var{failure} is provided,
;;> then it is bound to a procedure of no arguments which continues,
;;> processing at the next \var{pattern}.  If no \var{pattern} matches,
;;> an error is signalled.

;; The basic interface.  MATCH just performs some basic syntax
;; validation, binds the match expression to a temporary variable `v',
;; and passes it on to MATCH-NEXT.  It's a constant throughout the
;; code below that the binding `v' is a direct variable reference, not
;; an expression.

(define-syntax match
  (syntax-rules ()
    ((match)
     (match-syntax-error "missing match expression"))
    ((match atom)
     (match-syntax-error "no match clauses"))
    ((match (app ...) (pat . body) ...)
     (let ((v (app ...)))
       (match-next v ((app ...) (set! (app ...))) (pat . body) ...)))
    ((match #(vec ...) (pat . body) ...)
     (let ((v #(vec ...)))
       (match-next v (v (set! v)) (pat . body) ...)))
    ((match atom (pat . body) ...)
     (let ((v atom))
       (match-next v (atom (set! atom)) (pat . body) ...)))
    ))

;; MATCH-NEXT passes each clause to MATCH-ONE in turn with its failure
;; thunk, which is expanded by recursing MATCH-NEXT on the remaining
;; clauses.  `g+s' is a list of two elements, the get! and set!
;; expressions respectively.

(define-syntax match-next
  (syntax-rules (=>)
    ;; no more clauses, the match failed
    ((match-next v g+s)
     (error 'match "no matching pattern"))
    ;; named failure continuation
    ((match-next v g+s (pat (=> failure) . body) . rest)
     (let ((failure (lambda () (match-next v g+s . rest))))
       ;; match-one analyzes the pattern for us
       (match-one v pat g+s (match-drop-ids (begin . body)) (failure) ())))
    ;; anonymous failure continuation, give it a dummy name
    ((match-next v g+s (pat . body) . rest)
     (match-next v g+s (pat (=> failure) . body) . rest))))

;; MATCH-ONE first checks for ellipsis patterns, otherwise passes on to
;; MATCH-TWO.

(define-syntax match-one
  (syntax-rules ()
    ;; If it's a list of two or more values, check to see if the
    ;; second one is an ellipsis and handle accordingly, otherwise go
    ;; to MATCH-TWO.
    ((match-one v (p q . r) g+s sk fk i)
     (match-check-ellipsis
      q
      (match-extract-vars p (match-gen-ellipsis v p r  g+s sk fk i) i ())
      (match-two v (p q . r) g+s sk fk i)))
    ;; Go directly to MATCH-TWO.
    ((match-one . x)
     (match-two . x))))

;; This is the guts of the pattern matcher.  We are passed a lot of
;; information in the form:
;;
;;   (match-two var pattern getter setter success-k fail-k (ids ...))
;;
;; usually abbreviated
;;
;;   (match-two v p g+s sk fk i)
;;
;; where VAR is the symbol name of the current variable we are
;; matching, PATTERN is the current pattern, getter and setter are the
;; corresponding accessors (e.g. CAR and SET-CAR! of the pair holding
;; VAR), SUCCESS-K is the success continuation, FAIL-K is the failure
;; continuation (which is just a thunk call and is thus safe to expand
;; multiple times) and IDS are the list of identifiers bound in the
;; pattern so far.

(define-syntax match-two
  (syntax-rules (_ ___ ..1 *** quote quasiquote ? $ struct @ object = and or not set! get!)
    ((match-two v () g+s (sk ...) fk i)
     (if (null? v) (sk ... i) fk))
    ((match-two v (quote p) g+s (sk ...) fk i)
     (if (equal? v 'p) (sk ... i) fk))
    ((match-two v (quasiquote p) . x)
     (match-quasiquote v p . x))
    ((match-two v (and) g+s (sk ...) fk i) (sk ... i))
    ((match-two v (and p q ...) g+s sk fk i)
     (match-one v p g+s (match-one v (and q ...) g+s sk fk) fk i))
    ((match-two v (or) g+s sk fk i) fk)
    ((match-two v (or p) . x)
     (match-one v p . x))
    ((match-two v (or p ...) g+s sk fk i)
     (match-extract-vars (or p ...) (match-gen-or v (p ...) g+s sk fk i) i ()))
    ((match-two v (not p) g+s (sk ...) fk i)
     (match-one v p g+s (match-drop-ids fk) (sk ... i) i))
    ((match-two v (get! getter) (g s) (sk ...) fk i)
     (let ((getter (lambda () g))) (sk ... i)))
    ((match-two v (set! setter) (g (s ...)) (sk ...) fk i)
     (let ((setter (lambda (x) (s ... x)))) (sk ... i)))
    ((match-two v (? pred . p) g+s sk fk i)
     (if (pred v) (match-one v (and . p) g+s sk fk i) fk))
    ((match-two v (= proc p) . x)
     (let ((w (proc v))) (match-one w p . x)))
    ((match-two v (p ___ . r) g+s sk fk i)
     (match-extract-vars p (match-gen-ellipsis v p r g+s sk fk i) i ()))
    ((match-two v (p) g+s sk fk i)
     (if (and (pair? v) (null? (cdr v)))
         (let ((w (car v)))
           (match-one w p ((car v) (set-car! v)) sk fk i))
         fk))
    ((match-two v (p *** q) g+s sk fk i)
     (match-extract-vars p (match-gen-search v p q g+s sk fk i) i ()))
    ((match-two v (p *** . q) g+s sk fk i)
     (match-syntax-error "invalid use of ***" (p *** . q)))
    ((match-two v (p ..1) g+s sk fk i)
     (if (pair? v)
         (match-one v (p ___) g+s sk fk i)
         fk))
    ((match-two v ($ rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-refs v rec 0 (p ...) g+s sk fk i)
         fk))
    ((match-two v (struct rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-refs v rec 0 (p ...) g+s sk fk i)
         fk))
    ((match-two v (@ rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-named-refs v rec (p ...) g+s sk fk i)
         fk))
    ((match-two v (object rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-named-refs v rec (p ...) g+s sk fk i)
         fk))
    ((match-two v (p . q) g+s sk fk i)
     (if (pair? v)
         (let ((w (car v)) (x (cdr v)))
           (match-one w p ((car v) (set-car! v))
                      (match-one x q ((cdr v) (set-cdr! v)) sk fk)
                      fk
                      i))
         fk))
    ((match-two v #(p ...) g+s . x)
     (match-vector v 0 () (p ...) . x))
    ((match-two v _ g+s (sk ...) fk i) (sk ... i))
    ;; Not a pair or vector or special literal, test to see if it's a
    ;; new symbol, in which case we just bind it, or if it's an
    ;; already bound symbol or some other literal, in which case we
    ;; compare it with EQUAL?.
    ((match-two v x g+s (sk ...) fk (id ...))
     (let-syntax
         ((new-sym?
           (syntax-rules (id ...)
             ((new-sym? x sk2 fk2) sk2)
             ((new-sym? y sk2 fk2) fk2))))
       (new-sym? random-sym-to-match
                 (let ((x v)) (sk ... (id ... x)))
                 (if (equal? v x) (sk ... (id ...)) fk))))
    ))

;; QUASIQUOTE patterns

(define-syntax match-quasiquote
  (syntax-rules (unquote unquote-splicing quasiquote)
    ((_ v (unquote p) g+s sk fk i)
     (match-one v p g+s sk fk i))
    ((_ v ((unquote-splicing p) . rest) g+s sk fk i)
     (if (pair? v)
       (match-one v
                  (p . tmp)
                  (match-quasiquote tmp rest g+s sk fk)
                  fk
                  i)
       fk))
    ((_ v (quasiquote p) g+s sk fk i . depth)
     (match-quasiquote v p g+s sk fk i #f . depth))
    ((_ v (unquote p) g+s sk fk i x . depth)
     (match-quasiquote v p g+s sk fk i . depth))
    ((_ v (unquote-splicing p) g+s sk fk i x . depth)
     (match-quasiquote v p g+s sk fk i . depth))
    ((_ v (p . q) g+s sk fk i . depth)
     (if (pair? v)
       (let ((w (car v)) (x (cdr v)))
         (match-quasiquote
          w p g+s
          (match-quasiquote-step x q g+s sk fk depth)
          fk i . depth))
       fk))
    ((_ v #(elt ...) g+s sk fk i . depth)
     (if (vector? v)
       (let ((ls (vector->list v)))
         (match-quasiquote ls (elt ...) g+s sk fk i . depth))
       fk))
    ((_ v x g+s sk fk i . depth)
     (match-one v 'x g+s sk fk i))))

(define-syntax match-quasiquote-step
  (syntax-rules ()
    ((match-quasiquote-step x q g+s sk fk depth i)
     (match-quasiquote x q g+s sk fk i . depth))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

;; Takes two values and just expands into the first.
(define-syntax match-drop-ids
  (syntax-rules ()
    ((_ expr ids ...) expr)))

(define-syntax match-tuck-ids
  (syntax-rules ()
    ((_ (letish args (expr ...)) ids ...)
     (letish args (expr ... ids ...)))))

(define-syntax match-drop-first-arg
  (syntax-rules ()
    ((_ arg expr) expr)))

;; To expand an OR group we try each clause in succession, passing the
;; first that succeeds to the success continuation.  On failure for
;; any clause, we just try the next clause, finally resorting to the
;; failure continuation fk if all clauses fail.  The only trick is
;; that we want to unify the identifiers, so that the success
;; continuation can refer to a variable from any of the OR clauses.

(define-syntax match-gen-or
  (syntax-rules ()
    ((_ v p g+s (sk ...) fk (i ...) ((id id-ls) ...))
     (let ((sk2 (lambda (id ...) (sk ... (i ... id ...)))))
       (match-gen-or-step v p g+s (match-drop-ids (sk2 id ...)) fk (i ...))))))

(define-syntax match-gen-or-step
  (syntax-rules ()
    ((_ v () g+s sk fk . x)
     ;; no OR clauses, call the failure continuation
     fk)
    ((_ v (p) . x)
     ;; last (or only) OR clause, just expand normally
     (match-one v p . x))
    ((_ v (p . q) g+s sk fk i)
     ;; match one and try the remaining on failure
     (let ((fk2 (lambda () (match-gen-or-step v q g+s sk fk i))))
       (match-one v p g+s sk (fk2) i)))
    ))

;; We match a pattern (p ...) by matching the pattern p in a loop on
;; each element of the variable, accumulating the bound ids into lists.

;; Look at the body of the simple case - it's just a named let loop,
;; matching each element in turn to the same pattern.  The only trick
;; is that we want to keep track of the lists of each extracted id, so
;; when the loop recurses we cons the ids onto their respective list
;; variables, and on success we bind the ids (what the user input and
;; expects to see in the success body) to the reversed accumulated
;; list IDs.

(define-syntax match-gen-ellipsis
  (syntax-rules ()
    ((_ v p () g+s (sk ...) fk i ((id id-ls) ...))
     (match-check-identifier p
       ;; simplest case equivalent to (p ...), just bind the list
       (let ((p v))
         (if (list? p)
             (sk ... i)
             fk))
       ;; simple case, match all elements of the list
       (let loop ((ls v) (id-ls '()) ...)
         (cond
           ((null? ls)
            (let ((id (reverse id-ls)) ...) (sk ... i)))
           ((pair? ls)
            (let ((w (car ls)))
              (match-one w p ((car ls) (set-car! ls))
                         (match-drop-ids (loop (cdr ls) (cons id id-ls) ...))
                         fk i)))
           (else
            fk)))))
    ((_ v p r g+s (sk ...) fk i ((id id-ls) ...))
     ;; general case, trailing patterns to match, keep track of the
     ;; remaining list length so we don't need any backtracking
     (match-verify-no-ellipsis
      r
      (let* ((tail-len (length 'r))
             (ls v)
             (len (and (list? ls) (length ls))))
        (if (or (not len) (< len tail-len))
            fk
            (let loop ((ls ls) (n len) (id-ls '()) ...)
              (cond
                ((= n tail-len)
                 (let ((id (reverse id-ls)) ...)
                   (match-one ls r (#f #f) (sk ...) fk i)))
                ((pair? ls)
                 (let ((w (car ls)))
                   (match-one w p ((car ls) (set-car! ls))
                              (match-drop-ids
                               (loop (cdr ls) (- n 1) (cons id id-ls) ...))
                              fk
                              i)))
                (else
                 fk)))))))))

;; This is just a safety check.  Although unlike syntax-rules we allow
;; trailing patterns after an ellipsis, we explicitly disable multiple
;; ellipsis at the same level.  This is because in the general case
;; such patterns are exponential in the number of ellipsis, and we
;; don't want to make it easy to construct very expensive operations
;; with simple looking patterns.  For example, it would be O(n^2) for
;; patterns like (a ... b ...) because we must consider every trailing
;; element for every possible break for the leading "a ...".

(define-syntax match-verify-no-ellipsis
  (syntax-rules ()
    ((_ (x . y) sk)
     (match-check-ellipsis
      x
      (match-syntax-error
       "multiple ellipsis patterns not allowed at same level")
      (match-verify-no-ellipsis y sk)))
    ((_ () sk)
     sk)
    ((_ x sk)
     (match-syntax-error "dotted tail not allowed after ellipsis" x))))

;; To implement the tree search, we use two recursive procedures.  TRY
;; attempts to match Y once, and on success it calls the normal SK on
;; the accumulated list ids as in MATCH-GEN-ELLIPSIS.  On failure, we
;; call NEXT which first checks if the current value is a list
;; beginning with X, then calls TRY on each remaining element of the
;; list.  Since TRY will recursively call NEXT again on failure, this
;; effects a full depth-first search.
;;
;; The failure continuation throughout is a jump to the next step in
;; the tree search, initialized with the original failure continuation
;; FK.

(define-syntax match-gen-search
  (syntax-rules ()
    ((match-gen-search v p q g+s sk fk i ((id id-ls) ...))
     (letrec ((try (lambda (w fail id-ls ...)
                     (match-one w q g+s
                                (match-tuck-ids
                                 (let ((id (reverse id-ls)) ...)
                                   sk))
                                (next w fail id-ls ...) i)))
              (next (lambda (w fail id-ls ...)
                      (if (not (pair? w))
                          (fail)
                          (let ((u (car w)))
                            (match-one
                             u p ((car w) (set-car! w))
                             (match-drop-ids
                              ;; accumulate the head variables from
                              ;; the p pattern, and loop over the tail
                              (let ((id-ls (cons id id-ls)) ...)
                                (let lp ((ls (cdr w)))
                                  (if (pair? ls)
                                      (try (car ls)
                                           (lambda () (lp (cdr ls)))
                                           id-ls ...)
                                      (fail)))))
                             (fail) i))))))
       ;; the initial id-ls binding here is a dummy to get the right
       ;; number of '()s
       (let ((id-ls '()) ...)
         (try v (lambda () fk) id-ls ...))))))

;; Vector patterns are just more of the same, with the slight
;; exception that we pass around the current vector index being
;; matched.

(define-syntax match-vector
  (syntax-rules (___)
    ((_ v n pats (p q) . x)
     (match-check-ellipsis q
                          (match-gen-vector-ellipsis v n pats p . x)
                          (match-vector-two v n pats (p q) . x)))
    ((_ v n pats (p ___) sk fk i)
     (match-gen-vector-ellipsis v n pats p sk fk i))
    ((_ . x)
     (match-vector-two . x))))

;; Check the exact vector length, then check each element in turn.

(define-syntax match-vector-two
  (syntax-rules ()
    ((_ v n ((pat index) ...) () sk fk i)
     (if (vector? v)
         (let ((len (vector-length v)))
           (if (= len n)
               (match-vector-step v ((pat index) ...) sk fk i)
               fk))
         fk))
    ((_ v n (pats ...) (p . q) . x)
     (match-vector v (+ n 1) (pats ... (p n)) q . x))))

(define-syntax match-vector-step
  (syntax-rules ()
    ((_ v () (sk ...) fk i) (sk ... i))
    ((_ v ((pat index) . rest) sk fk i)
     (let ((w (vector-ref v index)))
       (match-one w pat ((vector-ref v index) (vector-set! v index))
                  (match-vector-step v rest sk fk)
                  fk i)))))

;; With a vector ellipsis pattern we first check to see if the vector
;; length is at least the required length.

(define-syntax match-gen-vector-ellipsis
  (syntax-rules ()
    ((_ v n ((pat index) ...) p sk fk i)
     (if (vector? v)
       (let ((len (vector-length v)))
         (if (>= len n)
           (match-vector-step v ((pat index) ...)
                              (match-vector-tail v p n len sk fk)
                              fk i)
           fk))
       fk))))

(define-syntax match-vector-tail
  (syntax-rules ()
    ((_ v p n len sk fk i)
     (match-extract-vars p (match-vector-tail-two v p n len sk fk i) i ()))))

(define-syntax match-vector-tail-two
  (syntax-rules ()
    ((_ v p n len (sk ...) fk i ((id id-ls) ...))
     (let loop ((j n) (id-ls '()) ...)
       (if (>= j len)
         (let ((id (reverse id-ls)) ...) (sk ... i))
         (let ((w (vector-ref v j)))
           (match-one w p ((vector-ref v j) (vector-set! v j))
                      (match-drop-ids (loop (+ j 1) (cons id id-ls) ...))
                      fk i)))))))

(define-syntax match-record-refs
  (syntax-rules ()
    ((_ v rec n (p . q) g+s sk fk i)
     (let ((w (slot-ref rec v n)))
       (match-one w p ((slot-ref rec v n) (slot-set! rec v n))
                  (match-record-refs v rec (+ n 1) q g+s sk fk) fk i)))
    ((_ v rec n () g+s (sk ...) fk i)
     (sk ... i))))

(define-syntax match-record-named-refs
  (syntax-rules ()
    ((_ v rec ((f p) . q) g+s sk fk i)
     (let ((w (slot-ref rec v 'f)))
       (match-one w p ((slot-ref rec v 'f) (slot-set! rec v 'f))
                  (match-record-named-refs v rec q g+s sk fk) fk i)))
    ((_ v rec () g+s (sk ...) fk i)
     (sk ... i))))

;; Extract all identifiers in a pattern.  A little more complicated
;; than just looking for symbols, we need to ignore special keywords
;; and non-pattern forms (such as the predicate expression in ?
;; patterns), and also ignore previously bound identifiers.
;;
;; Calls the continuation with all new vars as a list of the form
;; ((orig-var tmp-name) ...), where tmp-name can be used to uniquely
;; pair with the original variable (e.g. it's used in the ellipsis
;; generation for list variables).
;;
;; (match-extract-vars pattern continuation (ids ...) (new-vars ...))

(define-syntax match-extract-vars
  (syntax-rules (_ ___ ..1 *** ? $ struct @ object = quote quasiquote and or not get! set!)
    ((match-extract-vars (? pred . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars ($ rec . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (struct rec . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (@ rec (f p) ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars (object rec (f p) ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars (= proc p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (quote x) (k ...) i v)
     (k ... v))
    ((match-extract-vars (quasiquote x) k i v)
     (match-extract-quasiquote-vars x k i v (#t)))
    ((match-extract-vars (and . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (or . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (not . p) . x)
     (match-extract-vars p . x))
    ;; A non-keyword pair, expand the CAR with a continuation to
    ;; expand the CDR.
    ((match-extract-vars (p q . r) k i v)
     (match-check-ellipsis
      q
      (match-extract-vars (p . r) k i v)
      (match-extract-vars p (match-extract-vars-step (q . r) k i v) i ())))
    ((match-extract-vars (p . q) k i v)
     (match-extract-vars p (match-extract-vars-step q k i v) i ()))
    ((match-extract-vars #(p ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars _ (k ...) i v)    (k ... v))
    ((match-extract-vars ___ (k ...) i v)  (k ... v))
    ((match-extract-vars *** (k ...) i v)  (k ... v))
    ((match-extract-vars ..1 (k ...) i v)  (k ... v))
    ;; This is the main part, the only place where we might add a new
    ;; var if it's an unbound symbol.
    ((match-extract-vars p (k ...) (i ...) v)
     (let-syntax
         ((new-sym?
           (syntax-rules (i ...)
             ((new-sym? p sk fk) sk)
             ((new-sym? any sk fk) fk))))
       (new-sym? random-sym-to-match
                 (k ... ((p p-ls) . v))
                 (k ... v))))
    ))

;; Stepper used in the above so it can expand the CAR and CDR
;; separately.

(define-syntax match-extract-vars-step
  (syntax-rules ()
    ((_ p k i v ((v2 v2-ls) ...))
     (match-extract-vars p k (v2 ... . i) ((v2 v2-ls) ... . v)))
    ))

(define-syntax match-extract-quasiquote-vars
  (syntax-rules (quasiquote unquote unquote-splicing)
    ((match-extract-quasiquote-vars (quasiquote x) k i v d)
     (match-extract-quasiquote-vars x k i v (#t . d)))
    ((match-extract-quasiquote-vars (unquote-splicing x) k i v d)
     (match-extract-quasiquote-vars (unquote x) k i v d))
    ((match-extract-quasiquote-vars (unquote x) k i v (#t))
     (match-extract-vars x k i v))
    ((match-extract-quasiquote-vars (unquote x) k i v (#t . d))
     (match-extract-quasiquote-vars x k i v d))
    ((match-extract-quasiquote-vars (x . y) k i v (#t . d))
     (match-extract-quasiquote-vars
      x
      (match-extract-quasiquote-vars-step y k i v d) i ()))
    ((match-extract-quasiquote-vars #(x ...) k i v (#t . d))
     (match-extract-quasiquote-vars (x ...) k i v d))
    ((match-extract-quasiquote-vars x (k ...) i v (#t . d))
     (k ... v))
    ))

(define-syntax match-extract-quasiquote-vars-step
  (syntax-rules ()
    ((_ x k i v d ((v2 v2-ls) ...))
     (match-extract-quasiquote-vars x k (v2 ... . i) ((v2 v2-ls) ... . v) d))
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Gimme some sugar baby.

;;> Shortcut for \scheme{lambda} + \scheme{match}.  Creates a
;;> procedure of one argument, and matches that argument against each
;;> clause.

(define-syntax match-lambda
  (syntax-rules ()
    ((_ (pattern . body) ...) (lambda (expr) (match expr (pattern . body) ...)))))

;;> Similar to \scheme{match-lambda}.  Creates a procedure of any
;;> number of arguments, and matches the argument list against each
;;> clause.

(define-syntax match-lambda*
  (syntax-rules ()
    ((_ (pattern . body) ...) (lambda expr (match expr (pattern . body) ...)))))

;;> Matches each var to the corresponding expression, and evaluates
;;> the body with all match variables in scope.  Raises an error if
;;> any of the expressions fail to match.  Syntax analogous to named
;;> let can also be used for recursive functions which match on their
;;> arguments as in \scheme{match-lambda*}.

(define-syntax match-let
  (syntax-rules ()
    ((_ ((var value) ...) . body)
     (match-let/helper let () () ((var value) ...) . body))
    ((_ loop ((var init) ...) . body)
     (match-named-let loop ((var init) ...) . body))))

;;> Similar to \scheme{match-let}, but analogously to \scheme{letrec}
;;> matches and binds the variables with all match variables in scope.

(define-syntax match-letrec
  (syntax-rules ()
    ((_ ((var value) ...) . body)
     (match-let/helper letrec () () ((var value) ...) . body))))

(define-syntax match-let/helper
  (syntax-rules ()
    ((_ let ((var expr) ...) () () . body)
     (let ((var expr) ...) . body))
    ((_ let ((var expr) ...) ((pat tmp) ...) () . body)
     (let ((var expr) ...)
       (match-let* ((pat tmp) ...)
         . body)))
    ((_ let (v ...) (p ...) (((a . b) expr) . rest) . body)
     (match-let/helper
      let (v ... (tmp expr)) (p ... ((a . b) tmp)) rest . body))
    ((_ let (v ...) (p ...) ((#(a ...) expr) . rest) . body)
     (match-let/helper
      let (v ... (tmp expr)) (p ... (#(a ...) tmp)) rest . body))
    ((_ let (v ...) (p ...) ((a expr) . rest) . body)
     (match-let/helper let (v ... (a expr)) (p ...) rest . body))))

(define-syntax match-named-let
  (syntax-rules ()
    ((_ loop ((pat expr var) ...) () . body)
     (let loop ((var expr) ...)
       (match-let ((pat var) ...)
         . body)))
    ((_ loop (v ...) ((pat expr) . rest) . body)
     (match-named-let loop (v ... (pat expr tmp)) rest . body))))

;;> \macro{(match-let* ((var value) ...) body ...)}

;;> Similar to \scheme{match-let}, but analogously to \scheme{let*}
;;> matches and binds the variables in sequence, with preceding match
;;> variables in scope.

(define-syntax match-let*
  (syntax-rules ()
    ((_ () . body)
     (let () . body))
    ((_ ((pat expr) . rest) . body)
     (match expr (pat (match-let* rest . body))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Otherwise COND-EXPANDed bits.

(cond-expand
 (chibi
  (define-syntax match-check-ellipsis
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (compare '... (cadr expr))
           (car (cddr expr))
           (cadr (cddr expr))))))
  (define-syntax match-check-identifier
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (identifier? (cadr expr))
           (car (cddr expr))
           (cadr (cddr expr)))))))

 (else
  ;; Portable versions
  ;;
  ;; This *should* work, but doesn't :(
  ;;   (define-syntax match-check-ellipsis
  ;;     (syntax-rules (...)
  ;;       ((_ ... sk fk) sk)
  ;;       ((_ x sk fk) fk)))
  ;;
  ;; This is a little more complicated, and introduces a new let-syntax,
  ;; but should work portably in any R[56]RS Scheme.  Taylor Campbell
  ;; originally came up with the idea.
  (define-syntax match-check-ellipsis
    (syntax-rules ()
      ;; these two aren't necessary but provide fast-case failures
      ((match-check-ellipsis (a . b) success-k failure-k) failure-k)
      ((match-check-ellipsis #(a ...) success-k failure-k) failure-k)
      ;; matching an atom
      ((match-check-ellipsis id success-k failure-k)
       (let-syntax ((ellipsis? (syntax-rules ()
                                 ;; iff `id' is `...' here then this will
                                 ;; match a list of any length
                                 ((ellipsis? (foo id) sk fk) sk)
                                 ((ellipsis? other sk fk) fk))))
         ;; this list of three elements will only match the (foo id) list
         ;; above if `id' is `...'
         (ellipsis? (a b c) success-k failure-k)))))

  ;; This is portable but can be more efficient with non-portable
  ;; extensions.  This trick was originally discovered by Oleg Kiselyov.
  (define-syntax match-check-identifier
    (syntax-rules ()
      ;; fast-case failures, lists and vectors are not identifiers
      ((_ (x . y) success-k failure-k) failure-k)
      ((_ #(x ...) success-k failure-k) failure-k)
      ;; x is an atom
      ((_ x success-k failure-k)
       (let-syntax
           ((sym?
             (syntax-rules ()
               ;; if the symbol `abracadabra' matches x, then x is a
               ;; symbol
               ((sym? x sk fk) sk)
               ;; otherwise x is a non-symbol datum
               ((sym? y sk fk) fk))))
         (sym? abracadabra success-k failure-k)))))))

(cond-expand
 (plan9
  (define (exit . o)
    (%exit (if (pair? o)
               (if (string? (car o))
                   (car o)
                   (if (eq? #t (car o)) "" "chibi error"))
               ""))))
 (else
  (define (exit . o)
    (%exit (if (pair? o)
               (if (integer? (car o)) (car o) (if (eq? #t (car o)) 0 1))
               0)))))

(cond-expand
 (bsd
  (define (process-command-line pid)
    (let ((res (%process-command-line pid)))
      ;; TODO: get command-line arguments
      (if (string? res) (list res) res))))
 (else
  (define (process-command-line pid)
    (call-with-current-continuation
     (lambda (return)
       (with-exception-handler
        (lambda (exn) (return #f))
        (lambda ()
          (let ((file (string-append "/proc/" (number->string pid) "/cmdline")))
            (call-with-input-file file
              (lambda (in)
                (let lp ((arg '()) (res '()))
                  (let ((ch (read-char in)))
                    (if (or (eof-object? ch) (eqv? (char->integer ch) 0))
                        (let ((res (cons (list->string (reverse arg)) res))
                              (ch2 (peek-char in)))
                          (if (or (eof-object? ch2)
                                  (eqv? (char->integer ch2) 0))
                              (reverse res)
                              (lp '() res)))
                        (lp (cons ch arg) res))))))))))))))

(define (process-running? pid . o)
  (let ((cmdline (process-command-line pid)))
    (and (pair? cmdline)
         (or (null? o)
             (not (car o))
             (equal? (car o) (car cmdline))))))

(define (execute cmd args)
  (define (->string x)
    (cond ((symbol? x) (symbol->string x))
          ((number? x) (number->string x))
          (else x)))
  (execvp (->string cmd) (map ->string args)))

(define (system cmd . args)
  (let ((pid (fork)))
    (cond
     ((zero? pid)
      (let* ((res (execute cmd (cons cmd args)))
             (err (current-error-port)))
        ;; we only arrive here if execute fails
        (cond
         ((output-port? err)
          (display "ERROR: couldn't execute: " (current-error-port))
          (write cmd (current-error-port))
          (newline (current-error-port))))
        (exit 1)))
     (else
      (waitpid pid 0)))))

(define (call-with-process-io command proc)
  (define (set-non-blocking! fd)
    (cond-expand
     (threads
      (set-file-descriptor-status!
       fd
       (bitwise-ior open/non-block (get-file-descriptor-status fd))))
     (else
      #f)))
  (let ((command-ls (if (string? command) (string-split command) command))
        (in-pipe (open-pipe))
        (out-pipe (open-pipe))
        (err-pipe (open-pipe)))
    (and in-pipe out-pipe err-pipe
         (let ((pid (fork)))
           (cond
            ((not pid)
             (error "couldn't fork"))
            ((zero? pid)  ;; child
             (close-file-descriptor (cadr in-pipe))
             (close-file-descriptor (car out-pipe))
             (close-file-descriptor (car err-pipe))
             (duplicate-file-descriptor-to (car in-pipe) 0)
             (duplicate-file-descriptor-to (cadr out-pipe) 1)
             (duplicate-file-descriptor-to (cadr err-pipe) 2)
             (close-file-descriptor (car in-pipe))
             (close-file-descriptor (cadr out-pipe))
             (close-file-descriptor (cadr err-pipe))
             (execute (car command-ls) command-ls))
            (else         ;; parent
             (close-file-descriptor (car in-pipe))
             (close-file-descriptor (cadr out-pipe))
             (close-file-descriptor (cadr err-pipe))
             (set-non-blocking! (cadr in-pipe))
             (set-non-blocking! (car out-pipe))
             (set-non-blocking! (car err-pipe))
             (proc pid
                   (open-output-file-descriptor (cadr in-pipe))
                   (open-input-file-descriptor (car out-pipe))
                   (open-input-file-descriptor (car err-pipe)))))))))

(define (process->string str)
  (call-with-process-io
   str
   (lambda (pid in out err)
     (close-output-port in)
     (let ((res (port->string out)))
       (waitpid pid 0)
       res))))

(define (process->sexp str)
  (call-with-input-string (process->string str) read))

(define (process->output+error str)
  (call-with-process-io
   str
   (lambda (pid in out err)
     (close-output-port in)
     (let ((out (port->string out))
           (err (port->string err)))
       (waitpid pid 0)
       (list out err)))))

(define (process->string-list str)
  (call-with-process-io
   str
   (lambda (pid in out err)
     (close-output-port in)
     (let ((res (port->string-list out)))
       (waitpid pid 0)
       res))))
;; strings.scm -- cursor-oriented string library
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (string-null? str)
  (equal? str ""))

(define (make-char-predicate x)
  (cond ((procedure? x) x)
        ((char? x) (lambda (ch) (eq? ch x)))
        ((char-set? x) (lambda (ch) (char-set-contains? x ch)))
        (else (error "invalid character predicate" x))))

(define (complement pred) (lambda (x) (not (pred x))))

(define (string-any x str)
  (let ((pred (make-char-predicate x))
        (end (string-cursor-end str)))
    (and (string-cursor>? end (string-cursor-start str))
         (let lp ((i (string-cursor-start str)))
           (let ((i2 (string-cursor-next str i))
                 (ch (string-cursor-ref str i)))
             (if (string-cursor>=? i2 end)
                 (pred ch)  ;; tail call
                 (or (pred ch) (lp i2))))))))

(define (string-every x str)
  (not (string-any (complement (make-char-predicate x)) str)))

(define (string-find str x . o)
  (let ((pred (make-char-predicate x))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (string-cursor-end str))))
    (let lp ((i (if (pair? o) (car o) (string-cursor-start str))))
      (cond ((string-cursor>=? i end) end)
            ((pred (string-cursor-ref str i)) i)
            (else (lp (string-cursor-next str i)))))))

(define (string-find? str x . o)
  (let ((start (if (pair? o) (car o) (string-cursor-start str)))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (string-cursor-end str))))
    (< (string-find str x start end) end)))

(define (string-find-right str x . o)
  (let ((pred (make-char-predicate x))
        (start (if (pair? o) (car o) (string-cursor-start str))))
    (let lp ((i (if (and (pair? o) (pair? (cdr o)))
                    (cadr o)
                    (string-cursor-end str))))
      (let ((i2 (string-cursor-prev str i)))
        (cond ((string-cursor<? i2 start) start)
              ((pred (string-cursor-ref str i2)) i)
              (else (lp i2)))))))

(define (string-skip str x . o)
  (apply string-find str (complement (make-char-predicate x)) o))

(define (string-skip-right str x . o)
  (apply string-find-right str (complement (make-char-predicate x)) o))

(define string-join string-concatenate)

(define (string-split str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space)))
        (limit (if (and (pair? o) (pair? (cdr o)))
                   (cadr o)
                   (+ 1 (string-size str))))
        (start (string-cursor-start str))
        (end (string-cursor-end str)))
    (if (string-cursor>=? start end)
        '()
        (let lp ((i start) (n 1) (res '()))
          (cond
           ((>= n limit)
            (reverse (cons (substring-cursor str i) res)))
           (else
            (let* ((j (string-find str pred i))
                   (res (cons (substring-cursor str i j) res)))
              (if (string-cursor>=? j end)
                  (reverse res)
                  (lp (string-cursor-next str j) (+ n 1) res)))))))))

(define (string-trim-left str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space))))
    (substring-cursor str (string-skip str pred))))

(define (string-trim-right str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space))))
    (substring-cursor str
                      (string-cursor-start str)
                      (string-skip-right str pred))))

(define (string-trim str . o)
  (let* ((pred (if (pair? o) (car o) #\space))
         (left (string-skip str pred))
         (right (string-skip-right str pred)))
    (if (string-cursor>=? left right)
        ""
        (substring-cursor str left right))))

(define (string-mismatch prefix str)
  (let ((end1 (string-cursor-end prefix))
        (end2 (string-cursor-end str)))
    (let lp ((i (string-cursor-start prefix))
             (j (string-cursor-start str)))
      (if (or (string-cursor>=? i end1)
              (string-cursor>=? j end2)
              (not (eq? (string-cursor-ref prefix i) (string-cursor-ref str j))))
          j
          (lp (string-cursor-next prefix i) (string-cursor-next str j))))))

(define (string-mismatch-right suffix str)
  (let ((end1 (string-cursor-start suffix))
        (end2 (string-cursor-start str)))
    (let lp ((i (string-cursor-prev suffix (string-cursor-end suffix)))
             (j (string-cursor-prev str (string-cursor-end str))))
      (if (or (string-cursor<? i end1)
              (string-cursor<? j end2)
              (not (eq? (string-cursor-ref suffix i) (string-cursor-ref str j))))
          j
          (lp (string-cursor-prev suffix i) (string-cursor-prev str j))))))

;; TODO: These definitions are specific to the Chibi implementation of
;; cursors.  Possibly the mismatch API should be modified to allow an
;; efficient portable definition.
(define (string-prefix? prefix str)
  (= (string-cursor-end prefix) (string-mismatch prefix str)))

(define (string-suffix? suffix str)
  (= (string-cursor-prev suffix (string-cursor-start suffix))
     (- (string-mismatch-right suffix str)
        (- (string-cursor-end str) (string-cursor-end suffix)))))

(define (string-fold kons knil str . los)
  (if (null? los)
      (let ((end (string-cursor-end str)))
        (let lp ((i (string-cursor-start str)) (acc knil))
          (if (string-cursor>=? i end)
              acc
              (lp (string-cursor-next str i)
                  (kons (string-cursor-ref str i) acc)))))
      (let ((los (cons str los)))
        (let lp ((is (map string-cursor-start los))
                 (acc knil))
          (if (any (lambda (str i)
                     (string-cursor>=? i (string-cursor-end str)))
                   los is)
              acc
              (lp (map string-cursor-next los is)
                  (apply kons (append (map string-cursor-ref los is)
                                      (list acc)))))))))

(define (string-fold-right kons knil str)
  (let ((end (string-cursor-end str)))
    (let lp ((i (string-cursor-start str)))
      (if (string-cursor>=? i end)
          knil
          (kons (string-cursor-ref str i) (lp (string-cursor-next str i)))))))

(define (string-count str x)
  (let ((pred (make-char-predicate x)))
    (string-fold (lambda (ch count) (if (pred ch) (+ count 1) count)) 0 str)))

(define (string-for-each proc str . los)
  (if (null? los)
      (string-fold (lambda (ch a) (proc ch)) #f str)
      (let ((los (cons str los)))
	(let lp ((is (map string-cursor-start los)))
	  (cond
	   ((any (lambda (str i)
		   (string-cursor>=? i (string-cursor-end str)))
		 los is))
	   (else
	    (apply proc (map string-cursor-ref los is))
	    (lp (map string-cursor-next los is))))))))

(define (string-map proc str . los)
  (call-with-output-string
    (lambda (out)
      (apply string-for-each
	     (lambda args (write-char (apply proc args) out))
	     str los))))

(define (make-string-searcher needle)
  (lambda (haystack) (string-contains haystack needle)))

(define (string-downcase-ascii s)
  (call-with-output-string
    (lambda (out)
      (string-for-each (lambda (ch) (write-char (char-downcase ch) out)) s))))

(define (string-upcase-ascii s)
  (call-with-output-string
    (lambda (out)
      (string-for-each (lambda (ch) (write-char (char-upcase ch) out)) s))))
;; commands.scm -- snow commands
;;
;; This code was written by Alex Shinn in 2014 and placed in the
;; Public Domain.  All warranties are disclaimed.

(define (find-in-path file . o)
  (any (lambda (dir)
         (let ((path (make-path dir file)))
           (and (file-exists? path) path)))
       (if (pair? o)
           (car o)
           (string-split (get-environment-variable "PATH") #\:))))

(define (find-sexp-in-path file dirs . o)
  (let ((pred (if (pair? o) (car o) (lambda (x) #t))))
    (any (lambda (dir)
           (let ((path (make-path dir file)))
             (and (file-exists? path)
                  (guard (exn (else #f))
                    (let ((x (call-with-input-file path read)))
                      (and (pred x) x))))))
         dirs)))

(define (available-implementations cfg)
  (define (find prog name) (if (find-in-path prog) (list name) '()))
  (append (cond-expand
           (chibi (list 'chibi))
           (else (find "chibi-scheme" 'chibi)))
          (find "foment" 'foment)
          (find "gosh" 'gauche)
          (find "guile" 'guile)
          (find "sagittarius" 'sagittarius)))

(define (conf-selected-implementations cfg)
  (let ((requested (conf-get-list cfg 'implementations '(chibi)))
        (available (available-implementations cfg)))
    (if (memq 'all requested)
        available
        (lset-intersection eq? requested available))))

(define (conf-for-implementation cfg impl)
  (conf-specialize cfg 'implementation impl))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (file->sexp-list file)
  (call-with-input-file file
    (lambda (in)
      (let lp ((res '()))
        (let ((x (read in)))
          (if (eof-object? x)
              (reverse res)
              (lp (cons x res))))))))

(define (version-split str)
  (if str
      (map (lambda (x) (or (string->number x) x))
        (string-split str #\.))
      '()))

(define (version-compare a b)
  (define (less? x y)
    (cond ((number? x) (if (number? y) (< x y) 1))
          ((number? y) -1)
          (else (string<? x y))))
  (let lp ((as (version-split a))
           (bs (version-split b)))
    (cond
     ((null? as) (if (null? bs) -1 0))
     ((null? bs) 1)
     ((less? (car as) (car bs)) -1)
     ((less? (car bs) (car as)) 1)
     (else (lp (cdr as) (cdr bs))))))

(define (version>? a b) (> (version-compare a b) 0))
(define (version>=? a b) (>= (version-compare a b) 0))

;; Hack to evaluate an expression in a separate process with a larger
;; default heap.  The expression and result must be serializable with
;; write, and imports should be an argument list for environment.
;; Currently only used when generating keys and signing.
(define (fast-eval expr imports . o)
  (let* ((heap-size (if (pair? o) (car o) 500))
         (cmd
          `("chibi-scheme"
            ,(string-append "-h" (number->string heap-size) "M")
            ,@(map
               (lambda (i)
                 (string-append "-m" (string-join (map write-to-string i) ".")))
               imports)
            "-p" ,(write-to-string expr))))
    (let ((res (process->sexp cmd)))
      (if (eof-object? res)  ; process error
          (eval expr (apply environment imports))
          res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Package - generate a package from one or more libraries.

(define (tar-file? file)
  (or (equal? (path-extension file) "tgz")
      (and (member (path-extension file) '("gz" "bz2"))
           (equal? (path-extension (path-strip-extension file)) "tar"))))

(define (package-file-meta file)
  (and
   (tar-file? file)
   (let* ((unzipped-file
           (if (member (path-extension file) '("tgz" "gz"))
               (gunzip (let* ((in (open-binary-input-file file))
                              (res (port->bytevector in)))
                         (close-input-port in)
                         res))
               file))
          (package-file
           (find
            (lambda (x)
              (and (equal? "package.scm" (path-strip-directory x))
                   (equal? "." (path-directory (path-directory x)))))
            (tar-files unzipped-file))))
     (and package-file
          (guard (exn (else #f))
            (let* ((str (utf8->string
                         (tar-extract-file unzipped-file package-file)))
                   (package (read (open-input-string str))))
              (and (pair? package)
                   (eq? 'package (car package))
                   package)))))))

(define (package-file? file)
  (and (package-file-meta file) #t))

(define (x->string x)
  (cond ((string? x) x)
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (error "not a valid path component" x))))

(define (library-path-base file name)
  (let lp ((ls (cdr (reverse name))) (dir (path-directory file)))
    (cond
     ((null? ls) dir)
     ((equal? (x->string (car ls)) (path-strip-directory dir))
      (lp (cdr ls) (path-directory dir)))
     (else dir))))

(define (path-relative file dir)
  (let ((file (path-normalize file))
        (dir (string-trim-right (path-normalize dir) #\/)))
    (string-trim-left
     (if (string-prefix? dir file)
         (substring file (string-length dir))
         file)
     #\/)))

;; remove import qualifiers
(define (import-name import)
  (cond
   ((and (pair? import)
         (memq (car import) '(only except prefix drop-prefix rename))
         (pair? (cadr import)))
    (import-name (cadr import)))
   (else import)))

(define (extract-library cfg file)
  (let ((lib (read-from-file file)))
    (match lib
      (('define-library (name ...)
         declarations ...)
       (let* ((dir (library-path-base file name))
              (lib-file (path-relative file dir))
              (lib-dir (path-directory lib-file)))
         (define (resolve file)
           (let ((dest-path (make-path lib-dir file)))
             (list 'rename (make-path dir dest-path) dest-path)))
         (let lp ((ls declarations)
                  (info `(,@(cond
                             ((conf-get cfg '(command package author))
                              => (lambda (x) (list (list 'author x))))
                             (else '()))
                          (path ,lib-file)
                          (name ,name)))
                  (files `((rename ,file ,lib-file))))
           (cond
            ((null? ls)
             (cons `(library ,@(reverse info))
                   files))
            (else
             (match (car ls)
               (((or 'include 'include-ci) includes ...)
                (lp (cdr ls)
                    info
                    (append (map resolve includes) files)))
               (('include-library-declarations includes ...)
                (lp (append (append-map file->sexp-list includes) (cdr ls))
                    info
                    (append (map resolve includes) files)))
               (('import libs ...)
                (lp (cdr ls)
                    (cons (cons 'depends (map import-name libs)) info)
                    files))
               (('cond-expand clauses ...)
                (lp (append (append-map cdr clauses) (cdr ls)) info files))
               (else
                (lp (cdr ls) info files))))))))
      (else
       (die 2 "not a valid library declaration " lib " in file " file)))))

(define (extract-program-imports file)
  (let lp ((ls (guard (exn (else '())) (file->sexp-list file)))
           (deps '()))
    (cond
     ((and (pair? ls) (pair? (car ls)) (eq? 'import (caar ls)))
      (lp (cdr ls) (append (reverse (map import-name (cdar ls))) deps)))
     (else
      (reverse deps)))))

(define (make-package-name cfg libs . o)
  (let ((name (any (lambda (x) (or (library-name x) (program-name x))) libs))
        (version (and (pair? o) (car o))))
    (cond
     ((not (and (pair? name) (list? name)))
      (die 2 "Invalid library name: " name))
     ((not name)
      (die 2 "Couldn't determine package name from libs: " libs))
     (else
      (let lp ((ls (if version
                       (append name (list version))
                       name))
               (res '()))
        (if (null? ls)
            (string-join (reverse (cons ".tgz" res)))
            (lp (cdr ls)
                (cons (x->string (car ls))
                      (if (null? res) res (cons "-" res))))))))))

(define (check-overwrite cfg file type-pred type-name)
  (let ((mode (conf-get cfg '(command package overwrite) 'same-type)))
    (cond
     ((eq? mode 'always))
     ((file-exists? file)
      (case mode
        ((never)
         (die 2 "Destination " file " already exists, not overwriting"))
        ((same-type)
         (if (not (type-pred file))
             (die 2 "Destination " file " doesn't look like a " type-name
                  ", not overwriting")))
        ((confirm)
         (if (not (yes-or-no? cfg "Overwrite existing " file "?"))
             (die 2 "Not overwriting " file))))))))

;; Simplistic pretty printing for package/repository/config declarations.
(define (write-simple-pretty pkg out)
  (let wr ((ls pkg) (indent 0) (tails 0))
    (cond
     ((and (pair? ls)
           (pair? (cdr ls))
           (pair? (cadr ls)))
      (display (make-string indent #\space) out)
      (write-char #\( out)
      (write (car ls) out)
      (newline out)
      (for-each (lambda (x) (wr x (+ indent 2) 0)) (drop-right (cdr ls) 1))
      (wr (last ls) (+ indent 2) (+ tails 1)))
     (else
      (display (make-string indent #\space) out)
      (write ls out)
      (display (make-string tails #\)) out)
      (newline out)))))

;; We want to automatically bundle (foo bar *) when packaging (foo bar)
;; if it's already in the same directory.
(define (submodule->path base file lib dep)
  (and base
       (> (length dep) (length base))
       (equal? base (take dep (length base)))
       ;; TODO: find-library(-relative)
       (let* ((dir (library-path-base file lib))
              (dep-file (make-path dir (string-append
                                        (library-name->path dep)
                                        ".sld"))))
         (and (file-exists? dep-file) dep-file))))

(define (package-docs cfg spec libs)
  (cond
   ((conf-get cfg '(command package doc)) => list)
   ((conf-get cfg '(command package doc-from-scribble))
    (map
     (lambda (lib)
       (let* ((lib+files (extract-library cfg lib))
              (lib-name (library-name (car lib+files))))
         `(inline
           ,(string-append (library-name->path lib-name) ".html")
           ,(call-with-output-string
              (lambda (out)
                (print-module-docs lib-name out sxml-display-as-html))))))
     libs))
   (else '())))

(define (package-description cfg spec libs docs)
  (cond
   ((conf-get cfg '(command package description)))
   ((conf-get cfg '(command upload description)))
   ;; Crazy hack, make this more robust, probably opt-in.
   ((and (pair? docs) (pair? (car docs)) (eq? 'inline (caar docs))
         (regexp-search
          '(: "<p>" (* "\n") (* space) ($ (* (~ ("."))) "."))
          (third (car docs))))
    => (lambda (m)
         (let ((s (regexp-match-submatch m 1)))
           (and s
                (regexp-replace-all
                 '(>= 2 space)
                 (regexp-replace-all
                  "\n"
                  (regexp-replace-all '(: "<" (? "/") (* (~ ("<>"))) ">")
                                      s "")
                  " ")
                 " ")))))
   (else #f)))

(define (package-test cfg)
  (conf-get cfg '(command package test)))

(define (package-license cfg)
  (conf-get cfg '(command package license)))

(define (package-output-version cfg)
  (cond ((conf-get cfg '(command package version)))
        ((conf-get cfg '(command upload version)))
        ((conf-get cfg '(command package version-file))
         => (lambda (file) (call-with-input-file file read-line)))
        ((conf-get cfg '(command upload version-file))
         => (lambda (file) (call-with-input-file file read-line)))
        (else #f)))

(define (package-output-path cfg package-spec)
  (or (conf-get cfg 'output)
      (make-package-name
       cfg
       (filter (lambda (x) (and (pair? x) (memq (car x) '(library program))))
               package-spec)
       (package-output-version cfg))))

(define (package-spec+files cfg spec libs)
  (let* ((recursive? (conf-get cfg '(command package recursive?)))
         (programs (conf-get-list cfg '(command package programs)))
         (docs (package-docs cfg spec libs))
         (desc (package-description cfg spec libs docs))
         (test (package-test cfg))
         (authors (conf-get-list cfg '(command package authors)))
         (maintainers (conf-get-list cfg '(command package maintainers)))
         (version (package-output-version cfg))
         (license (package-license cfg)))
    (let lp ((ls (map (lambda (x) (cons x #f)) libs))
             (progs programs)
             (res
              `(,@(if license `((license ,license)) '())
                ,@(if (pair? docs)
                      `((manual ,@(map
                                   (lambda (x)
                                     (path-strip-leading-parents
                                      (if (pair? x) (cadr x) x)))
                                   docs)))
                      '())
                ,@(if desc `((description ,desc)) '())
                ,@(if test `((test ,(path-strip-leading-parents test))) '())
                ,@(if version `((version ,version)) '())
                ,@(if (pair? authors) `((authors ,@authors)) '())
                ,@(if (pair? maintainers) `((maintainers ,@maintainers)) '())))
             (files
              `(,@(if test (list test) '())
                ,@docs)))
      (cond
       ((pair? ls)
        (let* ((lib+files (extract-library cfg (caar ls)))
               (lib (car lib+files))
               (name (library-name lib))
               (base (or (cdar ls) name))
               (subdeps (if recursive?
                            (filter-map
                             (lambda (x)
                               (submodule->path base (caar ls) name x))
                             (cond ((assq 'depends (cdr lib)) => cdr)
                                   (else '())))
                            '())))
          (lp (append (map (lambda (x) (cons x base)) subdeps) (cdr ls))
              progs
              (cons lib res)
              (append (reverse (cdr lib+files)) files))))
       ((pair? progs)
        (lp ls
            (cdr progs)
            (cons `(program
                    (path ,(path-strip-leading-parents (car progs)))
                    (depends ,@(extract-program-imports (car progs))))
                  res)
            (cons (car progs) files)))
       ((null? res)
        (die 2 "No packages generated"))
       (else
        (cons (cons 'package (reverse res)) (reverse files)))))))

(define (create-package spec files path)
  (gzip
   (tar-create #f `(,@files
                    (inline "package.scm"
                            ,(call-with-output-string
                               (lambda (out) (write-simple-pretty spec out)))))
               (let ((dir (path-strip-extension (path-strip-directory path))))
                 (lambda (f) (make-path dir f)))
               #t)))

(define (command/package cfg spec . libs)
  (let* ((spec+files (package-spec+files cfg spec libs))
         (output (package-output-path cfg (car spec+files)))
         (tarball (create-package (car spec+files) (cdr spec+files) output)))
    (check-overwrite cfg output package-file? "package")
    (let ((out (open-binary-output-file output)))
      (write-bytevector tarball out)
      (close-output-port out))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Gen-key - generate a new RSA key pair.

(define (conf-get-snow-dir cfg)
  (or (conf-get cfg 'snow-dir)
      (string-append (get-environment-variable "HOME") "/.snow")))

(define (rsa-key->sexp key name email)
  `((name ,name)
    (email ,email)
    (bits ,(rsa-key-bits key))
    ,@(cond
       ((rsa-key-e key)
        => (lambda (e)
             `((public-key
                (modulus ,(integer->hex-string (rsa-key-n key)))
                (exponent ,e)))))
       (else '()))
    ,@(cond
       ((rsa-key-d key)
        => (lambda (d)
             `((private-key
                (modulus ,(integer->hex-string (rsa-key-n key)))
                (exponent ,d)))))
       (else '()))))

(define (conf-gen-key cfg bits)
  (show #t "Generating a new key, this may take quite a while...\n")
  (if (conf-get cfg 'gen-key-in-process?)
      (rsa-key-gen bits)
      (let* ((lo (max 3 (expt 2 (- bits 1))))
             (hi (expt 2 bits))
             (p (fast-eval `(random-prime ,lo ,hi)
                           '((chibi math prime))))
             (q (fast-eval `(random-prime-distinct-from ,lo ,hi ,p)
                           '((chibi math prime)))))
        (rsa-key-gen-from-primes bits p q))))

(define (command/gen-key cfg spec)
  (show #t
        "Generate a new RSA key for signing packages.\n"
        "We need a descriptive name, and an email address to "
        "uniquely identify the key.\n")
  (let* ((name (input cfg '(gen-key name) "Name: "))
         (email (input cfg '(gen-key email) "Email: "))
         (bits (input-number cfg '(gen-key bits)
                             "RSA key size in bits: " 512 64 20148))
         (key (conf-gen-key cfg bits))
         (snow-dir (conf-get-snow-dir cfg))
         (key-file (or (conf-get cfg 'key-file)
                       (string-append snow-dir "/priv-key.scm")))
         (old-keys (guard (exn (else '()))
                     (call-with-input-file key-file read)))
         (new-keys
          (cons (rsa-key->sexp key name email) 
                ;; TODO: confirm overwrite, preserve old keys
                (remove (rsa-identity=? email) old-keys))))
    (if (not (file-directory? snow-dir))
        (create-directory snow-dir))
    (let* ((fd (open key-file (bitwise-ior open/write open/create) #o600))
           (out (open-output-file-descriptor fd)))
      (show out "("
            (joined (lambda (x)
                      (if (pair? x)
                          (each "(" (joined written x "\n  ") ")")
                          (written x)))
                    new-keys
                    "\n ")
            ")" nl)
      (close-output-port out)
      (show #t "Saved key to " key-file ".\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reg-key - register an RSA key pair with a repository.

(define (remote-uri cfg name path)
  (or (conf-get cfg name)
      (make-path (or (conf-get cfg 'host) "http://snow-fort.org")
                 path)))

(define (remote-command cfg name path params)
  (let ((uri (remote-uri cfg name path)))
    (sxml-display-as-text (read (http-post uri (cons '(fmt . "sexp") params))))
    (newline)))

(define (command/reg-key cfg spec)
  (let* ((keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (or (conf-get cfg 'email)
                    (assoc-get (car keys) 'email)))
         (rsa-key-sexp (or (find (rsa-identity=? email) keys)
                           (and (not email) (car keys))))
         (name (assoc-get rsa-key-sexp 'name))
         (rsa-pub-key (extract-rsa-public-key rsa-key-sexp))
         (rsa-pub-key-str
          (write-to-string (rsa-key->sexp rsa-pub-key name email))))
    (remote-command cfg
                    '(command reg-key uri)
                    "/pkg/reg"
                    `((u (file . "pub-key.scm")
                         (value . ,rsa-pub-key-str))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sign - sign a package.

(define (generate-signature cfg package)
  (let* ((digest-name (conf-get cfg 'digest 'sha-256))
         (digest-func (lookup-digest digest-name))
         (raw-data (if (string? package)
                       (call-with-input-file package port->bytevector)
                       package))
         (snowball (maybe-gunzip raw-data))
         (digest (digest-func snowball))
         (keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (or (conf-get cfg 'email)
                    (assoc-get (car keys) 'email)))
         (rsa-key-sexp (find (rsa-identity=? email) keys))
         (rsa-key (extract-rsa-private-key rsa-key-sexp))
         (sig (fast-eval `(rsa-sign (make-rsa-key ,(rsa-key-bits rsa-key)
                                                  ,(rsa-key-n rsa-key)
                                                  #f
                                                  ,(rsa-key-d rsa-key))
                                    ;;,(hex-string->integer digest)
                                    ,(hex-string->bytevector digest))
                         '((chibi crypto rsa))))
         (hex-sig (if (bytevector? sig)
                      (bytevector->hex-string sig)
                      (integer->hex-string sig))))
    `(signature
      (email ,email)
      (digest ,digest-name)
      (,digest-name ,digest)
      (rsa ,hex-sig))))

(define (command/sign cfg spec package)
  (let* ((dst (or (conf-get cfg 'output)
                  (path-replace-extension package "sig")))
         (sig (generate-signature cfg package)))
    (call-with-output-file dst
      (lambda (out) (write sig out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verify - verify a signature.

(define (command/verify cfg spec sig)
  (let* ((sig-spec (cdr (call-with-input-file sig read)))
         (keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (assoc-get sig-spec 'email))
         (digest-name (assoc-get sig-spec 'digest #f 'sha-256))
         (digest (assoc-get sig-spec digest-name))
         (sig (assoc-get sig-spec 'rsa))
         (rsa-key-sexp (or (and (string? email)
                                (find (rsa-identity=? email) keys))
                           (car keys)))
         (rsa-key (extract-rsa-public-key rsa-key-sexp))
         (cipher (rsa-verify rsa-key (hex-string->bytevector sig)))
         (digest-bv (hex-string->bytevector digest)))
    (if (equal? cipher digest-bv)
        (show #t "signature valid " nl)
        (show #t "signature invalid " cipher " != " digest-bv nl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upload - upload a package.

(define (upload-package cfg spec package . o)
  (let ((pkg (if (string? package)
                 `(u (file . ,package))
                 `(u (file . ,(if (pair? o) (car o) "package.tgz"))
                     (value . ,package))))
        (sig
         (cond
          ((conf-get cfg 'sig-file)
           => (lambda (sig-file) `(sig (file . ,sig-file))))
          (else
           `(sig (file . "package.sig")
                 (value . ,(write-to-string
                            (generate-signature cfg package))))))))
    (remote-command cfg '(command package uri) "/pkg/put" (list pkg sig))))

(define (command/upload cfg spec . o)
  (define (non-homogeneous)
    (die 1 "upload arguments must all be packages or all be libraries, "
         "but got " o))
  (cond
   ((null? o)
    (die 1 "upload requires at least one input argument"))
   ((package-file? (car o))
    (if (not (every package-file? (cdr o)))
        (non-homogeneous))
    (for-each
     (lambda (package) (upload-package cfg spec package))
     o))
   (else
    (if (any package-file? (cdr o))
        (non-homogeneous))
    (let* ((spec+files (package-spec+files cfg spec o))
           (package-file (package-output-path cfg (car spec+files)))
           (package (create-package (car spec+files)
                                    (cdr spec+files)
                                    package-file)))
      (upload-package cfg spec package package-file)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Remove - removes the listed libraries.
;;
;; Provides a summary of the libraries to remove along with any
;; dependencies they have which were not explicitly installed.

(define (warn-delete-file file)
  (guard (exn (else (warn "couldn't delete file: " file)))
    (delete-file file)))

(define (delete-library-files impl cfg pkg lib-name)
  (for-each warn-delete-file (package-installed-files pkg))
  (warn-delete-file (make-path (get-install-source-dir impl cfg)
                               (get-package-meta-file cfg pkg)))
  (let ((dir (make-path (get-install-source-dir impl cfg)
                        (package->path pkg))))
    (if (and (file-directory? dir)
             (= 2 (length (directory-files dir))))
        (delete-directory dir))))

(define (command/remove cfg spec . args)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (lib-names (map parse-library-name args)))
    (for-each
     (lambda (impl impl-cfg)
       (for-each (lambda (pkg lib-name)
                   (delete-library-files impl impl-cfg (cdr pkg) lib-name))
                 (lookup-installed-libraries impl impl-cfg lib-names)
                 lib-names))
     impls
     impl-cfgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Search - search for libraries matching keywords.
;;
;; Prints a list of libraries whose meta-info contain any of the given
;; keywords.  Returns in sorted order for how well the package matches.

(define (summarize-libraries cfg lib-names+pkgs)
  (for-each describe-library
            (map car lib-names+pkgs)
            (map cdr lib-names+pkgs)))

;; faster than (length (regexp-extract re str))
(define (regexp-count re str)
  (regexp-fold re (lambda (from md str acc) (+ acc 1)) 0 str))

(define (count-in-sexp x keywords)
  (regexp-count `(word (w/nocase (or ,@keywords)))
                (write-to-string x)))

(define (extract-matching-libraries cfg repo keywords)
  (define (library-score lib)
    (+ (* 10 (count-in-sexp (library-name lib) keywords))
       (count-in-sexp lib keywords)
       (let ((use-for (assoc-get lib 'use-for)))
         (case (if (pair? use-for) (car use-for) use-for)
           ((test) 0)
           ((build) 10)
           (else 100)))))
  (append-map
   (lambda (x)
     (cond
      ((not (package? x)) '())
      (else
       (let ((pkg-score (count-in-sexp x keywords))
             (libs (package-libraries x)))
         (if (or (zero? pkg-score) (null? libs))
             '()
             (let lp ((libs (cdr libs))
                      (best-score (library-score (car libs)))
                      (best-lib (car libs)))
               (cond
                ((null? libs)
                 (list (cons (+ best-score pkg-score)
                             (cons (library-name best-lib) x))))
                (else
                 (let ((score (library-score (car libs))))
                   (if (> score best-score)
                       (lp (cdr libs) score (car libs))
                       (lp (cdr libs) best-score best-lib)))))))))))
   repo))

(define (extract-sorted-packages cfg repo keywords)
  (let ((ls (extract-matching-libraries cfg repo keywords)))
    (map cdr (sort ls > car))))

(define (command/search cfg spec . keywords)
  (let* ((repo (maybe-update-repository cfg))
         (lib-names+pkgs (extract-sorted-packages cfg repo keywords)))
    (if (pair? lib-names+pkgs)
        (summarize-libraries cfg lib-names+pkgs)
        (display "No libraries matched your query.\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Show - show detailed information for the given libraries
;;
;; The typical pattern is to use search to find the names of libraries
;; of interest, and show to see detailed information to decide whether
;; or not to install them.

(define (describe-library library-name pkg)
  (display library-name)
  (display "\t")
  (display (package-version pkg))
  (newline))

(define (command/show cfg spec . args)
  (maybe-update-repository cfg)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (lib-names (map parse-library-name args)))
    (for-each
     (lambda (impl impl-cfg)
       (for-each describe-library
                 (lookup-installed-libraries impl impl-cfg lib-names)
                 lib-names))
     impls
     impl-cfgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Update - update the repository.

(define (valid-repository? repo)
  (and (pair? repo) (list? repo) (eq? 'repository (car repo))))

(define (repository-dir cfg)
  (cond
   ((zero? (current-user-id))
    (or (conf-get cfg 'local-root-repository)
        "/usr/local/share/snow/repo"))
   (else
    (or (conf-get cfg 'local-user-repository)
        (make-path (conf-get-snow-dir cfg) "repo")))))

(define (update-repository cfg)
  (let* ((local-dir (repository-dir cfg))
         (local-path (make-path local-dir "repo.scm"))
         (local-tmp (string-append local-path ".tmp."
                                   (number->string (current-second))))
         (repo-uri (remote-uri cfg 'repository-uri "/s/repo.scm"))
         (repo-str (call-with-input-url repo-uri port->string))
         (repo (guard (exn (else #f))
                 (let ((repo (read (open-input-string repo-str))))
                   `(,(car repo) (url ,repo-uri) ,@(cdr repo))))))
    (cond
     ((not (valid-repository? repo))
      (die 2 "not a valid repository: " repo-uri))
     ((not (create-directory* local-dir))
      (die 2 "can't create directory: " local-dir ))
     (else
      (guard (exn (else (die 2 "couldn't write repository")))
        (call-with-output-file local-tmp
          (lambda (out) (write repo out)))
        (if (file-exists? local-path)
            (rename-file local-path (string-append local-path ".bak")))
        (rename-file local-tmp local-path)
        repo)))))

(define (repository-stale? cfg)
  (let ((path (make-path (repository-dir cfg) "repo.scm")))
    (guard (exn (else #t))
      (> (current-second)
         (+ (file-modification-time path)
            ;; by default update once every 3 hours
            (conf-get cfg 'update-refresh (* 3 60 60)))))))

(define (should-update-repository? cfg)
  (case (conf-get cfg 'update-strategy 'cache)
    ((always) #t)
    ((never) #f)
    ((cache)
     (repository-stale? cfg))
    ((confirm)
     (and (repository-stale? cfg)
          (yes-or-no? cfg "Update repository info?")))
    (else
     (warn "unknown update-stategy: " (conf-get cfg 'update-strategy))
     #f)))

(define (maybe-update-repository cfg)
  (or (guard (exn (else #f))
        (and (should-update-repository? cfg)
             (update-repository cfg)))
      (guard (exn (else '(repository)))
        (call-with-input-file (make-path (repository-dir cfg) "repo.scm")
          read))))

(define (command/update cfg spec)
  (update-repository cfg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Install - install one or more libraries.
;;
;; Installs the listed libraries along with their transitive closure
;; of dependencies.  For each library to install we confirm the
;; current status (skipping if already installed), the signature and
;; trust (optionally updating the trust level), and the default tests.
;; If multiple implementations are targeted, we install separately but
;; use the same confirmations for each.

(define (get-install-dirs impl cfg)
  (define (guile-eval expr)
    (guard (exn (else #f))
      (process->sexp `(guile -c ,(write-to-string `(write ,expr))))))
  (case impl
    ((chibi)
     (let* ((dirs (reverse (fast-eval '(current-module-path) '((chibi)))))
            (share-dir (find (lambda (d) (string-contains d "/share/")) dirs)))
       (if share-dir
           (cons share-dir (delete share-dir dirs))
           dirs)))
    ((gauche)
     (let ((dir (process->string '(gauche-config "--sitelibdir"))))
       (and (string? dir) (> 0 (string-length dir))
            (eqv? #\/ (string-ref dir 0))
            dir)))
    ((guile)
     (let ((path
            (guile-eval
             '(string-append (cdr (assq 'pkgdatadir %guile-build-info))
                             (string (integer->char 47))
                             (effective-version)))))
       (if (string? path)
           path
           "/usr/local/share/guile/")))
    (else (list (make-path "/usr/local/share/snow" impl)))))

(define (get-install-search-dirs impl cfg)
  (let ((install-dir (get-install-source-dir impl cfg))
        (other-dirs (get-install-dirs impl cfg)))
    (cons install-dir (delete install-dir other-dirs))))

(define (find-library-meta impl cfg name)
  (let ((dirs (get-install-search-dirs impl cfg)))
    (let lp ((subname name))
      (or (find-sexp-in-path
           (package-name->meta-file cfg subname)
           dirs
           (lambda (x)
             (and (package? x)
                  (any (lambda (y) (equal? name (library-name y)))
                       (package-libraries x)))))
          (and (pair? (cdr subname))
               (lp (drop-right subname 1)))))))

(define (test-library impl cfg library dir)
  #t)

(define (lookup-installed-libraries impl cfg names)
  (map (lambda (name)
         (cons name
               (or (find-library-meta impl cfg name)
                   `(not-installed ,name))))
       names))

(define (installed-libraries impl cfg)
  (delete-duplicates
   (directory-fold-tree
    (get-install-source-dir impl cfg)
    #f #f
    (lambda (file acc)
      (cond
       ((and (equal? "meta" (path-extension file))
             (guard (exn (else #f))
               (let ((pkg (call-with-input-file file read)))
                 (and (package? pkg) pkg))))
        => (lambda (pkg)
             (append
              (map
               (lambda (lib) (cons (library-name lib) pkg))
               (package-libraries pkg))
              acc)))
       (else acc)))
    '())
   (lambda (a b) (equal? (car a) (car b)))))

(define (get-install-source-dir impl cfg)
  (cond
   ((conf-get cfg 'install-source-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "share/snow" impl)))
   (else (car (get-install-dirs impl cfg)))))

(define (get-install-binary-dir impl cfg)
  (cond
   ((conf-get cfg 'install-binary-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "bin")))
   (else "/usr/local/bin")))

(define (install-with-sudo? cfg path)
  (case (conf-get cfg '(command install use-sudo?))
    ((always) #t)
    ((never) #f)
    (else
     (let lp ((path path))
       (let ((dir (path-directory path)))
         (and (not (file-is-writable? path))
              (or (file-exists? path)
                  (lp dir))))))))

(define (install-file cfg source dest)
  (if (install-with-sudo? cfg dest)
      (system "sudo" "cp" source dest)
      (copy-file source dest)))

(define (install-sexp-file cfg obj dest)
  (if (install-with-sudo? cfg dest)
      (call-with-temp-file "sexp"
        (lambda (tmp-path out)
          (write-simple-pretty obj out)
          (close-output-port out)
          (system "sudo" "cp" tmp-path dest)))
      (call-with-output-file dest
        (lambda (out) (write-simple-pretty obj out)))))

(define (install-symbolic-link cfg source dest)
  (if (install-with-sudo? cfg dest)
      (system "sudo" "ln" "-s" source dest)
      (symbolic-link-file source dest)))

(define (install-directory cfg dir)
  (cond
   ((file-directory? dir))
   ((install-with-sudo? cfg dir)
    (system "sudo" "mkdir" "-p" dir))
   (else
    (create-directory* dir))))

(define (install-package-meta-info impl cfg pkg)
  (let* ((meta-file (get-package-meta-file cfg pkg))
         (install-dir (get-install-source-dir impl cfg))
         (path (make-path install-dir meta-file)))
    ;; write the package name
    (install-sexp-file cfg pkg path)
    ;; symlink utility libraries for which the package can't be inferred
    (let ((pkg-name (package-name pkg)))
      (for-each
       (lambda (lib)
         (let ((lib-name (library-name lib)))
           (if (not (equal? pkg-name (take lib-name (length pkg-name))))
               (let ((lib-meta (get-library-meta-file cfg lib)))
                 (install-symbolic-link
                  cfg path (make-path install-dir lib-meta))))))
       (package-libraries pkg)))))

;; The default installer just copies the library file and any included
;; source files to an installation directory, optionally mapping
;; extensions to the implementations preferred value.
(define (default-installer impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (ext (conf-get cfg 'library-extension "sld"))
         (dest-library-file (path-replace-extension library-file ext))
         (include-files
          (library-include-files cfg (make-path dir library-file)))
         (rewrite-include-files
          ;; Rewrite if any include has the same path as the library
          ;; declaration file after extension renaming.
          ;; TODO: Also rewrite if multiple libs use same file names?
          (map
           (lambda (x)
             (if (equal? x dest-library-file)
                 (cons x (string-append x "." ext))
                 x))
           include-files))
         (install-dir (get-install-source-dir impl cfg)))
    ;; install the library file
    (let ((path (make-path install-dir dest-library-file)))
      (install-directory cfg (path-directory path))
      (if (any pair? rewrite-include-files)
          (install-sexp-file
           cfg
           (library-rewrite-includes library rewrite-include-files)
           path)
          (install-file cfg (make-path dir library-file) path))
      ;; install any includes
      (cons
       path
       (map
        (lambda (x)
          (let ((dest-file
                 (make-path install-dir
                            (path-relative (if (pair? x) (cdr x) x) dir))))
            (install-directory cfg (path-directory dest-file))
            (install-file cfg (if (pair? x) (car x) x) dest-file)
            dest-file))
        rewrite-include-files)))))

(define (default-program-installer impl cfg prog dir)
  (let* ((program-file (get-program-file cfg prog))
         (dest-program-file (program-install-name prog))
         (install-dir (get-install-binary-dir impl cfg)))
    (let ((path (make-path install-dir dest-program-file)))
      (install-directory cfg (path-directory path))
      (install-file cfg (make-path dir program-file) path))))

;; installers should return the list of installed files
(define (lookup-installer installer)
  (case installer
    (else default-installer)))

(define (install-library impl cfg library dir)
  (let ((installer (lookup-installer (conf-get cfg 'installer))))
    (installer impl cfg library dir)))

(define (build-library impl cfg library dir)
  ;; the currently supported implementations don't require building
  #t)

(define (build-program impl cfg prog dir)
  #t)

(define (lookup-program-installer installer)
  (case installer
    (else default-program-installer)))

(define (install-program impl cfg prog dir)
  (let ((installer (lookup-program-installer
                    (conf-get cfg 'program-installer))))
    (installer impl cfg prog dir)))

(define (fetch-package cfg url)
  (call-with-input-url url port->bytevector))

(define (path-strip-top file)
  (let ((pos (string-find file #\/)))
    (if (string-cursor<? pos (string-cursor-end file))
        (substring-cursor file (string-cursor-next file pos))
        file)))

(define (maybe-invalid-package-reason impl cfg pkg)
  (let ((res (invalid-package-reason pkg)))
    (and res
         (not (yes-or-no? cfg "Package invalid: " res "\nProceed anyway?"))
         res)))

(define (package-maybe-digest-mismatches impl cfg pkg raw)
  (and (not (conf-get cfg 'ignore-digests?))
       (let ((res (package-digest-mismatches cfg pkg raw)))
         (and res
              (not (yes-or-no? cfg "Package checksum mismatches: " res
                               "\nProceed anyway?"))
              res))))

(define (package-maybe-signature-mismatches repo impl cfg pkg raw)
  (cond
   ((conf-get cfg 'ignore-signature?) #f)
   ((not (assq 'signature (cdr pkg)))
    (if (yes-or-no? cfg "Package signature missing.\nProceed anyway?")
        #f
        '(package-signature-missing)))
   (else
    (let ((res (package-signature-mismatches repo cfg pkg raw)))
      (and res
           (not (yes-or-no? cfg "Package signature mismatches: " res
                            "\nProceed anyway?"))
           res)))))

(define (install-package repo impl cfg pkg)
  (cond
   ((maybe-invalid-package-reason impl cfg pkg)
    => (lambda (x) (die 2 "package invalid: " x)))
   (else
    (let* ((url (package-url repo pkg))
           (raw (fetch-package cfg url))
           (snowball (maybe-gunzip raw)))
      (cond
       ((not (tar-safe? snowball))
        (die 2 "package tarball should contain a single relative directory: "
             (tar-files snowball)))
       ((package-maybe-digest-mismatches impl cfg pkg snowball)
        => (lambda (x) (die 2 "package checksum didn't match: " x)))
       ((package-maybe-signature-mismatches repo impl cfg pkg snowball)
        => (lambda (x) (die 2 "package signature didn't match: " x)))
       (else
        (call-with-temp-dir
         "pkg"
         (lambda (dir)
           (tar-extract snowball (lambda (f) (make-path dir (path-strip-top f))))
           (let ((installed-files
                  (append
                   (append-map
                    (lambda (lib)
                      (build-library impl cfg lib dir)
                      (test-library impl cfg lib dir)
                      (install-library impl cfg lib dir))
                    (package-libraries pkg))
                   (append-map
                    (lambda (prog)
                      (build-program impl cfg prog dir)
                      (install-program impl cfg prog dir))
                    (package-programs pkg)))))
             (install-package-meta-info
              impl cfg
              `(,@(remove (lambda (x)
                            (and (pair? x) (eq? 'installed-files (car x))))
                          pkg)
                (installed-files ,@installed-files))))))))))))

(define (install-for-implementation repo impl cfg pkgs)
  (for-each
   (lambda (pkg) (install-package repo impl cfg pkg))
   pkgs))

(define (select-best-candidate impl cfg repo candidates)
  (cond
   ((null? (cdr candidates))
    (car candidates))
   (else
    (display "Select a package:\n")
    (let lp ((ls candidates) (i 1))
      (if (pair? ls)
          (let ((pkg (car ls)))
            (display "  ") (display i)
            (display "  ") (display (package-name pkg))
            (display " ") (display (package-version pkg))
            (display " (") (display (package-author repo pkg #t))
            (display ")\n")
            (lp (cdr ls) (+ i 1)))))
    (let ((n (input-number cfg 'candidate-number "Candidate number: "
                           1 1 (length candidates))))
      (list-ref candidates (- n 1))))))

;; Choose packages for the corresponding libraries, and recursively
;; select uninstalled packages.  Verifies and records preferences for
;; trusting publishers for different library prefixes.
(define (expand-package-dependencies repo impl cfg lib-names)
  (let ((current (installed-libraries impl cfg)))
    (let lp ((ls lib-names) (res '()) (ignored '()))
      (cond
       ((null? ls) res)
       ((find (lambda (pkg) (package-provides? pkg (car ls))) res)
        (lp (cdr ls) res ignored))
       (else
        (let* ((current-version
                (cond ((assoc (car ls) current)
                       => (lambda (x) (package-version (cdr x))))
                      (else #f)))
               (candidates
                (filter
                 (lambda (pkg)
                   (and (package-provides? pkg (car ls))
                        (or (not current-version)
                            (version>? (package-version pkg)
                                       current-version))))
                 (cdr repo))))
          (cond
           ((member (car ls) ignored)
            (lp (cdr ls) res ignored))
           ((and (null? candidates) (assoc (car ls) current))
            (if (member (car ls) lib-names)
                (warn "skipping already installed library" (car ls)))
            (lp (cdr ls) res (cons (car ls) ignored)))
           ((and (null? candidates) (member (car ls) lib-names))
            (die 2 "Can't find package: " (car ls)))
           ((null? candidates)
            (if (yes-or-no? cfg "Can't find package: " (car ls)
                            ".  Proceed anyway?")
                (lp (cdr ls) res (cons (car ls) ignored))
                (exit 2)))
           (else
            (let ((pkg (select-best-candidate impl cfg repo candidates)))
              (lp (append (package-dependencies pkg) (cdr ls))
                  (cons pkg res)
                  ignored))))))))))

;; First lookup dependencies for all implementations so we can
;; download in a single batch.  Then perform the installations a
;; single implementation at a time.
(define (command/install cfg spec . args)
  (let* ((repo (maybe-update-repository cfg))
         (impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (lib-names (map parse-library-name args))
         (impl-pkgs
          (map (lambda (impl cfg)
                 (expand-package-dependencies repo impl cfg lib-names))
               impls
               impl-cfgs)))
    (for-each
     (lambda (impl cfg pkgs)
       (install-for-implementation repo impl cfg pkgs))
     impls
     impl-cfgs
     impl-pkgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upgrade - upgrade installed packages.

;; With explicit packages same as install, but by default upgrade all
;; available packages.
(define (command/upgrade cfg spec . args)
  (if (pair? args)
      (apply command/install cfg spec args)
      (let* ((repo (maybe-update-repository cfg))
             (impls (conf-selected-implementations cfg))
             (impl-cfgs (map (lambda (impl)
                               (conf-for-implementation cfg impl))
                             impls)))
        (for-each
         (lambda (impl cfg)
           (let ((pkgs (map cdr (installed-libraries impl cfg))))
             (install-for-implementation repo impl cfg pkgs)))
         impls
         impl-cfgs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Status - show the status of installed libraries.

(define (command/status cfg spec . args)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls)))
    (for-each
     (lambda (impl impl-cfg)
       (cond
        ((pair? (cdr impls))
         (if (not (eq? impl (car impls)))
             (display "\n"))
         (display impl)
         (display ":\n")))
       (summarize-libraries
        impl-cfg
        (if (pair? args)
            (lookup-installed-libraries
             impl impl-cfg (map parse-library-name args))
            (installed-libraries impl impl-cfg))))
     impls
     impl-cfgs)))

;; Abstract user interface for the snow command.  This could be
;; substituted with a different implementation to provide a GUI.

(define (message . args)
  (for-each display args)
  (newline))

(define (info . args)
  (apply message args))

(define (warn msg . args)
  (let ((err (current-error-port)))
    (display "WARNING: " err)
    (display msg err)
    (display ": " err)
    (if (and (pair? args) (null? (cdr args)))
        (write (car args) err)
        (for-each (lambda (x) (display "\n  " err) (write x err)) args))
    (newline err)))

(define (die x . args)
  (let ((n (if (number? x) x 2))
        (args (if (number? x) args (cons x args)))
        (err (current-error-port)))
    (for-each (lambda (x) (display x err)) args)
    (newline err)
    (exit n)))

(define input-history #f)

(define (conf-input-history-file cfg)
  (or (conf-get cfg 'input-history)
      (string-append (or (conf-get cfg 'snow-dir)
                         (string-append (get-environment-variable "HOME")
                                        "/.snow"))
                     "/input-history.scm")))

(define (restore-history cfg)
  (let ((history-file (conf-input-history-file cfg)))
    (set! input-history
          (or (guard (exn (else #f))
                (list->history (call-with-input-file history-file read)))
              (make-history)))))

(define (save-history cfg)
  (let ((history-file (conf-input-history-file cfg)))
    (guard (exn (else (warn "couldn't save history to " history-file)))
      (call-with-output-file history-file
        (lambda (out)
          (write (remove (lambda (x) (equal? x ""))
                         (history->list input-history))
                 out))))))

(define (input cfg name prompt . o)
  (let ((proc (or (and (pair? o) (car o)) (lambda (x) x)))
        (check (or (and (pair? o) (pair? (cdr o)) (cadr o))
                   (lambda (str res lp) res))))
    (let lp ((reason #f))
      (cond
       ((and (not reason) (conf-get cfg name))
        => (lambda (res) (check "" res lp)))
       (else
        (if reason
            (show #t reason fl))
        (let ((str (edit-line 'prompt: (lambda () (show #f prompt))
                              'history: input-history)))
          (history-insert! input-history str)
          (check str (proc str) lp)))))))

(define (input-number cfg name prompt . o)
  (let* ((default (and (pair? o) (car o)))
         (lo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (hi (and (pair? o) (pair? (cdr o)) (pair? (cddr o)) (car (cddr o))))
         (prompt
          (if default (each prompt " [default=" default "]: ") prompt))
         (proc (lambda (str)
                 (if (and default (equal? str ""))
                     default
                     (string->number str))))
         (check
          (lambda (str res fail)
            (cond
             ((not (number? res))
              (fail "not a valid number"))
             ((and lo (< res lo))
              (fail (each "too low, must be greater than " lo)))
             ((and hi (> res hi))
              (fail (each "too high, must be less than " hi)))
             (else
              res)))))
    (input cfg name prompt proc check)))

(define (yes-or-no? cfg . prompt)
  (define (is-true? str)
    (and (member (string-downcase str) '("#t" "y" "yes")) #t))
  (input cfg 'always-yes? (each (each-in-list prompt) " [y/n]: ") is-true?))

;; general utils

(define (read-from-string str)
  (call-with-input-string str read))

(define (display-to-string x)
  (cond ((string? x) x)
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (call-with-output-string (lambda (out) (display x out))))))

(define (maybe-parse-hex x)
  (if (string? x) (hex-string->bytevector x) x))

;; rsa key utils

(define (lookup-digest name)
  (case name
    ((md5) md5)
    ((sha-224) sha-224)
    ((sha-256) sha-256)
    (else (error "unknown digest: " name))))

(define (rsa-identity=? email)
  (lambda (x)
    (cond ((not email) #f)
          ((assoc-get x 'email eq?)
           => (lambda (e) (string-ci=? email e)))
          (else #f))))

(define (extract-rsa-key ls name)
  (define (hex x)
    (if (integer? x) x (string->number x 16)))
  (cond
   ((assq name ls)
    => (lambda (x)
         (let ((bits (assoc-get ls 'bits))
               (modulus (assoc-get (cdr x) 'modulus))
               (exponent (assoc-get (cdr x) 'exponent)))
           (and bits modulus exponent
                (if (eq? name 'private-key)
                    (make-rsa-key (hex bits) (hex modulus) #f (hex exponent))
                    (make-rsa-key (hex bits) (hex modulus)
                                  (hex exponent) #f))))))
   (else #f)))

(define (extract-rsa-private-key ls)
  (extract-rsa-key ls 'private-key))

(define (extract-rsa-public-key ls)
  (extract-rsa-key ls 'public-key))

;; repositories

(define (repo-url repo)
  (and (pair? repo) (assoc-get (cdr repo) 'url eq?)))

(define (repo-find-publisher repo email)
  (find (rsa-identity=? email)
        (filter (lambda (x) (and (pair? x) (eq? 'publisher (car x))))
                (cdr repo))))

;; packages

(define (package? x)
  (and (pair? x) (eq? 'package (car x)) (every pair? (cdr x))))

(define (package-name package)
  (and (pair? package)
       (eq? 'package (car package))
       (cond ((assoc-get (cdr package) 'name)
              => (lambda (x) (and (pair? x) x)))
             ((assq 'library (cdr package))
              => (lambda (x) (library-name (cdr x))))
             ((assq 'progam (cdr package))
              => (lambda (x) (program-name (cdr x))))
             (else #f))))

(define (package-email pkg)
  (and (package? pkg)
       (let ((sig (assq 'signature (cdr pkg))))
         (and (pair? sig)
              (assoc-get (cdr sig) 'email eq?)))))

(define (package-author repo pkg . o)
  (and (package? pkg)
       (let ((email (package-email pkg))
             (show-email? (and (pair? o) (car o))))
         (or (cond
              ((repo-find-publisher repo email)
               => (lambda (pub)
                    (let ((name (assoc-get pub 'name)))
                      (if (and name show-email?)
                          (string-append name " <" (or email "") ">")
                          (or name email "")))))
              (else #f))
             email))))

(define (package-url repo pkg)
  (let ((url (and (pair? pkg) (assoc-get (cdr pkg) 'url eq?))))
    (and url
         (uri-resolve url (string->path-uri 'http (repo-url repo))))))

(define (package-version pkg)
  (and (pair? pkg) (assoc-get (cdr pkg) 'version eq?)))

(define (package-digest-mismatches cfg pkg raw)
  (let ((size (assoc-get (cdr pkg) 'size))
        (actual-size (bytevector-length raw)))
    (if (and (integer? size) (not (= size actual-size)))
        `(size: expected: ,size actual: ,actual-size)
        (let* ((digest-name (assoc-get (cdr pkg) 'digest #f 'sha-256))
               (digest (assoc-get (cdr pkg) digest-name))
               (actual-digest ((lookup-digest digest-name) raw)))
          (and digest
               (not (equal? digest actual-digest))
               `(digest: ,digest-name expected: ,digest
                         actual: ,actual-digest))))))

(define (package-digest-ok? cfg pkg raw)
  (not (package-digest-mismatches cfg pkg raw)))

(define (package-signature-mismatches repo cfg pkg raw)
  (let* ((sig-spec (assoc-get-list (cdr pkg) 'signature))
         (digest-name (assoc-get sig-spec 'digest #f 'sha-256))
         (digest (assoc-get sig-spec digest-name))
         (sig (assoc-get sig-spec 'rsa))
         (email (assoc-get sig-spec 'email))
         (rsa-key-sexp (repo-find-publisher repo email))
         (rsa-key (and (pair? rsa-key-sexp)
                       (extract-rsa-public-key (cdr rsa-key-sexp)))))
    (cond
     ((not email)
      `(sign: missing-email ,sig-spec))
     ((not rsa-key)
      `(sign: unknown-publisher: ,email))
     ((not (rsa-verify? rsa-key
                        (maybe-parse-hex digest)
                        (maybe-parse-hex sig)))
      `(sign: rsa-signature-invalid: digest: ,digest sig: ,sig
              actual: ,(rsa-verify rsa-key (maybe-parse-hex digest))))
     (else #f))))

(define (package-signature-ok? cfg pkg raw)
  (not (package-signature-mismatches cfg pkg raw)))

(define (failure str . args)
  (let ((out (open-output-string)))
    (display str out)
    (cond
     ((pair? args)
      (display ":" out)
      (for-each (lambda (x) (display " " out) (write x out)) args)))
    (get-output-string out)))

(define (invalid-library-reason lib)
  (cond
   ((not (list? lib)) "library must be a list")
   ((not (list? (library-name lib)))
    (failure "library name must be a list" (library-name lib)))
   ((not (every (lambda (x) (or (symbol? x) (integer? x))) (library-name lib)))
    (failure "library name must contain only symbols or integers"
             (library-name lib)))
   (else #f)))

(define (valid-library? lib)
  (not (invalid-library-reason lib)))

(define (invalid-package-reason pkg)
  (cond
   ((not (list? pkg))
    "package must be a list")
   ((not (string? (package-version pkg)))
    (failure "package-version is not a string" (package-version pkg)))
   (else
    (let ((libs (package-libraries pkg)))
      (cond
       ((not (pair? libs)) "package must contain at least one library")
       ((any invalid-library-reason libs))
       (else #f))))))

(define (valid-package? pkg)
  (not (invalid-package-reason pkg)))

(define (package-libraries package)
  (and (package? package) (filter library? (cdr package))))

(define (package-programs package)
  (and (package? package) (filter program? (cdr package))))

(define (package-provides? package name)
  (and (pair? package)
       (eq? 'package (car package))
       (or (equal? name (assoc-get (cdr package) 'name))
           (find (lambda (x) (equal? name (library-name x)))
                 (package-libraries package)))))

(define (package-dependencies package)
  (append-map library-dependencies
              (package-libraries package)))

(define (package-installed-files pkg)
  (or (and (pair? pkg) (assoc-get-list (cdr pkg) 'installed-files)) '()))

(define (library-name->path name)
  (if (null? name)
      ""
      (call-with-output-string
        (lambda (out)
          (let lp ((name name))
            (display (car name) out)
            (cond ((pair? (cdr name))
                   (write-char #\/ out)
                   (lp (cdr name)))))))))

;; map a library to the path name it would be found in (sans extension)
(define (library->path library)
  (library-name->path (library-name library)))

;; find the library declaration file for the given library
(define (get-library-file cfg library)
  (or (assoc-get library 'path)
      (string-append (library->path library) "."
                     (conf-get cfg 'library-extension "sld"))))

(define (package->path pkg)
  (library-name->path (package-name pkg)))

(define (package-name->meta-file cfg name)
  (let ((path (library-name->path name)))
    (string-append (path-directory path) "/."
                   (path-strip-directory path) ".meta")))

(define (get-package-meta-file cfg pkg)
  (package-name->meta-file cfg (package-name pkg)))

(define (get-library-meta-file cfg lib)
  (package-name->meta-file cfg (library-name lib)))

;; libraries

(define (library? x)
  (and (pair? x) (eq? 'library (car x)) (every pair? (cdr x))))

(define (library-name lib)
  (and (pair? lib) (assoc-get (cdr lib) 'name eq?)))

(define (library-url lib)
  (and (pair? lib) (assoc-get (cdr lib) 'url eq?)))

(define (library-dependencies lib)
  (cond ((assq 'depends (cdr lib)) => cdr)
        (else '())))

(define (parse-library-name str)
  (cond
   ((pair? str) str)
   ((equal? "" str) (error "empty library name"))
   ((eqv? #\( (string-ref str 0)) (read-from-string str))
   (else (map (lambda (x) (or (string->number x) (string->symbol x)))
              (string-split str #\.)))))

(define (check-cond-expand config test)
  (define (library-installed? config name)
    ;; assume it could be installed for now
    #t)
  (cond
   ((symbol? test)
    (or (eq? 'else test) (memq test (conf-get-list config 'features))))
   ((pair? test)
    (case (car test)
      ((not) (not (check-cond-expand config (cadr test))))
      ((and) (every (lambda (x) (check-cond-expand config x)) (cdr test)))
      ((or) (any (lambda (x) (check-cond-expand config x)) (cdr test)))
      ((library) (every (lambda (x) (library-installed? config x)) (cdr test)))
      (else
       (warn "unknown cond-expand form" test)
       #f)))
   (else #f)))

;; We can't use the native library system introspection since we may
;; be analyzing a library which can't be loaded in the native system.
(define (library-analyze config file)
  (let ((sexp (call-with-input-file file read)))
    (and (list? sexp)
         (memq (car sexp) '(define-library library define-module module))
         (let analyze ((ls (cddr sexp)))
           (cond
            ((null? ls) '())
            (else
             (append
              (case (caar ls)
                ((cond-expand)
                 (cond
                  ((find (lambda (x) (check-cond-expand config (car x))) (cdar ls))
                   => (lambda (x) (analyze (cdr x))))
                  (else (analyze (cdr ls)))))
                (else (list (car ls))))
              (analyze (cdr ls)))))))))

(define (library-include-files config file)
  (let ((lib (library-analyze config file))
        (dir (path-directory file)))
    (append-map
     (lambda (x) (map (lambda (y) (make-path dir y)) (cdr x)))
     (filter (lambda (x) (and (pair? x) (memq (car x) '(include include-ci))))
             lib))))

(define (library-rewrite-includes x rules)
  (define (recurse x) (library-rewrite-includes x rules))
  (define (rewrite x)
    (cond ((any (lambda (r) (and (pair? r) (equal? x (car r)))) rules) => cdr)
          (else x)))
  (cond
   ((pair? x)
    (case (car x)
      ((include include-ci)
       (cons (car x) (map rewrite (cdr x))))
      ((cond-expand)
       (cons (car x)
             (map (lambda (y) (cons (car y) (map recurse (cdr y)))) (cdr x))))
      ((define-library library)
       (cons (car x) (map recurse (cdr x))))
      (else x)))
   (else x)))

;; programs

(define (program? x)
  (and (pair? x) (eq? 'program (car x)) (every pair? (cdr x))))

(define (program-name prog)
  (and (pair? prog)
       (cond ((assoc-get (cdr prog) 'name eq?))
             ((assoc-get (cdr prog) 'path eq?)
              => (lambda (p) (list (string->symbol (path-strip-directory p)))))
             (else #f))))

(define (get-program-file cfg prog)
  (cond ((assoc-get prog 'path))
        ((assoc-get prog 'name)
         => (lambda (name) (library-name->path (last name))))
        (else (error "program missing path: " prog))))

(define (program-install-name prog)
  (or (assoc-get (cdr prog) 'install-name eq?)
      (path-strip-extension
       (path-strip-directory
        (assoc-get (cdr prog) 'path eq?)))))

(define-library (chibi snow utils)
  (export copy-file call-with-temp-file call-with-temp-dir)
  (import (scheme base)
          (scheme file)
          (scheme time)
          (srfi 33)
          (chibi filesystem)
          (chibi pathname)
          (chibi process)
          (chibi snow interface))
  (include "utils.scm"))

(define-library (chibi snow package)
  (export package? library? program?
          package-name package-email package-url package-version
          package-libraries package-programs
          package-provides? package-dependencies
          package-installed-files package-author
          package-digest-mismatches package-signature-mismatches
          package-digest-ok? package-signature-ok?
          package->path package-name->meta-file
          get-package-meta-file get-library-meta-file
          library-name->path library->path get-library-file
          library-url library-name parse-library-name library-name->path
          library-analyze library-include-files library-dependencies
          library-rewrite-includes
          get-program-file program-name program-install-name
          invalid-package-reason valid-package?
          invalid-library-reason valid-library?
          repo-find-publisher lookup-digest rsa-identity=?
          extract-rsa-private-key extract-rsa-public-key)
  (import (chibi)
          (srfi 1)
          (chibi snow interface)
          (chibi bytevector)
          (chibi config)
          (chibi crypto md5)
          (chibi crypto rsa)
          (chibi crypto sha2)
          (chibi pathname)
          (chibi string)
          (chibi uri))
  (include "package.scm"))

(define-library (chibi snow interface)
  (export warn info message die input input-number yes-or-no?
          restore-history save-history)
  (import (scheme base) (scheme char) (scheme read) (scheme write)
          (scheme file) (scheme process-context) (srfi 1)
          (chibi config) (chibi show) (chibi stty) (chibi term edit-line))
  (include "interface.scm"))

;;> Copies the file \var{from} to \var{to}.

(define (copy-file from to)
  (let ((in (open-binary-input-file from))
        (out (open-binary-output-file to)))
    (let lp ()
      (let ((n (read-u8 in)))
        (cond ((eof-object? n) (close-input-port in) (close-output-port out))
              (else (write-u8 n out) (lp)))))))

(define (call-with-temp-file template proc)
  (let ((base (string-append
               "/tmp/" (path-strip-extension template)
               "-" (number->string (current-process-id)) "-"
               (number->string (exact (round (current-second)))) "-"))
        (ext (or (path-extension template) "tmp")))
    (let lp ((i 0))
      (let ((path (string-append base (number->string i) "." ext)))
        (cond
         ((> i 100)  ;; give up after too many tries regardless
          (die 2 "Repeatedly failed to generate temp file in /tmp"))
         ((file-exists? path)
          (lp (+ i 1)))
         (else
          (let ((fd (open path
                          (bitwise-ior open/write open/create open/exclusive))))
            (if (not fd)
                (if (file-exists? path) ;; created between test and open
                    (lp (+ i 1))
                    (die 2 "Couldn't generate temp file in /tmp " path))
                (let* ((out (open-output-file-descriptor fd #o700))
                       (res (proc path out)))
                  (close-output-port out)
                  (delete-file path)
                  res)))))))))

(define (call-with-temp-dir template proc)
  (let ((base (string-append
               "/tmp/" template
               "-" (number->string (current-process-id)) "-"
               (number->string (exact (round (current-second)))) "-")))
    (let lp ((i 0))
      (let ((path (string-append base (number->string i))))
        (cond
         ((> i 100)  ;; give up after too many tries
          (die 2 "Repeatedly failed to generate temp dir in /tmp " path))
         ((file-exists? path)
          (lp (+ i 1)))
         ((create-directory path #o700)
          (let ((res (proc path)))
            (delete-file-hierarchy path)
            res)))))))

(define-library (chibi snow commands)
  (export command/package
          command/gen-key
          command/reg-key
          command/sign
          command/verify
          command/upload
          command/install
          command/remove
          command/search
          command/show
          command/status
          command/update
          command/upgrade)
  (import (scheme base)
          (scheme eval)
          (scheme file)
          (scheme process-context)
          (scheme time)
          (scheme read)
          (scheme write)
          (srfi 1)
          (srfi 27)
          (srfi 33)
          (srfi 95)
          (chibi snow interface)
          (chibi snow package)
          (chibi snow utils)
          (chibi bytevector)
          (chibi config)
          (chibi crypto md5)
          (chibi crypto rsa)
          (chibi crypto sha2)
          (chibi doc)
          (chibi filesystem)
          (chibi io)
          (chibi match)
          (chibi net http)
          (chibi process)
          (chibi pathname)
          (chibi regexp)
          (chibi show)
          (chibi show pretty)
          (chibi string)
          (chibi sxml)
          (chibi system)
          (chibi tar)
          (chibi zlib))
  (include "commands.scm"))

(define-library (chibi base64)
  (export base64-encode base64-encode-string base64-encode-bytevector
          base64-decode base64-decode-string base64-decode-bytevector
          base64-encode-header)
  (import (scheme base) (srfi 33) (chibi io)
          (only (chibi) string-concatenate))
  (include "base64.scm"))

(define-library (chibi type-inference)
  (export type-analyze-module type-analyze procedure-signature
          type=? type-subset?)
  (import (chibi) (srfi 1) (srfi 38) (srfi 69)
          (chibi modules) (chibi ast) (chibi match))
  (include "type-inference.scm"))


(define-library (chibi parse common)
  (export parse-integer parse-unsigned-integer parse-c-integer
          parse-real parse-complex
          parse-identifier parse-delimited parse-separated parse-records
          parse-space parse-binary-op
          parse-ipv4-address parse-ipv6-address parse-ip-address
          parse-domain parse-common-domain parse-email parse-uri
          char-hex-digit? char-octal-digit?)
  (import (chibi) (chibi parse))
  (include "common.scm"))

(define (char-hex-digit? ch)
  (or (char-numeric? ch)
      (memv (char-downcase ch) '(#\a #\b #\c #\d #\e #\f))))

(define (char-octal-digit? ch)
  (and (char? ch) (char<=? #\0 ch #\7)))

(define (parse-assert-range proc lo hi)
  (if (or lo hi)
      (parse-assert proc (lambda (n)
                          (and (or (not lo) (<= lo n))
                               (or (not hi) (<= n hi)))))
      proc))

(define (parse-unsigned-integer . o)
  (let ((lo (and (pair? o) (car o)))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (parse-assert-range
     (parse-map (parse-token char-numeric?) string->number)
     lo hi)))

(define (parse-sign+)
  (parse-or (parse-char #\+) (parse-char #\-)))

(define (parse-sign)
  (parse-or (parse-sign+) parse-epsilon))

(define (parse-integer . o)
  (let ((lo (and (pair? o) (car o)))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (parse-assert-range
     (parse-map-substring
      (parse-seq (parse-sign) (parse-token char-numeric?)
                 ;; (parse-not (parse-or (parse-sign) (parse-char #\.)))
                 )
      string->number)
     lo hi)))

(define (parse-c-integer)
  (parse-or
   (parse-map (parse-seq (parse-string "0x") (parse-token char-hex-digit?))
              (lambda (x) (string->number (cadr x) 16)))
   (parse-map (parse-seq (parse-string "0") (parse-token char-octal-digit?))
              (lambda (x) (string->number (cadr x) 8)))
   (parse-integer)))

(define (parse-real)
  (parse-map-substring
   (parse-seq
    (parse-or
     (parse-seq (parse-sign) (parse-repeat+ (parse-char char-numeric?))
                (parse-optional
                 (parse-seq (parse-char #\.)
                            (parse-repeat (parse-char char-numeric?)))))
     (parse-seq (parse-sign) (parse-char #\.)
                (parse-repeat+ (parse-char char-numeric?))))
    (parse-optional
     (parse-seq (parse-char (lambda (ch) (eqv? #\e (char-downcase ch))))
                (parse-sign)
                (parse-repeat+ (parse-char char-numeric?)))))
   string->number))

(define (parse-imag)
  (parse-or (parse-char #\i) (parse-char #\I)))

(define (parse-complex)
  (parse-map-substring
   (parse-or
    (parse-seq (parse-real) (parse-sign+) (parse-real) (parse-imag))
    (parse-seq (parse-real) (parse-imag))
    (parse-real))
   string->number))

(define (parse-identifier . o)
  ;; Slightly more complicated than mapping parse-token because the
  ;; typical identifier syntax has different initial and subsequent
  ;; char-sets.
  (let* ((init?
          (if (pair? o)
              (car o)
              (lambda (ch) (or (eqv? #\_ ch) (char-alphabetic? ch)))))
         (init (parse-char init?))
         (subsequent
          (parse-char
           (if (and (pair? o) (pair? (cdr o)))
               (cadr o)
               (lambda (ch) (or (init? ch) (char-numeric? ch)))))))
    (lambda (source0 index0 sk0 fk0)
      (init
       source0
       index0
       (lambda (res source index fk2)
         (let lp ((s source) (i index))
           (subsequent
            s i (lambda (r s i fk) (lp s i))
            (lambda (s i r)
              (sk0 (string->symbol (parse-stream-substring source0 index0 s i))
                   s i fk0)))))
       fk0))))

(define (parse-delimited . o)
  (let ((delim (if (pair? o) (car o) #\"))
        (esc (if (and (pair? o) (pair? (cdr o))) (cadr o) #\\))
        (parse-esc (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                       (car (cddr o))
                       parse-anything)))
    (parse-map
     (parse-seq
      (parse-char delim)
      (parse-repeat
       (parse-or (parse-char
                  (lambda (ch)
                    (and (not (eqv? ch delim)) (not (eqv? ch esc)))))
                 (parse-map (parse-seq (parse-char esc)
                                       (if (eqv? delim esc)
                                           (parse-char esc)
                                           parse-esc))
                            cadr)))
      (parse-char delim))
     (lambda (res) (list->string (cadr res))))))

(define (parse-separated . o)
  (let* ((sep (if (pair? o) (car o) #\,))
         (o1 (if (pair? o) (cdr o) '()))
         (delim (if (pair? o1) (car o1) #\"))
         (o2 (if (pair? o1) (cdr o1) '()))
         (esc (if (pair? o2) (car o2) delim))
         (o3 (if (pair? o2) (cdr o2) '()))
         (ok?
          (if (pair? o3)
              (let ((pred (car o3)))
                (lambda (ch)
                  (and (not (eqv? ch delim))
                       (not (eqv? ch sep))
                       (pred ch))))
              (lambda (ch) (and (not (eqv? ch delim)) (not (eqv? ch sep))))))
         (parse-field
          (parse-or (parse-delimited delim esc)
                    (parse-map-substring
                     (parse-repeat+ (parse-char ok?))))))
    (parse-map
     (parse-seq parse-field
                (parse-repeat
                 (parse-map (parse-seq (parse-char sep) parse-field) cadr)))
     (lambda (res) (cons (car res) (cadr res))))))

(define (parse-records . o)
  (let* ((terms (if (pair? o) (car o) '("\r\n" "\n")))
         (terms (if (list? terms) terms (list terms)))
         (term-chars (apply append (map string->list terms)))
         (ok? (lambda (ch) (not (memv ch term-chars))))
         (o (if (pair? o) (cdr o) '()))
         (sep (if (pair? o) (car o) #\,))
         (o (if (pair? o) (cdr o) '()))
         (delim (if (pair? o) (car o) #\"))
         (o (if (pair? o) (cdr o) '()))
         (esc (if (pair? o) (car o) delim)))
    (parse-repeat
     (parse-map
      (parse-seq (parse-separated sep delim esc ok?)
                 (apply parse-or parse-end (map parse-string terms)))
      car))))

(define parse-space (parse-char char-whitespace?))

(define (op-value op) (car op))
(define (op-prec op) (cadr op))
(define (op-assoc op)
  (let ((tail (cddr op))) (if (pair? tail) (car tail) 'left)))
(define (op<? op1 op2)
  (or (< (op-prec op1) (op-prec op2))
      (and (= (op-prec op1) (op-prec op2))
           (eq? 'right (op-assoc op1)))))

;; rules are of the form ((op precedence [assoc=left]) ...)
;; ls is of the forms (expr [op expr] ...)
;; returns an sexp representation of the operator chain
(define (resolve-operator-precedence rules ls)
  (define (lookup op rules)
    (or (assoc op rules)
        (list op 0)))
  (define (join exprs ops)
    `((,(op-value (car ops)) ,(cadr exprs) ,(car exprs))
      ,@(cddr exprs)))
  (if (null? ls) (error "empty operator chain"))
  (let lp ((ls (cdr ls)) (exprs (list (car ls))) (ops '((#f -1))))
    ;; ls: trailing operations ([op expr] ...)
    ;; exprs: list of expressions (expr expr ...)
    ;; ops: operator chain, same len as exprs ((op prec [assoc]) ...)
    (cond
     ((and (null? ls) (null? (cdr exprs)))
      (car exprs))
     ((null? ls)
      (lp ls (join exprs ops) (cdr ops)))
     ((null? (cdr ls))
      (error "unbalanced expression" ls))
     (else
      (let ((op (lookup (car ls) rules))
            (expr (cadr ls)))
        (if (or (null? (cdr ops)) (op<? op (car ops)))
            (lp (cddr ls) (cons expr exprs) (cons op ops))
            (lp ls (join exprs ops) (cdr ops))))))))

(define (parse-binary-op op rules expr . o)
  (let* ((ws (if (pair? o) (car o) (parse-repeat parse-space)))
         (ws-right (if (and (pair? o) (pair? (cdr o))) (cadr o) ws)))
    (parse-map
     (parse-seq ws expr (parse-repeat (parse-seq ws-right op ws expr)))
     (lambda (x)
       (resolve-operator-precedence
        rules
        (cons (cadr x)
              (apply append
                     (map (lambda (y) (list (cadr y) (cadr (cddr y))))
                          (car (cddr x))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define parse-ipv4-digit (parse-integer 0 255))

(define parse-ipv4-address
  (parse-map-substring
   (parse-seq parse-ipv4-digit
              (parse-repeat (parse-seq (parse-char #\.) parse-ipv4-digit)
                            3 3))))

(define parse-ipv6-digit
  (parse-repeat (parse-char char-hex-digit?) 0 4))

(define parse-ipv6-address
  (parse-map-substring
   (parse-seq
    parse-ipv6-digit
    (parse-repeat (parse-seq (parse-repeat (parse-char #\:) 1 2)
                             parse-ipv6-digit)
                  1 7))))

(define parse-ip-address
  (parse-or parse-ipv4-address parse-ipv6-address))

(define parse-domain-atom
  (parse-token
   (lambda (ch)
     (or (char-alphabetic? ch) (char-numeric? ch) (memv ch '(#\- #\_))))))

(define (parse-domain)
  (parse-map-substring
   (parse-or
    parse-ip-address
    (parse-seq (parse-repeat (parse-seq parse-domain-atom (parse-char #\.)))
               parse-domain-atom))))

(define parse-top-level-domain
  (apply parse-or
         (parse-repeat (parse-char char-alphabetic?) 2 2)
         (map parse-string
              '("arpa" "com" "gov" "mil" "net" "org" "aero" "biz" "coop"
                "info" "museum" "name" "pro"))))

(define (parse-common-domain)
  (parse-map-substring
   (parse-seq (parse-repeat+ (parse-seq parse-domain-atom (parse-char #\.)))
              parse-top-level-domain)))

(define parse-email-local-part
  (parse-token
   (lambda (ch)
     (or (char-alphabetic? ch)
         (char-numeric? ch)
         (memv ch '(#\- #\_ #\. #\+))))))

(define (parse-email)
  ;; no quoted local parts or bang paths
  (parse-seq parse-email-local-part
             (parse-ignore (parse-char #\@))
             (parse-domain)))

(define (char-url-fragment? ch)
  (or (char-alphabetic? ch) (char-numeric? ch)
      (memv ch '(#\_ #\- #\+ #\\ #\= #\~ #\&))))

(define (char-url? ch)
  (or (char-url-fragment? ch) (memv ch '(#\. #\, #\;))))

(define (parse-url-char pred)
  (parse-or (parse-char pred)
            (parse-seq (parse-char #\%)
                       (parse-repeat (parse-char char-hex-digit?) 2 2))))

(define (parse-uri)
  (parse-seq
   (parse-identifier)
   (parse-ignore
    (parse-seq (parse-char #\:) (parse-repeat (parse-char #\/))))
   (parse-domain)
   (parse-optional (parse-map (parse-seq (parse-char #\:)
                                         (parse-integer 0 65536))
                              cadr))
   (parse-optional
    (parse-map-substring
     (parse-seq (parse-char #\/)
                (parse-repeat (parse-url-char char-url?)))))
   (parse-optional
    (parse-map
     (parse-seq (parse-ignore (parse-char #\?))
                (parse-map-substring
                 (parse-repeat (parse-url-char char-url?))))
     car))
   (parse-optional
    (parse-map
     (parse-seq (parse-ignore (parse-char #\#))
                (parse-map-substring
                 (parse-repeat (parse-url-char char-url-fragment?))))
     car))))
;; parse.scm -- Parser Combinators
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parse stream type
;;
;; Abstraction to treat ports as proper streams so that we can
;; backtrack from previous states.  A single Parse-Stream record
;; represents a single buffered chunk of text.

(define-record-type Parse-Stream
  (%make-parse-stream
   filename port buffer cache offset prev-char line column tail)
  parse-stream?
  ;; The file the data came from, for debugging and error reporting.
  (filename parse-stream-filename)
  ;; The underlying port.
  (port parse-stream-port)
  ;; A vector of characters read from the port.  We use a vector
  ;; rather than a string for guaranteed O(1) access.
  (buffer parse-stream-buffer)
  ;; A vector of caches corresponding to parser successes or failures
  ;; starting from the corresponding char.  Currently each cache is
  ;; just an alist, optimized under the assumption that the number of
  ;; possible memoized parsers is relatively small.  Note that
  ;; memoization is only enabled explicitly.
  (cache parse-stream-cache)
  ;; The current offset of filled characters in the buffer.
  ;; If offset is non-zero, (vector-ref buffer (- offset 1)) is
  ;; valid.
  (offset parse-stream-offset parse-stream-offset-set!)
  ;; The previous char before the beginning of this Parse-Stream.
  ;; Used for line/word-boundary checks.
  (prev-char parse-stream-prev-char)
  ;; The debug info for the start line and column of this chunk.
  (line parse-stream-line)
  (column parse-stream-column)
  ;; The successor Parse-Stream chunk, created on demand and filled
  ;; from the same port.
  (tail %parse-stream-tail %parse-stream-tail-set!))

;; We want to balance avoiding reallocating buffers with avoiding
;; holding many memoized values in memory.
(define default-buffer-size 256)

(define (make-parse-stream filename . o)
  (let ((port (if (pair? o) (car o) (open-input-file filename)))
        (len (if (and (pair? o) (pair? (cdr o))) (cadr o) default-buffer-size)))
    (%make-parse-stream
     filename port (make-vector len #f) (make-vector len '()) 0 #f 0 0 #f)))

(define (file->parse-stream filename)
  (make-parse-stream filename (open-input-file filename)))

(define (string->parse-stream str)
  (make-parse-stream #f (open-input-string str)))

(define (parse-stream-tail source)
  (or (%parse-stream-tail source)
      (let* ((len (vector-length (parse-stream-buffer source)))
             (line-info (parse-stream-count-lines source))
             (line (+ (parse-stream-line source) (car line-info)))
             (col (if (zero? (car line-info))
                      (+ (parse-stream-column source) (cadr line-info))
                      (cadr line-info)))
             (tail (%make-parse-stream (parse-stream-filename source)
                                       (parse-stream-port source)
                                       (make-vector len #f)
                                       (make-vector len '())
                                       0
                                       (parse-stream-last-char source)
                                       line
                                       col
                                       #f)))
        (%parse-stream-tail-set! source tail)
        tail)))

(define (parse-stream-fill! source i)
  (let ((off (parse-stream-offset source))
        (buf (parse-stream-buffer source)))
    (if (<= off i)
        (do ((off off (+ off 1)))
            ((> off i) (parse-stream-offset-set! source off))
          (vector-set! buf off (read-char (parse-stream-port source))))
        #f)))

(define (parse-stream-start? source i)
  (and (zero? i) (not (parse-stream-prev-char source))))

(define (parse-stream-end? source i)
  (eof-object? (parse-stream-ref source i)))

(define (parse-stream-ref source i)
  (parse-stream-fill! source i)
  (vector-ref (parse-stream-buffer source) i))

(define (parse-stream-last-char source)
  (let ((buf (parse-stream-buffer source)))
    (let lp ((i (min (- (vector-length buf) 1) (parse-stream-offset source))))
      (if (negative? i)
          (parse-stream-prev-char source)
          (let ((ch (vector-ref buf i)))
            (if (eof-object? ch)
                (lp (- i 1))
                ch))))))

(define (parse-stream-char-before source i)
  (if (> i (parse-stream-offset source))
      (parse-stream-ref source (- i 1))
      (parse-stream-prev-char source)))

(define (parse-stream-max-char source)
  (let ((buf (parse-stream-buffer source)))
    (let lp ((i (min (- (vector-length buf) 1)
                     (parse-stream-offset source))))
      (if (or (negative? i)
              (char? (vector-ref buf i)))
          i
          (lp (- i 1))))))

(define (parse-stream-count-lines source . o)
  (let* ((buf (parse-stream-buffer source))
         (end (if (pair? o) (car o) (vector-length buf))))
    (let lp ((i 0) (from 0) (lines 0))
      (if (>= i end)
          (list lines (- i from) from)
          (let ((ch (vector-ref buf i)))
            (cond
             ((not (char? ch))
              (list lines (- i from) from))
             ((eqv? ch #\newline)
              (lp (+ i 1) i (+ lines 1)))
             (else
              (lp (+ i 1) from lines))))))))

(define (parse-stream-end-of-line source i)
  (let* ((buf (parse-stream-buffer source))
         (end (vector-length buf)))
    (let lp ((i i))
      (if (>= i end)
          i
          (let ((ch (vector-ref buf i)))
            (if (or (not (char? ch)) (eqv? ch #\newline))
                i
                (lp (+ i 1))))))))

(define (parse-stream-debug-info s i)
  ;; i is the failed parse index, but we want the furthest reached
  ;; location
  (if (%parse-stream-tail s)
      (parse-stream-debug-info (%parse-stream-tail s) i)
      (let* ((line-info
              (parse-stream-count-lines s (parse-stream-max-char s)))
             (line (+ (parse-stream-line s) (car line-info)))
             (col (if (zero? (car line-info))
                      (+ (parse-stream-column s) (cadr line-info))
                      (cadr line-info)))
             (from (car (cddr line-info)))
             (to (parse-stream-end-of-line s (+ from 1)))
             (str (parse-stream-substring s from s to)))
        (list line col str))))

(define (parse-stream-next-source source i)
  (if (>= (+ i 1) (vector-length (parse-stream-buffer source)))
      (parse-stream-tail source)
      source))

(define (parse-stream-next-index source i)
  (if (>= (+ i 1) (vector-length (parse-stream-buffer source)))
      0
      (+ i 1)))

(define (parse-stream-close source)
  (close-input-port (parse-stream-port source)))

(define (vector-substring vec start . o)
  (let* ((end (if (pair? o) (car o) (vector-length vec)))
         (res (make-string (- end start))))
    (do ((i start (+ i 1)))
        ((= i end) res)
      (string-set! res (- i start) (vector-ref vec i)))))

(define (parse-stream-in-tail? s0 s1)
  (let ((s0^ (%parse-stream-tail s0)))
    (or (eq? s0^ s1)
        (and s0^ (parse-stream-in-tail? s0^ s1)))))

(define (parse-stream< s0 i0 s1 i1)
  (if (eq? s0 s1)
      (< i0 i1)
      (parse-stream-in-tail? s0 s1)))

(define (parse-stream-substring s0 i0 s1 i1)
  (cond
   ((eq? s0 s1)
    (parse-stream-fill! s0 i1)
    (vector-substring (parse-stream-buffer s0) i0 i1))
   (else
    (let lp ((s (parse-stream-tail s0))
             (res (list (vector-substring (parse-stream-buffer s0) i0))))
      (let ((buf (parse-stream-buffer s)))
        (cond
         ((eq? s s1)
          (apply string-append
                 (reverse (cons (vector-substring buf 0 i1) res))))
         (else
          (lp (parse-stream-tail s)
              (cons (vector-substring buf 0) res)))))))))

(define (parse-stream-cache-cell s i f)
  (assv f (vector-ref (parse-stream-cache s) i)))

(define (parse-stream-cache-set! s i f x)
  (let ((cache (vector-ref (parse-stream-cache s) i)))
    (cond
     ((assv f cache)
      => (lambda (cell)
           ;; prefer longer matches
           (if (and (pair? (cdr cell))
                    (parse-stream< (car (cddr cell)) (cadr (cddr cell)) s i))
               (set-cdr! cell x))))
     (else
      (vector-set! (parse-stream-cache s) i (cons (cons f x) cache))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; the parser interface

(define (parse-failure s i reason)
  (let ((line+col (parse-stream-debug-info s i)))
    (error "incomplete parse at" (append line+col (list reason)))))

(define (call-with-parse f source index sk . o)
  (let ((s (if (string? source) (string->parse-stream source) source))
        (fk (if (pair? o) (car o) (lambda (s i reason) #f))))
    (f s index sk fk)))

(define (parse f source . o)
  (let ((index (if (pair? o) (car o) 0)))
    (call-with-parse f source index (lambda (r s i fk) r))))

(define (parse-fully f source . o)
  (let ((s (if (string? source) (string->parse-stream source) source))
        (index (if (pair? o) (car o) 0)))
    (call-with-parse
     f s index
     (lambda (r s i fk)
       (if (parse-stream-end? s i) r (fk s i "incomplete parse")))
     parse-failure)))

(define (parse-fold f kons knil source . o)
  (let lp ((p (if (string? source) (string->parse-stream source) source))
           (index (if (pair? o) (car o) 0))
           (acc knil))
    (f p index (lambda (r s i fk) (lp s i (kons r acc))) (lambda (s i r) acc))))

(define (parse->list f source . o)
  (reverse (apply parse-fold cons '() f source o)))

(define (parse-fully->list f source . o)
  (let lp ((s (if (string? source) (string->parse-stream source) source))
           (index (if (pair? o) (car o) 0))
           (acc '()))
    (f s index
       (lambda (r s i fk)
         (if (eof-object? r) (reverse acc) (lp s i (cons r acc))))
       (lambda (s i reason) (error "incomplete parse")))))

(define (parse-with-failure-reason f reason)
  (lambda (r s i fk)
    (f r s i (lambda (s i r) (fk s i reason)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; basic parsing combinators

(define parse-epsilon
  (lambda (source index sk fk)
    (sk #t source index fk)))

(define parse-anything
  (lambda (source index sk fk)
    (if (parse-stream-end? source index)
        (fk source index "end of input")
        (sk (parse-stream-ref source index)
            (parse-stream-next-source source index)
            (parse-stream-next-index source index)
            fk))))

(define parse-nothing
  (lambda (source index sk fk)
    (fk source index "nothing")))

(define (parse-or f . o)
  (if (null? o)
      f
      (let ((g (apply parse-or o)))
        (lambda (source index sk fk)
          (let ((fk2 (lambda (s i r)
                       (g source index sk fk
                          ;; (lambda (s2 i2 r2)
                          ;;   (fk s2 i2 `(or ,r ,r2)))
                          ))))
            (f source index sk fk2))))))

(define (parse-and f g)
  (lambda (source index sk fk)
    (f source index (lambda (r s i fk) (g source index sk fk)) fk)))

(define (parse-not f)
  (lambda (source index sk fk)
    (f source index (lambda (r s i fk) (fk s i "not"))
       (lambda (s i r) (sk #t source index fk)))))

(define (parse-seq-list o)
  (cond
   ((null? o)
    parse-epsilon)
   ((null? (cdr o))
    (let ((f (car o)))
      (lambda (s i sk fk)
        (f s i (lambda (r s i fk) (sk (list r) s i fk)) fk))))
   (else
    (let* ((f (car o))
           (o (cdr o))
           (g (car o))
           (o (cdr o))
           (g (if (pair? o)
                  (apply parse-seq g o)
                  (lambda (s i sk fk)
                    (g s i (lambda (r s i fk) (sk (list r) s i fk)) fk)))))
      (lambda (source index sk fk)
        (f source
           index
           (lambda (r s i fk)
             (g s i (lambda (r2 s i fk)
                      (let ((r2 (if (eq? r ignored-value) r2 (cons r r2))))
                        (sk r2 s i fk)))
                fk))
           fk))))))

(define (parse-seq . o)
  (parse-seq-list o))

(define (maybe-parse-seq ls)
  (if (null? (cdr ls)) (car ls) (parse-seq-list ls)))

(define (parse-optional f . o)
  (if (pair? o)
      (parse-optional (apply parse-seq f o))
      (lambda (source index sk fk)
        (f source index sk (lambda (s i r) (sk #f source index fk))))))

(define ignored-value (list 'ignore))

(define (parse-repeat f . o)
  (let ((lo (if (pair? o) (car o) 0))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (lambda (source0 index0 sk fk)
      (let repeat ((source source0) (index index0) (fk fk) (j 0) (res '()))
        (let ((fk (if (>= j lo)
                      (lambda (s i r) (sk (reverse res) source index fk))
                      fk)))
          (if (and hi (= j hi))
              (sk (reverse res) source index fk)
              (f source
                 index
                 (lambda (r s i fk) (repeat s i fk (+ j 1) (cons r res)))
                 fk)))))))

(define (parse-repeat+ f)
  (parse-repeat f 1))

(define (parse-map f proc)
  (lambda (source index sk fk)
    (f source index (lambda (res s i fk) (sk (proc res) s i fk)) fk)))

(define (parse-map-substring f . o)
  (let ((proc (if (pair? o) (car o) (lambda (res) res))))
    (lambda (source index sk fk)
      (f source
         index
         (lambda (res s i fk)
           (sk (proc (parse-stream-substring source index s i)) s i fk))
         fk))))

(define (parse-ignore f)
  (parse-map f (lambda (res) ignored-value)))

(define (parse-assert f check?)
  (lambda (source index sk fk)
    (f source
       index
       (lambda (res s i fk)
         (if (check? res) (sk res s i fk) (fk s i "assertion failed")))
       fk)))

(define (parse-atomic f)
  (lambda (source index sk fk)
    (f source index (lambda (res s i fk2) (sk res s i fk)) fk)))

(define (parse-commit f)
  (lambda (source index sk fk)
    (f source index (lambda (res s i fk) (sk res s i (lambda (s i r) #f))) fk)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; boundary checks

(define parse-beginning
  (lambda (source index sk fk)
    (if (parse-stream-start? source index)
        (sk #t source index fk)
        (fk source index "expected beginning"))))

(define parse-end
  (lambda (source index sk fk)
    (if (parse-stream-end? source index)
        (sk #t source index fk)
      (fk source index "expected end"))))

(define parse-beginning-of-line
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (or (not before) (eqv? #\newline before))
          (sk #t source index fk)
          (fk source index "expected beginning of line")))))

(define parse-end-of-line
  (lambda (source index sk fk)
    (if (or (parse-stream-end? source index)
            (eqv? #\newline (parse-stream-ref source index)))
        (sk #t source index fk)
        (fk source index "expected end of line"))))

(define (char-word? ch)
  (or (char-alphabetic? ch) (eqv? ch #\_)))

(define parse-beginning-of-word
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (and (or (not before) (not (char-word? before)))
               (not (parse-stream-end? source index))
               (char-word? (parse-stream-ref source index)))
          (sk #t source index fk)
          (fk source index "expected beginning of word")))))

(define parse-end-of-word
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (and before
               (char-word? before)
               (or (parse-stream-end? source index)
                   (not (char-word? (parse-stream-ref source index)))))
          (sk #t source index fk)
          (fk source index "expected end of word")))))

(define (parse-word . o)
  (let ((word (if (pair? o) (car o) (parse-token char-word?))))
    (lambda (source index sk fk)
      (parse-seq parse-beginning-of-word
                 word
                 parse-end-of-word))))

(define (parse-word+ . o)
  (let ((pred (if (pair? o)
                  (lambda (ch) (and (char-word? ch) ((car o) ch)))
                  char-word?)))
    (parse-word (parse-token pred))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; constant parsers

(define (parse-char-pred pred)
  (lambda (source index sk fk)
    (let ((ch (parse-stream-ref source index)))
      (if (and (char? ch) (pred ch))
          (sk ch
              (parse-stream-next-source source index)
              (parse-stream-next-index source index)
              fk)
          (fk source index "failed char pred")))))

(define (x->char-predicate x)
  (cond
   ((char? x)
    (lambda (ch) (eqv? ch x)))
   ((char-set? x)
    (lambda (ch) (and (char? ch) (char-set-contains? x ch))))
   ((procedure? x)
    (lambda (ch) (and (char? ch) (x ch))))
   (else
    (error "don't know how to handle char predicate" x))))

(define (parse-char x)
  (parse-char-pred (x->char-predicate x)))

(define (parse-not-char x)
  (let ((pred (x->char-predicate x)))
    (parse-char-pred (lambda (ch) (not (pred ch))))))

(define (parse-string x)
  (parse-map (parse-with-failure-reason
              (parse-seq-list (map parse-char (string->list x)))
              `(expected ,x))
             list->string))

(define (parse-token x)
  ;; (parse-map (parse-repeat+ (parse-char x)) list->string)
  ;; Tokens are atomic - we don't want to split them at any point in
  ;; the middle - so the implementation is slightly more complex than
  ;; the above.  With a sane grammar the result would be the same
  ;; either way, but this provides a useful optimization.
  (let ((f (parse-char x)))
    (lambda (source0 index0 sk fk)
      (let lp ((source source0) (index index0))
        (f source
           index
           (lambda (r s i fk) (lp s i))
           (lambda (s i r)
             (if (and (eq? source source0) (eqv? index index0))
                 (fk s i r)
                 (sk (parse-stream-substring source0 index0 source index)
                     source index fk))))))))

;; We provide a subset of SRE syntax, optionally interspersed with
;; existing parsers.  These are just translated directly into parser
;; combinators.  A future version may translate pieces into a
;; non-backtracking engine where possible.
(define (parse-sre x)
  (define (ranges->char-set ranges)
    (let lp ((ls ranges) (res (char-set)))
      (cond
       ((null? ls)
        res)
       ((string? (car ls))
        (lp (append (string->list (car ls)) (cdr ls)) res))
       ((null? (cdr ls))
        (error "incomplete range in / char-set" ranges))
       (else
        (let ((cs (ucs-range->char-set (char->integer (car ls))
                                       (+ 1 (char->integer (cadr ls))))))
          (lp (cddr ls) (char-set-union cs res)))))))
  (define (sre-list->char-set ls)
    (apply char-set-union (map sre->char-set ls)))
  (define (sre->char-set x)
    (cond
     ((char? x) (char-set x))
     ((string? x) (if (= 1 (string-length x))
                      (string->char-set x)
                      (error "multi-element string in char-set" x)))
     ((pair? x)
      (if (and (string? (car x)) (null? (cdr x)))
          (string->char-set (car x))
          (case (car x)
            ((/) (ranges->char-set (cdr x)))
            ((~) (char-set-complement (sre-list->char-set (cdr x))))
            ((-) (apply char-set-difference (map sre->char-set (cdr x))))
            ((&) (apply char-set-intersection (map sre->char-set (cdr x))))
            ((or) (sre-list->char-set (cdr x)))
            (else (error "unknown SRE char-set operator" x)))))
     (else (error "unknown SRE char-set" x))))
  (cond
   ((procedure? x)  ; an embedded parser
    x)
   ((or (char? x) (char-set? x))
    (parse-char x))
   ((string? x)
    (parse-string x))
   ((null? x)
    parse-epsilon)
   ((list? x)
    (case (car x)
      ((: seq) (parse-seq-list (map parse-sre (cdr x))))
      ((or) (apply parse-or (map parse-sre (cdr x))))
      ((and) (apply parse-and (map parse-sre (cdr x))))
      ((not) (apply parse-not (map parse-sre (cdr x))))
      ((*) (parse-repeat (maybe-parse-seq (map parse-sre (cdr x)))))
      ((+) (parse-repeat+ (maybe-parse-seq (map parse-sre (cdr x)))))
      ((?) (parse-optional (parse-seq-list (map parse-sre (cdr x)))))
      ((=> ->) (maybe-parse-seq (map parse-sre (cddr x))))
      ((word) (apply parse-word (cdr x)))
      ((word+) (apply parse-word+ (cdr x)))
      ((/ ~ & -) (parse-char (sre->char-set x)))
      (else
       (if (string? (car x))
           (parse-char (sre->char-set x))
           (error "unknown SRE operator" x)))))
   (else
    (case x
      ((any) parse-anything)
      ((nonl) (parse-char (lambda (ch) (not (eqv? ch #\newline)))))
      ((space whitespace) (parse-char char-whitespace?))
      ((digit numeric) (parse-char char-numeric?))
      ((alpha alphabetic) (parse-char char-alphabetic?))
      ((alnum alphanumeric)
       (parse-char-pred (lambda (ch) (or (char-alphabetic? ch) (char-numeric? ch)))))
      ((lower lower-case) (parse-char char-lower-case?))
      ((upper upper-case) (parse-char char-upper-case?))
      ((word) (parse-word))
      ((bow) parse-beginning-of-word)
      ((eow) parse-end-of-word)
      ((bol) parse-beginning-of-line)
      ((eol) parse-end-of-line)
      ((bos) parse-beginning)
      ((eos) parse-end)
      (else (error "unknown SRE parser" x))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; delayed combinators for self-referentiality

(define-syntax parse-lazy
  (syntax-rules ()
    ((parse-lazy f)
     (let ((g (delay f)))
       (lambda (source index sk fk)
         ((force g) source index sk fk))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; memoization wrapper for packrat-like parsing

;; debugging
(define *procedures* '())
(define (procedure-name f)
  (cond ((assq f *procedures*) => cdr) (else #f)))
(define (procedure-name-set! f name)
  (set! *procedures* (cons (cons f name) *procedures*)))

(define memoized-failure (list 'failure))

(define (parse-memoize name f)
  ;;(if (not (procedure-name f)) (procedure-name-set! f name))
  (lambda (source index sk fk)
    (cond
     ((parse-stream-cache-cell source index f)
      => (lambda (cell)
           (if (and (pair? (cdr cell)) (eq? memoized-failure (cadr cell)))
               (fk source index (cddr cell))
               (apply sk (append (cdr cell) (list fk))))))
     (else
      (f source
         index
         (lambda (res s i fk)
           (parse-stream-cache-set! source index f (list res s i))
           (sk res s i fk))
         (lambda (s i r)
           (if (not (pair? (parse-stream-cache-cell source index f)))
               (parse-stream-cache-set!
                source index f (cons memoized-failure r)))
           (fk s i r)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntactic sugar

;; The four basic interfaces are grammar, define-grammar, and their
;; unmemoized variants grammar/unmemoized and
;; define-grammar/unmemoized.  This is optimized for the common case -
;; generally you want to memoize grammars, and may or may not want to
;; memoize the smaller lexical components.

(define-syntax grammar/unmemoized
  (syntax-rules ()
    ((grammar/unmemoized init (rule (clause . action) ...) ...)
     (letrec ((rule (parse-or (grammar-clause clause . action) ...))
              ...)
       init))))

(define-syntax grammar
  (syntax-rules ()
    ((grammar init (rule (clause . action) ...) ...)
     (letrec ((rule
               (parse-memoize
                'rule
                (parse-or (grammar-clause clause . action) ...)))
              ...)
       init))))

(define-syntax define-grammar/unmemoized
  (syntax-rules ()
    ((define-grammar/unmemoized name (rule (clause . action) ...) ...)
     (begin
       (define rule (parse-or (grammar-clause clause . action) ...))
       ...
       (define name (list (cons 'rule rule) ...))))))

(define-syntax define-grammar
  (syntax-rules ()
    ((define-grammar name (rule (clause . action) ...) ...)
     (begin
       (define rule
         (parse-memoize 'rule (parse-or (grammar-clause clause . action) ...)))
       ...
       (define name (list (cons 'rule rule) ...))))))

;; Most of the implementation goes into how we parse a single grammar
;; clause.  This is hard to read if you're not used to CPS macros.

(define-syntax grammar-clause
  (syntax-rules ()
    ((grammar-clause clause . action)
     (grammar-extract clause () (grammar-action action)))))

(define-syntax grammar-extract
  (syntax-rules (unquote -> => : seq * + ? or and)
    ;; Named patterns
    ((grammar-extract (-> name pattern) bindings k)
     (grammar-extract pattern bindings (grammar-bind name k)))
    ((grammar-extract (-> name pattern ...) bindings k)
     (grammar-extract (: pattern ...) bindings (grammar-bind name k)))
    ;; Allow => as an alias for -> for SRE compatibility.
    ((grammar-extract (=> name pattern) bindings k)
     (grammar-extract pattern bindings (grammar-bind name k)))
    ((grammar-extract (=> name pattern ...) bindings k)
     (grammar-extract (: pattern ...) bindings (grammar-bind name k)))
    ((grammar-extract ,name bindings k)
     (grammar-bind name k (parse-sre name) bindings))
    ;; Walk container patterns.
    ((grammar-extract (: x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-seq (y ...) () k)))
    ((grammar-extract (* x) bindings k)
     (grammar-extract x bindings (grammar-map parse-repeat () () k)))
    ((grammar-extract (* x y ...) bindings k)
     (grammar-extract (: x y ...) bindings (grammar-map parse-repeat () () k)))
    ((grammar-extract (+ x) bindings k)
     (grammar-extract x bindings (grammar-map parse-repeat+ () () k)))
    ((grammar-extract (+ x y ...) bindings k)
     (grammar-extract (: x y ...) bindings (grammar-map parse-repeat+ () () k)))
    ((grammar-extract (? x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-optional (y ...) () k)))
    ((grammar-extract (or x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-or (y ...) () k)))
    ((grammar-extract (and x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-and (y ...) () k)))
    ;; Anything else is an implicitly quasiquoted SRE
    ((grammar-extract pattern bindings (k ...))
     (k ... (parse-sre `pattern) bindings))))

(define-syntax grammar-map
  (syntax-rules ()
    ((grammar-map f () (args ...) (k ...) x bindings)
     (k ... (f args ... x) bindings))
    ((grammar-map f (y . rest) (args ...) k x bindings)
     (grammar-extract y bindings (grammar-map f rest (args ... x) k)))))

(define-syntax grammar-action
  (syntax-rules (=>)
    ((grammar-action () parser bindings)
     ;; By default just return the result.
     (grammar-action (=> (lambda (r s i fk) r)) parser bindings))
    ((grammar-action (=> receiver) parser ((var tmp) ...))
     ;; Explicit => handler.
     (lambda (source index sk fk)
       (let ((tmp #f) ...)
         (parser source
                 index
                 (lambda (r s i fk)
                   (sk (receiver r s i fk) s i fk))
                 fk))))
    ((grammar-action (action-expr) parser ())
     ;; Fast path - no named variables.
     (let ((f parser))
       (lambda (source index sk fk)
         (f source index (lambda (r s i fk) (sk action-expr s i fk)) fk))))
    ((grammar-action (action-expr) parser ((var tmp) ...))
     (lambda (source index sk fk)
       (let ((tmp #f) ...)
         ;; TODO: Precompute static components of the parser.
         ;; We need to bind fresh variables on each parse, so some
         ;; components must be reified in this scope.
         (parser source
                 index
                 (lambda (r s i fk)
                   (sk (let ((var tmp) ...) action-expr) s i fk))
                 fk))))))

(define-library (chibi tar)
  (import (scheme base) (scheme file) (scheme time) (srfi 1) (srfi 33)
          (chibi string) (chibi binary-record)
          (chibi pathname) (chibi filesystem) (chibi system))
  (export
   ;; basic
   tar make-tar tar? read-tar write-tar
   ;; utilities
   tar-safe? tar-files tar-fold tar-extract tar-extract-file tar-create
   ;; accessors
   tar-path tar-mode tar-uid tar-gid
   tar-owner tar-group tar-size
   tar-time tar-type tar-link-name
   tar-path-set! tar-mode-set! tar-uid-set! tar-gid-set!
   tar-owner-set! tar-group-set! tar-size-set!
   tar-time-set! tar-type-set! tar-link-name-set!
   tar-device-major tar-device-major-set!
   tar-device-minor tar-device-minor-set!
   tar-ustar tar-ustar-set!)
  (include "tar.scm"))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (display-to-string x)
  (cond ((string? x) x)
        ((char? x) (string x))
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (error "don't know how to display as sxml" x))))

(define (html-display-escaped-attr str . o)
  (let ((start 0)
        (end (string-length str))
        (out (if (pair? o) (car o) (current-output-port))))
    (let lp ((from start) (to start))
      (if (>= to end)
          (display (substring str from to) out)
          (let ((c (string-ref str to)))
            (cond
             ((eq? c #\<)
              (display (substring str from to) out)
              (display "&lt;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\&)
              (display (substring str from to) out)
              (display "&amp;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\")
              (display (substring str from to) out)
              (display "&quot;" out)
              (lp (+ to 1) (+ to 1)))
             (else
              (lp from (+ to 1)))))))))

(define (html-escape-attr str)
  (call-with-output-string
    (lambda (out) (html-display-escaped-attr (display-to-string str) out))))

(define (html-attr->string attr)
  (if (cdr attr)
      (let ((val (if (pair? (cdr attr)) (cadr attr) (cdr attr))))
        (string-append (symbol->string (car attr))
                       "=\"" (html-escape-attr val) "\""))
      (symbol->string (car attr))))

(define (html-tag->string tag attrs)
  (let lp ((ls attrs) (res (list (symbol->string tag) "<")))
    (if (null? ls)
        (apply string-append (reverse (cons ">" res)))
        (lp (cdr ls) (cons (html-attr->string (car ls)) (cons " " res))))))

(define (html-display-escaped-string x . o)
  (let* ((str (display-to-string x))
         (start 0)
         (end (string-length str))
         (out (if (pair? o) (car o) (current-output-port))))
    (let lp ((from start) (to start))
      (if (>= to end)
          (display (substring str from to) out)
          (let ((c (string-ref str to)))
            (cond
             ((eq? c #\<)
              (display (substring str from to) out)
              (display "&lt;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\&)
              (display (substring str from to) out)
              (display "&amp;" out)
              (lp (+ to 1) (+ to 1)))
             (else
              (lp from (+ to 1)))))))))

(define (html-escape str)
  (call-with-output-string
    (lambda (out) (html-display-escaped-string str out))))

;; utility to render (valid, expanded) sxml as html
(define (sxml-display-as-html sxml . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (let lp ((sxml sxml))
      (cond
       ((pair? sxml)
        (let ((tag (car sxml)))
          (if (symbol? tag)
              (let ((rest (cdr sxml)))
                (cond
                 ((and (pair? rest)
                       (pair? (car rest))
                       (eq? '@ (caar rest)))
                  (display (html-tag->string tag (cdar rest)) out)
                  (for-each lp (cdr rest))
                  (display "</" out) (display tag out) (display ">" out))
                 (else
                  (display (html-tag->string tag '()) out)
                  (for-each lp rest)
                  (display "</" out) (display tag out) (display ">" out))))
              (for-each lp sxml))))
       ((null? sxml))
       (else (html-display-escaped-string sxml out))))))

(define (sxml->xml sxml)
  (call-with-output-string
    (lambda (out) (sxml-display-as-html sxml out))))

;; utility to render sxml as simple text, stripping all tags
(define (sxml-strip sxml)
  (call-with-output-string
    (lambda (out)
      (let strip ((x sxml))
        (cond
         ((pair? x)
          (for-each
           strip
           (if (and (pair? (cdr x)) (eq? '@ (cadr x))) (cddr x) (cdr x))))
         ((string? x)
          (display x out)))))))

;; utility to render sxml as text for viewing in a terminal
(define (sxml-display-as-text sxml . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (let lp ((sxml sxml))
      (cond
       ((pair? sxml)
        (let ((tag (car sxml)))
          (cond
           ;; skip headers and the menu
           ((or (memq tag '(head style script))
                (and (eq? 'div tag)
                     (pair? (cdr sxml))
                     (pair? (cadr sxml))
                     (eq? '@ (car (cadr sxml)))
                     (equal? '(id . "menu") (assq 'id (cdr (cadr sxml)))))))
           ;; recurse other tags, appending newlines for new sections
           ((symbol? tag)
            (for-each
             lp
             (if (and (pair? (cdr sxml)) (eq? '@ (cadr sxml)))
                 (cddr sxml)
                 (cdr sxml)))
            (if (memq tag '(p br h1 h2 h3 h4 h5 h6))
                (newline out)))
           (else
            (for-each lp sxml)))))
       ((null? sxml))
       (else (html-display-escaped-string sxml out))))))
;; Copyright (c) 2010-2014 Alex Shinn. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;;> A library to use ANSI escape codes to format text and background
;;> color, font weigh, and underlining.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-simple-escape-procedure parameter)
  (let ((code (string-append "\x1B;[" (number->string parameter) "m")))
    (lambda () code)))

(define (make-wrap-procedure start-escape end-escape)
  (lambda (str)
    (if (not (string? str))
        (error "argument must be a string" str))
    (if (ansi-escapes-enabled?)
        (string-append start-escape str end-escape)
        str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Some definitions are wrapped in begin in order to avoid Scribble
;; generating duplicate signatures.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Library}

(define black-escape
   (make-simple-escape-procedure 30))
(define red-escape
  (make-simple-escape-procedure 31))
(define green-escape
  (make-simple-escape-procedure 32))
(define yellow-escape
  (make-simple-escape-procedure 33))
(define blue-escape
  (make-simple-escape-procedure 34))
(define magenta-escape
  (make-simple-escape-procedure 35))
(define cyan-escape
  (make-simple-escape-procedure 36))
(define white-escape
  (make-simple-escape-procedure 37))

;;> Return a string consisting of an ANSI escape code to select the
;;> specified text color.
;;/

;;> Return a string consisting of an ANSI escape code to select the
;;> text color specified by the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments, each of which must be an exact
;;> integer in the range [0, 5].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 5)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 5)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 5)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B[38;5;"
   (number->string (+ (* 36 red-level) (* 6 green-level) blue-level 16))
   "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> text color specified by the \var{gray-level} argument, which must
;;> be an exact integer in the range [0, 23].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-escape gray-level)
  (when (not (and (exact-integer? gray-level) (<= 0 gray-level 23)))
    (error "invalid gray-level value" gray-level))
  (string-append "\x1B[38;5;"
                 (number->string (+ gray-level 232))
                 "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> default text color.

(define reset-color-escape
  (make-simple-escape-procedure 39))

(define black
  (make-wrap-procedure (black-escape)
                       (reset-color-escape)))
(define red
  (make-wrap-procedure (red-escape)
                       (reset-color-escape)))
(define green
  (make-wrap-procedure (green-escape)
                       (reset-color-escape)))
(define yellow
  (make-wrap-procedure (yellow-escape)
                       (reset-color-escape)))
(define blue
  (make-wrap-procedure (blue-escape)
                       (reset-color-escape)))
(define magenta
  (make-wrap-procedure (magenta-escape)
                       (reset-color-escape)))
(define cyan
  (make-wrap-procedure (cyan-escape)
                       (reset-color-escape)))
(define white
  (make-wrap-procedure (white-escape)
                       (reset-color-escape)))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects specified text color
;;> and a suffix that selects the default text color.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.
;;/

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> text color (obtained by calling the \scheme{rgb-escape} procedure
;;> with the values of the \var{red-level}, \var{green-level}, and
;;> \var{blue-level} arguments) and a suffix that selects the default
;;> text color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb red-level green-level blue-level)
  (make-wrap-procedure (rgb-escape red-level green-level blue-level)
                       (reset-color-escape)))

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> text color (obtained by calling the \scheme{gray-escape} procedure
;;> with the values of the \var{gray-level} argument) and a suffix
;;> that selects the default text color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray gray-level)
  (make-wrap-procedure (gray-escape gray-level)
                       (reset-color-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define black-background-escape
  (make-simple-escape-procedure 40))
(define red-background-escape
  (make-simple-escape-procedure 41))
(define green-background-escape
  (make-simple-escape-procedure 42))
(define yellow-background-escape
  (make-simple-escape-procedure 43))
(define blue-background-escape
  (make-simple-escape-procedure 44))
(define magenta-background-escape
  (make-simple-escape-procedure 45))
(define cyan-background-escape
  (make-simple-escape-procedure 46))
(define white-background-escape
  (make-simple-escape-procedure 47))

;;> Return a string consisting of an ANSI escape code to select the
;;> specified background color.
;;/

;;> Return a string consisting of an ANSI escape code to select the
;;> background color specified by the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments, each of which must be an exact
;;> integer in the range [0, 5].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-background-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 5)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 5)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 5)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B[48;5;"
   (number->string (+ (* 36 red-level) (* 6 green-level) blue-level 16))
   "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> background color specified by the \var{gray-level} argument, which
;;> must be an exact integer in the range [0, 23].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-background-escape gray-level)
  (when (not (and (exact-integer? gray-level) (<= 0 gray-level 23)))
    (error "invalid gray-level value" gray-level))
  (string-append "\x1B[48;5;"
                 (number->string (+ gray-level 232))
                 "m"))

;;> \procedure{(reset-background-color-escape)}
;;>
;;> Return a string consisting of an ANSI escape code to select the
;;> default background color.

(define reset-background-color-escape
  (make-simple-escape-procedure 49))

(define black-background
  (make-wrap-procedure (black-background-escape)
                       (reset-background-color-escape)))
(define red-background
  (make-wrap-procedure (red-background-escape)
                       (reset-background-color-escape)))
(define green-background
  (make-wrap-procedure (green-background-escape)
                       (reset-background-color-escape)))
(define yellow-background
  (make-wrap-procedure (yellow-background-escape)
                       (reset-background-color-escape)))
(define blue-background
  (make-wrap-procedure (blue-background-escape)
                       (reset-background-color-escape)))
(define magenta-background
  (make-wrap-procedure (magenta-background-escape)
                       (reset-background-color-escape)))
(define cyan-background
  (make-wrap-procedure (cyan-background-escape)
                       (reset-background-color-escape)))
(define white-background
  (make-wrap-procedure (white-background-escape)
                       (reset-background-color-escape)))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects specified background
;;> color and a suffix that selects the default background color.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.
;;/

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> background color (obtained by calling the \scheme{rgb-background-escape}
;;> procedure with the values of the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments) and a suffix that selects the
;;> default background color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-background red-level green-level blue-level)
  (make-wrap-procedure (rgb-background-escape red-level green-level blue-level)
                       (reset-background-color-escape)))

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> background color (obtained by calling the \scheme{gray-background-escape}
;;> procedure with the values of the \var{gray-level} argument) and a
;;> suffix that selects the default background color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-background gray-level)
  (make-wrap-procedure (gray-background-escape gray-level)
                       (reset-background-color-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select bold
;;> style.

(define bold-escape
  (make-simple-escape-procedure 1))

;;> Return a string consisting of an ANSI escape code to select non-bold
;;> style.

(define reset-bold-escape
  (make-simple-escape-procedure 22))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects bold style and a suffix
;;> that selects non-bold style.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define bold (make-wrap-procedure (bold-escape)
                                  (reset-bold-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select
;;> underlined style.

(define underline-escape
  (make-simple-escape-procedure 4))

;;> Return a string consisting of an ANSI escape code to select
;;> non-underlined style.

(define reset-underline-escape
  (make-simple-escape-procedure 24))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects underlined style and
;;> a suffix that selects non-underlined style.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define underline (make-wrap-procedure (underline-escape)
                                       (reset-underline-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select negative
;;> style (text in the background color and background in the text
;;> color).

(define negative-escape
  (make-simple-escape-procedure 7))

;;> Return a string consisting of an ANSI escape code to select positive
;;> style (text in the text color and background in the background
;;> color).

(define reset-negative-escape
  (make-simple-escape-procedure 27))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects negative style (text
;;> in the background color and background in the text color) and a
;;> suffix that selects positive style (text in the text color and
;;> background in the background color).
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define negative (make-wrap-procedure (negative-escape)
                                      (reset-negative-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> A parameter object that determines whether ANSI escapes are enabled
;;> in some of the preceding procedures. They are disabled if
;;> \scheme{(ansi-escapes-enabled?)} returns \scheme{#f}, and otherwise
;;> they are enabled.
;;>
;;> The initial value returned by \scheme{(ansi-escapes-enabled?)} is
;;> determined by the environment.
;;>
;;> If the environment variable \scheme{ANSI_ESCAPES_ENABLED} is set,
;;> its value determines the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)}. If the value of
;;> \scheme{ANSI_ESCAPES_ENABLED} is \scheme{"0"}, the initial value
;;> is \scheme{#f}, otherwise the initial value is \scheme{#t}.
;;>
;;> If the environment variable \scheme{ANSI_ESCAPES_ENABLED} is not
;;> set, but the environment variable \scheme{TERM} is set, the value
;;> of the latter determines the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)}. If the value of \scheme{TERM}
;;> is \scheme{"xterm"}, \scheme{"xterm-color"}, \scheme{"xterm-256color"},
;;> \scheme{"rxvt"}, \scheme{"kterm"}, \scheme{"linux"}, \scheme{"screen"},
;;> \scheme{"screen-256color"}, or \scheme{"vt100"}, the initial value
;;> is \scheme{#t}, otherwise the initial value is \scheme{#f}.
;;>
;;> If neither of the environment variables \scheme{ANSI_ESCAPES_ENABLED}
;;> and \scheme{TERM} are set, the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)} is \scheme{#f}.

(define ansi-escapes-enabled?
  (make-parameter
   (cond
    ((get-environment-variable "ANSI_ESCAPES_ENABLED")
     => (lambda (s) (not (equal? s "0"))))
    (else
     (member (get-environment-variable "TERM")
             '("xterm" "xterm-color" "xterm-256color" "rxvt" "kterm"
               "linux" "screen" "screen-256color" "vt100"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Notes}
;;>
;;> It is important to remember that the formatting procedures apply
;;> a prefix to set a particular graphics parameter and a suffix to
;;> reset the parameter to its default value. This can lead to surprises.
;;> For example, on an ANSI terminal, one might mistakenly expect the
;;> following to display GREEN in green text and then RED in red text:
;;>
;;> \codeblock{(display (red (string-append (green "GREEN") "RED")))}
;;>
;;> However, it will actually display GREEN in green text and then RED
;;> in the default text color. This is a limitation of ANSI control
;;> codes; graphics attributes are not saved to and restored from a
;;> stack, but instead are simply set. One way to display GREEN in
;;> green text and then RED in red text is:
;;>
;;> \codeblock{(display (string-append (green "GREEN") (red "RED")))}
;;>
;;> On the other hand, text color, background color, font weight (bold
;;> or default), underline (on or off), image (positive or negative)
;;> are orthogonal. So, for example, on an ANSI terminal the following
;;> should display GREEN in green text and then RED in red text, with
;;> both in bold and GREEN underlined.
;;>
;;> \codeblock{(display (bold (string-append (underline (green "GREEN")) (red "RED"))))}
;;>

(define-library (chibi term edit-line)
  (export make-line-editor edit-line edit-line-repl
          make-history history-insert! history-reset!
          history-commit! history->list list->history buffer->string
          make-buffer buffer-make-completer
          buffer-clear buffer-refresh buffer-draw
          buffer-row buffer-col
          make-keymap make-standard-keymap)
  (import (chibi) (chibi ast) (chibi stty) (chibi process) (srfi 9) (srfi 33))
  (include "edit-line.scm"))
;;;; edit-line.scm - pure scheme line editor
;;
;; Copyright (c) 2011-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; vt100 terminal utilities

(define (terminal-escape out ch arg)
  (write-char (integer->char 27) out)
  (write-char #\[ out)
  (if arg (display arg out))
  (write-char ch out)
  (flush-output out))

;; we use zero-based columns
(define (terminal-goto-col out n)  (terminal-escape out #\G (+ n 1)))
(define (terminal-up out n)        (terminal-escape out #\A n))
(define (terminal-down out n)      (terminal-escape out #\B n))
(define (terminal-clear-below out) (terminal-escape out #\J #f))
(define (terminal-clear-right out) (terminal-escape out #\K #f))

(define (read-numeric-sequence in)
  (let lp ((c (peek-char in)) (acc '()))
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (read-char in)  ;; skip peeked char
       (lp (peek-char in) (cons c acc)))
      (else
       (string->number (apply string (reverse acc)))))))

(define (terminal-current-position in out)
  (with-stty '(not icanon isig echo)
    (lambda ()
      (terminal-escape out #\n 6)
      (read-char in)
      (and (eqv? #\[ (read-char in))
           (let ((y (read-numeric-sequence in)))
             (and y
                  (eqv? #\; (read-char in))
                  (let ((x (read-numeric-sequence in)))
                    (and x
                         (eqv? #\R (read-char in))
                         (list (- y 1) (- x 1))))))))))

(define (at-first-column? in out)
  (let ((pos (terminal-current-position in out)))
    (and pos (zero? (cadr pos)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; history

(define maximum-history-size 512)

(define-record-type History
  (%make-history remaining past future filter)
  history?
  (remaining history-remaining history-remaining-set!)
  (past history-past history-past-set!)
  (future history-future history-future-set!)
  (filter history-filter history-filter-set!))

(define (make-history . o)
  (%make-history (if (pair? o) (car o) maximum-history-size)
                 '()
                 '()
                 (and (pair? o) (pair? (cdr o)) (cadr o))))

(define (history-current h)
  (let ((p (history-past h)))
    (and (pair? p) (car p))))

(define (history->list h)
  (let ((past (history-past h)) (future (history-future h)))
    (if (pair? past) (cons (car past) (append future (cdr past))) future)))

(define (list->history ls . o)
  (%make-history (max maximum-history-size (length ls)) ls '()
                 (and (pair? o) (car o))))

(define (history-flatten! h)
  (history-past-set! h (history->list h))
  (history-future-set! h '()))

(define (drop-last ls) (reverse (cdr (reverse ls))))

(define (history-past-push! h x)
  (if (positive? (history-remaining h))
      (history-remaining-set! h (- (history-remaining h) 1))
      (if (pair? (history-past h))
          (history-past-set! h (drop-last (history-past h)))
          (history-future-set! h (drop-last (history-future h)))))
  (history-past-set! h (cons x (history-past h))))

(define (history-insert! h x)
  (history-flatten! h)
  (if (not (and (history-filter h) ((history-filter h) x)))
      (history-past-push! h x)))

(define (history-reset! h)
  (cond
   ((pair? (history-future h))
    (history-past-set! h (append (drop-last (history-future h))
                                 (history-past h)))
    (history-future-set! h '()))))

(define (history-commit! h x)
  (history-reset! h)
  (history-insert! h x))

(define (history-prev! h)
  (let ((past (history-past h)))
    (and (pair? past)
         (pair? (cdr past))
         (begin
           (history-future-set! h (cons (car past) (history-future h)))
           (history-past-set! h (cdr past))
           (cadr past)))))

(define (history-next! h)
  (let ((future (history-future h)))
    (and (pair? future)
         (begin
           (history-past-set! h (cons (car future) (history-past h)))
           (history-future-set! h (cdr future))
           (car future)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; char and string utils

(define (char-word-constituent? ch)
  (or (char-alphabetic? ch) (char-numeric? ch)
      (memv ch '(#\_ #\- #\+ #\:))))

(define (char-non-word-constituent? ch) (not (char-word-constituent? ch)))

(define (string-copy! dst dstart src start end)
  (if (>= start dstart)
      (do ((i start (+ i 1)) (j dstart (+ j 1)))
          ((= i end))
        (string-set! dst j (string-ref src i)))
      (do ((i (- end 1) (- i 1)) (j (+ dstart (- end start 1)) (- j 1)))
          ((< i start))
        (string-set! dst j (string-ref src i)))))

(define (string-index ch x)
  (let ((len (string-length x)))
    (let lp ((i 0))
      (cond ((>= i len) #f)
            ((eqv? ch (string-ref x i)))
            (else (lp (+ i 1)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; buffers

(define-record-type Buffer
  (%make-buffer refresh? cleared? min pos row max-row col gap start width
                string history complete? single-line?)
  buffer?
  (refresh? buffer-refresh? buffer-refresh?-set!)
  (cleared? buffer-cleared? buffer-cleared?-set!)
  (min buffer-min buffer-min-set!)
  (pos buffer-pos buffer-pos-set!)
  (row buffer-row buffer-row-set!)
  (max-row buffer-max-row buffer-max-row-set!)
  (col buffer-col buffer-col-set!)
  (gap buffer-gap buffer-gap-set!)
  (start buffer-start buffer-start-set!)
  (width buffer-width buffer-width-set!)
  (string buffer-string buffer-string-set!)
  (kill-ring buffer-kill-ring buffer-kill-ring-set!)
  (history buffer-history buffer-history-set!)
  (complete? buffer-complete? buffer-complete?-set!)
  (single-line? buffer-single-line? buffer-single-line?-set!))

(define default-buffer-size 256)
(define default-buffer-width 80)

(define (make-buffer)
  (%make-buffer #f #f 0 0 0 0 0 default-buffer-size 0 default-buffer-width
                (make-string default-buffer-size) '() #f #f))

(define (buffer->string buf)
  (let ((str (buffer-string buf)))
    (string-append (substring str (buffer-min buf) (buffer-pos buf))
                   (substring str (buffer-gap buf) (string-length str)))))

(define (buffer-right-length buf)
  (- (string-length (buffer-string buf)) (buffer-gap buf)))
(define (buffer-length buf)
  (+ (buffer-pos buf) (buffer-right-length buf)))
(define (buffer-free-space buf)
  (- (buffer-gap buf) (buffer-pos buf)))

(define (buffer-clamp buf n)
  (max (buffer-min buf) (min n (buffer-length buf))))

(define (buffer-resize buf n)
  (cond ((<= (buffer-free-space buf) n)
         (let* ((right-len (buffer-right-length buf))
                (new-len (* 2 (max n (buffer-length buf))))
                (new-gap (- new-len right-len))
                (new (make-string new-len))
                (old (buffer-string buf)))
           (string-copy! new 0 old 0 (buffer-pos buf))
           (string-copy! new new-gap old (buffer-gap buf) (string-length old))
           (buffer-string-set! buf new)
           (buffer-gap-set! buf new-gap)))))

;; Adapted from fmt-unicode. TODO: convert to char-sets.
(define low-non-spacing-chars '#u8(
#xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
#x78    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0 #xfe #xff #xff #xff #xff #xff #x1f    0    0    0    0    0    0    0
   0    0 #x3f    0    0    0    0    0    0 #xf8 #xff #x01    0    0 #x01    0
   0    0    0    0    0    0    0    0    0    0 #xc0 #xff #xff #x3f    0    0
   0    0 #x02    0    0    0 #xff #xff #xff #x07    0    0    0    0    0    0
   0    0    0    0 #xc0 #xff #x01    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
#x06    0    0    0    0    0    0 #x10 #xfe #x21 #x1e    0 #x0c    0    0    0
#x02    0    0    0    0    0    0 #x10 #x1e #x20    0    0 #x0c    0    0    0
#x06    0    0    0    0    0    0 #x10 #xfe #x3f    0    0    0    0 #x03    0
#x06    0    0    0    0    0    0 #x30 #xfe #x21    0    0 #x0c    0    0    0
#x02    0    0    0    0    0    0 #x90 #x0e #x20 #x40    0    0    0    0    0
#x04    0    0    0    0    0    0    0    0 #x20    0    0    0    0    0    0
   0    0    0    0    0    0    0 #xc0 #xc1 #xff #x7f    0    0    0    0    0
   0    0    0    0    0    0    0 #x10 #x40 #x30    0    0    0    0    0    0
   0    0    0    0    0    0    0    0 #x0e #x20    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0 #x04 #x7c    0    0    0    0    0
   0    0    0    0    0    0 #xf2 #x07 #x80 #x7f    0    0    0    0    0    0
   0    0    0    0    0    0 #xf2 #x1f    0 #x3f    0    0    0    0    0    0
   0    0    0 #x03    0    0 #xa0 #x02    0    0    0    0    0    0 #xfe #x7f
#xdf    0 #xff #xff #xff #xff #xff #x1f #x40    0    0    0    0    0    0    0
   0    0    0    0    0 #xe0 #xfd #x02    0    0    0 #x03    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0 #x1c    0    0    0 #x1c    0    0    0 #x0c    0    0    0 #x0c    0
   0    0    0    0    0    0 #x80 #x3f #x40 #xfe #x0f #x20    0    0    0    0
   0 #x38    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0 #x02    0    0    0    0    0    0    0    0    0    0
   0    0    0    0 #x87 #x01 #x04 #x0e    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0 #xff #x1f #xe2 #x07))

(define (unicode-char-width c)
  (let ((ci (char->integer c)))
    (cond
      ;; hand-checked ranges from EastAsianWidth.txt
      ((<= #x1100 ci #x115F) 2) ; Hangul
      ((<= #x2E80 ci #x4DB5) 2) ; CJK
      ((<= #x4E00 ci #xA4C6) 2)
      ((<= #xAC00 ci #xD7A3) 2) ; Hangul
      ((<= #xF900 ci #xFAD9) 2) ; CJK compat
      ((<= #xFE10 ci #xFE6B) 2)
      ((<= #xFF01 ci #xFF60) 2)
      ((<= #xFFE0 ci #xFFE6) 2)
      ((<= #x20000 ci #x30000) 2)
      ;; non-spacing mark (Mn) ranges from UnicodeData.txt
      ((<= #x0300 ci #x3029)
       ;; inlined bit-vector-ref for portability
       (let* ((i (- ci #x0300))
              (byte (quotient i 8))
              (off (remainder i 8)))
         (if (zero? (bitwise-and (bytevector-u8-ref low-non-spacing-chars byte)
                                 (arithmetic-shift 1 off)))
             1
             0)))
      ((<= #x302A ci #x302F) 0)
      ((<= #x3099 ci #x309A) 0)
      ((= #xFB1E ci) 0)
      ((<= #xFE00 ci #xFE23) 0)
      ((<= #x1D167 ci #x1D169) 0)
      ((<= #x1D17B ci #x1D182) 0)
      ((<= #x1D185 ci #x1D18B) 0)
      ((<= #x1D1AA ci #x1D1AD) 0)
      ((<= #xE0100 ci #xE01EF) 0)
      (else 1))))

(define (unicode-string-width str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (string-length str))))
    (let lp1 ((i start) (width 0))
      (if (>= i end)
          width
          (let ((c (string-ref str i)))
            (cond
              ;; ANSI escapes
              ((and (= 27 (char->integer c)) ; esc
                    (< (+ i 1) end)
                    (eqv? #\[ (string-ref str (+ i 1))))
               (let lp2 ((i (+ i 2)))
                 (cond ((>= i end) width)
                       ((memv (string-ref str i) '(#\m #\newline))
                        (lp1 (+ i 1) width))
                       (else (lp2 (+ i 1))))))
              ;; unicode characters
              ((>= (char->integer c) #x80)
               (lp1 (+ i 1) (+ width (unicode-char-width c))))
              ;; normal ASCII
              (else (lp1 (+ i 1) (+ width 1)))))))))

(define (buffer-update-position! buf)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (end (string-length (buffer-string buf)))
        (width (buffer-width buf)))
    (cond
     ((buffer-single-line? buf)
      ;; The "start" is the last left-most column of the buffer when
      ;; we overflow and need to scroll horizontally.  This defaults
      ;; to 0 and increments as we move past the last column.  We
      ;; update it when we find that (via movement or insertion) the
      ;; point would no longer be visible from "start" to the end of
      ;; the line, by shifting the start to the rightmost column that
      ;; would show the point.  Thus, after scrolling off the
      ;; beginning of the buffer, successive movements left will first
      ;; go to the 0th column, then scroll to the start one character
      ;; at a time.  A beginning-of-line command will restore the
      ;; "start" to 0 immediately.
      ;; We assume no embedded newlines in this case.
      (let ((start (buffer-start buf))
            (min-width (unicode-string-width str 0 (buffer-min buf))))
        (cond
         ((> start pos)
          ;; We've moved back before the current start - reset to pos.
          (buffer-start-set! buf pos))
         ((> (+ 1 min-width (unicode-string-width str start pos))
             (buffer-width buf))
          ;; The edited text is wider than the screen - scroll the
          ;; start so that pos fits on the end.
          ;; TODO: This isn't correct for wide characters, need to
          ;; loop checking individual widths.
          (buffer-start-set!
           buf
           (max 0 (- (+ 1 min-width (unicode-string-width str 0 pos))
                     (buffer-width buf))))))
        ;; Compute the current column as the width of the prompt plus
        ;; the width of the visible buffer from start to pos.
        (let* ((vis-width (unicode-string-width str (buffer-start buf) pos))
               (col (+ min-width vis-width)))
          (buffer-col-set! buf col))))
     (else
      ;; Otherwise, in a multi-line editor we need to scan for
      ;; newlines to determine the current (relative) row and column.
      ;; TODO: Handle ANSI escapes.
      (let lp ((i 0) (row 0) (col 0)) ;; update row/col
        (cond ((= i pos)
               (buffer-row-set! buf row)
               (buffer-col-set! buf col)
               (lp gap row col))      ;; skip from pos->gap
              ((>= i end)
               (buffer-max-row-set!
                buf (if (and (zero? col) (> row 0)) (- row 1) row)))
              ((eqv? #\newline (string-ref str i))
               (lp (+ i 1) (+ row 1) 0))
              (else
               (let ((off (unicode-char-width (string-ref str i))))
                 (if (>= (+ col off) width)
                     (lp (+ i 1) (+ row 1) 0)
                     (lp (+ i 1) row (+ col off)))))))))))

(define (buffer-clear buf out)
  (cond
   ((not (buffer-cleared? buf))
    ;; goto start of input
    (terminal-goto-col out 0)
    (if (positive? (buffer-row buf))
        (terminal-up out (buffer-row buf)))
    ;; clear below
    (terminal-clear-below out)
    (buffer-cleared?-set! buf #t))))

(define (buffer-draw buf out)
  (let* ((gap (buffer-gap buf))
         (str (buffer-string buf))
         (end (string-length str))
         (old-row (buffer-row buf))
         (old-col (buffer-col buf)))
    ;; update position and clear the current input
    (buffer-clear buf out)
    (buffer-update-position! buf)
    (let ((left (if (buffer-single-line? buf)
                    (buffer-start buf)
                    (buffer-min buf)))
          (right
           (if (buffer-single-line? buf)
               (min end (+ (buffer-gap buf)
                           (- (buffer-width buf) (buffer-col buf))))
               end)))
      (display (substring str 0 (buffer-min buf)) out)
      (display (substring str left (buffer-pos buf)) out)
      (display (substring str (buffer-gap buf) right) out))
    (cond
     ((not (buffer-single-line? buf))
      ;; move to next line if point at eol
      (if (and (zero? (buffer-col buf)) (positive? (buffer-row buf)))
          (write-char #\space out))
      ;; move to correct row then col
      (if (< (buffer-row buf) (buffer-max-row buf))
          (terminal-up out (- (buffer-max-row buf) (buffer-row buf))))))
    (terminal-goto-col out (buffer-col buf))
    (flush-output out)
    (buffer-cleared?-set! buf #f)))

(define (buffer-refresh buf out)
  (cond ((buffer-refresh? buf)
         (buffer-draw buf out)
         (buffer-refresh?-set! buf #f))))

(define (buffer-goto! buf out n)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (n (buffer-clamp buf n)))
    (cond ((not (= n pos))
           (buffer-update-position! buf) ;; necesary?
           (if (< n pos)
               (string-copy! str (- gap (- pos n)) str n pos)
               (string-copy! str pos str gap (+ gap (- n pos))))
           (buffer-pos-set! buf n)
           (buffer-gap-set! buf (+ gap (- n pos)))
           (cond
            ((not (buffer-refresh? buf))
             (let ((old-row (buffer-row buf))
                   (old-start (buffer-start buf)))
               (buffer-update-position! buf)
               (cond
                ((not (= old-start (buffer-start buf)))
                 (buffer-refresh?-set! buf #t))
                (else
                 (let ((row-diff (- old-row (buffer-row buf))))
                   (cond ((> row-diff 0) (terminal-up out row-diff))
                         ((< row-diff 0) (terminal-down out (- row-diff)))))
                 (terminal-goto-col out (buffer-col buf)))))))))))

(define (buffer-insert! buf out x)
  (let ((len (if (char? x) 1 (string-length x)))
        (pos (buffer-pos buf)))
    (buffer-resize buf len)
    (if (char? x)
        (string-set! (buffer-string buf) pos x)
        (string-copy! (buffer-string buf) pos x 0 len))
    (buffer-pos-set! buf (+ (buffer-pos buf) len))
    (cond
     ((buffer-refresh? buf))
     ((and (= (buffer-gap buf) (string-length (buffer-string buf)))
           (< (+ (buffer-col buf) len) (buffer-width buf))
           (if (char? x)
               (not (eqv? x #\newline))
               (not (string-index #\newline x))))
      ;; fast path - append to end of buffer w/o wrapping to next line
      (display x out)
      (flush-output out)
      (buffer-col-set! buf (+ (buffer-col buf) len))
      (buffer-cleared?-set! buf #f))
     (else
      (buffer-refresh?-set! buf #t)))))

(define (buffer-delete! buf out start end)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (start (buffer-clamp buf start))
        (end (buffer-clamp buf end)))
    (if (not (buffer-refresh? buf))
        (if (and (= start pos) (>= end (buffer-length buf)))
            (terminal-clear-below out)
            (buffer-refresh?-set! buf #t)))
    (cond ((< end pos)
           (string-copy! str start str end pos)
           (buffer-pos-set! buf (+ start (- pos end))))
          ((> start gap)
           (string-copy! str start str gap (+ gap (- end start)))
           (buffer-gap-set! buf (+ gap (- end start))))
          (else
           (buffer-pos-set! buf (min pos start))
           (buffer-gap-set! buf (max gap (+ pos (- gap pos) (- end pos))))))))

(define (buffer-skip buf pred)
  (let* ((str (buffer-string buf)) (end (string-length str)))
    (let lp ((i (buffer-gap buf)))
      (if (or (>= i end) (not (pred (string-ref str i))))
          (+ (- i (buffer-gap buf)) (buffer-pos buf))
          (lp (+ i 1))))))

(define (buffer-skip-reverse buf pred)
  (let ((str (buffer-string buf)))
    (let lp ((i (- (buffer-pos buf) 1)))
      (if (or (< i 0) (not (pred (string-ref str i)))) i (lp (- i 1))))))

(define (buffer-previous-word buf)
  (let ((i (buffer-skip-reverse buf char-word-constituent?)))
    (substring (buffer-string buf) (+ i 1) (buffer-pos buf))))

(define (buffer-format-list buf out words)
  (let ((width (buffer-width buf)))
    (define (write-rows num-cols widths)
      (let lp ((ls words) (i 0))
        (cond
         ((pair? ls)
          (let ((diff (- (vector-ref widths i) (string-length (car ls)))))
            (display (car ls) out)
            (if (= (+ i 1) num-cols)
                (newline out)
                (display (make-string (+ 1 diff) #\space) out))
            (lp (cdr ls) (modulo (+ i 1) num-cols))))
         ((< i num-cols)
          (newline out)))))
    (let try-cols ((num-cols (length words)))
      (cond
       ((<= num-cols 1)
        (newline out)
        (for-each (lambda (x) (display x out) (newline out)) words))
       (else
        (let ((widths (make-vector num-cols 0)))
          (let lp ((ls words) (i 0) (avail (- num-cols 1)))
            (cond
             ((null? ls)
              (write-rows num-cols widths))
             (else
              (let ((diff (- (string-length (car ls)) (vector-ref widths i))))
                (if (positive? diff)
                    (let ((avail (+ avail diff)))
                      (cond
                       ((> avail width)
                        (try-cols (- num-cols 1)))
                       (else
                        (vector-set! widths i (string-length (car ls)))
                        (lp (cdr ls) (modulo (+ i 1) num-cols) avail))))
                    (lp (cdr ls) (modulo (+ i 1) num-cols) avail))))))))))))

(define (buffer-make-completer generate)
  (lambda (ch buf out return)
    (let* ((word (buffer-previous-word buf))
           (ls (generate buf word)))
      (cond
       ((null? ls)
        (command/beep ch buf out return))
       ((= 1 (length ls))
        (buffer-insert! buf out (substring (car ls) (string-length word))))
       (else
        (newline out)
        (buffer-format-list buf out ls)
        (buffer-draw buf out))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; keymaps

(define keymap? pair?)

(define (make-keymap . o)
  (cons (make-vector 256 #f) (and (pair? o) (car o))))

(define (make-sparse-keymap . o)
  (cons '() (and (pair? o) (car o))))

(define (make-printable-keymap)
  (let* ((keymap (make-keymap command/self-insert))
         (v (car keymap)))
    (do ((i #x20 (+ i 1))) ((= i #x7F) keymap)
      (vector-set! v i command/self-insert))))

(define (make-standard-escape-bracket-keymap)
  (let* ((keymap (make-keymap))
         (v (car keymap)))
    (vector-set! v 65 command/backward-history)
    (vector-set! v 66 command/forward-history)
    (vector-set! v 67 command/forward-char)
    (vector-set! v 68 command/backward-char)
    keymap))

(define (make-standard-escape-keymap)
  (let* ((keymap (make-keymap))
         (v (car keymap)))
    (vector-set! v   8 command/backward-delete-word)
    (vector-set! v  91 (make-standard-escape-bracket-keymap))
    (vector-set! v  98 command/backward-word)
    (vector-set! v 100 command/forward-delete-word)
    (vector-set! v 102 command/forward-word)
    (vector-set! v 127 command/backward-delete-word)
    keymap))

(define (make-standard-keymap . o)
  (let* ((keymap (make-printable-keymap))
         (v (car keymap))
         (catch-control-c? (and (pair? o) (car o))))
    (vector-set! v   0 command/enter)   ;; for telnet
    (vector-set! v   1 command/beginning-of-line)
    (vector-set! v   2 command/backward-char)
    (vector-set! v   3 (if catch-control-c? command/cancel command/quit))
    (vector-set! v   4 command/forward-delete-char)
    (vector-set! v   5 command/end-of-line)
    (vector-set! v   6 command/forward-char)
    (vector-set! v   8 command/backward-delete-char)
    (vector-set! v  10 command/enter)
    (vector-set! v  11 command/forward-delete-line)
    (vector-set! v  12 command/refresh)
    (vector-set! v  13 command/skip)
    (vector-set! v  14 command/forward-history)
    (vector-set! v  16 command/backward-history)
    (vector-set! v  21 command/backward-delete-line)
    (vector-set! v  27 (make-standard-escape-keymap))
    (vector-set! v 127 command/backward-delete-char)
    keymap))

(define (keymap-lookup keymap n)
  (let ((table (car keymap)))
    (or (if (vector? table)
            (and (< -1 n (vector-length table)) (vector-ref table n))
            (cond ((assv n table) => cdr) (else #f)))
        (if (keymap? (cdr keymap))
            (keymap-lookup (cdr keymap) n)
            (cdr keymap)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; commands

(define (command/self-insert ch buf out return)
  (buffer-insert! buf out ch))

(define (command/enter ch buf out return)
  (protect (exn
            ((and (exception? exn)
                  (eq? 'read-incomplete (exception-kind exn)))
             (command/self-insert ch buf out return))
            (else
             (buffer-clear buf out)
             (print-exception exn out)
             (buffer-draw buf out)))
    (cond
     (((buffer-complete? buf) buf)
      (command/end-of-line ch buf out return)
      (display "\r\n" out)
      (flush-output out)
      (return))
     (else
      (command/self-insert ch buf out return)))))

(define (command/cancel ch buf out return)
  (command/end-of-line ch buf out return)
  (display "^C" out)
  (newline out)
  (buffer-delete! buf out 0 (buffer-length buf))
  (buffer-draw buf out))

(define (command/quit ch buf out return)
  (command/end-of-line ch buf out return)
  (display "^C" out)
  (newline out)
  (stty out '(icanon isig echo))
  (exit))

(define (command/beep ch buf out return)
  (write-char (integer->char 7) out))

(define (command/skip ch buf out return)
  #f)

(define (command/refresh ch buf out return)
  (buffer-draw buf out))

(define (command/beginning-of-line ch buf out return)
  (buffer-goto! buf out 0))

(define (command/end-of-line ch buf out return)
  (buffer-goto! buf out (buffer-length buf)))

(define (command/forward-char ch buf out return)
  (buffer-goto! buf out (+ (buffer-pos buf) 1)))

(define (command/backward-char ch buf out return)
  (buffer-goto! buf out (- (buffer-pos buf) 1)))

(define (command/forward-delete-char ch buf out return)
  (cond
   ((zero? (- (buffer-length buf) (buffer-min buf)))
    (newline out)
    (return 'eof))
   (else
    (buffer-delete! buf out (buffer-pos buf) (+ (buffer-pos buf) 1)))))

(define (command/backward-delete-char ch buf out return)
  (buffer-delete! buf out (- (buffer-pos buf) 1) (buffer-pos buf)))

(define (command/forward-delete-line ch buf out return)
  (buffer-delete! buf out (buffer-pos buf) (buffer-length buf)))

(define (command/backward-delete-line ch buf out return)
  (buffer-delete! buf out 0 (buffer-pos buf)))

(define (command/backward-history ch buf out return)
  (let ((history (buffer-history buf)))
    (cond
     ((and (history? history) (pair? (history-past history)))
      (if (null? (history-future history))
          (history-insert! history (buffer->string buf)))
      (cond
       ((pair? (cdr (history-past history)))
        (buffer-delete! buf out 0 (buffer-length buf))
        (buffer-insert! buf out (history-prev! history))))))))

(define (command/forward-history ch buf out return)
  (let ((history (buffer-history buf)))
    (cond
     ((and (history? history) (pair? (history-future history)))
      (buffer-delete! buf out 0 (buffer-length buf))
      (let ((res (buffer-insert! buf out (history-next! history))))
        (if (null? (history-future history))
            (history-past-set! history (cdr (history-past history))))
        res)))))

(define (command/forward-word ch buf out return)
  (buffer-goto! buf out (buffer-skip buf char-non-word-constituent?))
  (buffer-goto! buf out (buffer-skip buf char-word-constituent?)))

(define (command/backward-word ch buf out return)
  (buffer-goto! buf out (buffer-skip-reverse buf char-non-word-constituent?))
  (buffer-goto! buf out (+ (buffer-skip-reverse buf char-word-constituent?) 1)))

(define (command/forward-delete-word ch buf out return)
  (let ((start (buffer-pos buf)))
    (buffer-goto! buf out (buffer-skip buf char-non-word-constituent?))
    (buffer-delete! buf out start (buffer-skip buf char-word-constituent?))))

(define (command/backward-delete-word ch buf out return)
  (let ((end (buffer-pos buf)))
    (buffer-goto! buf out (buffer-skip-reverse buf char-non-word-constituent?))
    (let ((start (buffer-skip-reverse buf char-word-constituent?)))
      (buffer-delete! buf out (+ start 1) end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; line-editing

(define standard-keymap (make-standard-keymap))
(define standard-cancel-keymap (make-standard-keymap #t))

(define (get-key ls key . o)
  (let ((x (memq key ls)))
    (if (and x (pair? (cdr x))) (cadr x) (and (pair? o) (car o)))))

(define (with-leading-ports ls proc)
  (if (and (pair? ls) (input-port? (car ls)))
      (if (and (pair? (cdr ls)) (output-port? (cadr ls)))
          (proc (car ls) (cadr ls) (cddr ls))
          (proc (car ls) (current-output-port) (cdr ls)))
      (proc (current-input-port) (current-output-port) ls)))

(define (make-line-editor . args)
  (let* ((prompter (get-key args 'prompt: "> "))
         (history (get-key args 'history:))
         (complete? (get-key args 'complete?: (lambda (buf) #t)))
         (completion (get-key args 'completion: #f))
         (terminal-width (get-key args 'terminal-width:))
         (single-line? (get-key args 'single-line?: #f))
         (fresh-line (get-key args 'fresh-line: #f))
         (no-stty? (get-key args 'no-stty?: #f))
         (keymap0 (get-key args 'keymap:
                           (if (get-key args 'catch-control-c?: #f)
                               standard-cancel-keymap
                               standard-keymap)))
         (keymap (if completion
                     (cons (list (cons 9 completion)) keymap0)
                     keymap0))
         (buf (or (get-key args 'buffer: #f) (make-buffer))))
    (lambda (in out)
      (let* ((width (or terminal-width (get-terminal-width out) 80))
             (prompt (if (procedure? prompter) (prompter) prompter))
             (done? #f)
             (return (lambda o (set! done? (if (pair? o) (car o) #t)))))
        ;; Maybe start at a fresh line.
        (cond
         ((and fresh-line (not (at-first-column? in out)))
          (if (string? fresh-line) (display fresh-line out))
          (newline out)))
        ;; Clear buffer and reset prompt.
        (buffer-refresh?-set! buf #t)
        (buffer-min-set! buf 0)
        (buffer-delete! buf out 0 (buffer-length buf))
        (buffer-width-set! buf width)
        (buffer-insert! buf out prompt)
        (buffer-min-set! buf (string-length prompt))
        (buffer-history-set! buf history)
        (buffer-complete?-set! buf complete?)
        (buffer-single-line?-set! buf single-line?)
        (if single-line? (buffer-start-set! buf (buffer-min buf)))
        (buffer-refresh buf out)
        (flush-output out)
        ((if no-stty? (lambda (out f) (f)) with-raw-io)
         out
         (lambda ()
           (let lp ((kmap keymap))
             (let ((ch (read-char in)))
               (if (eof-object? ch)
                   (let ((res (buffer->string buf)))
                     (if (equal? res "") ch res))
                   (let ((x (keymap-lookup kmap (char->integer ch))))
                     (cond
                      ((keymap? x)
                       (lp x))
                      ((procedure? x)
                       (protect (exn (else
                                      (buffer-clear buf out)
                                      (print-exception exn out)
                                      (buffer-draw buf out)))
                         (x ch buf out return))
                       (flush-output out)
                       (buffer-refresh buf out)
                       (if done?
                           (and (not (eq? done? 'eof)) (buffer->string buf))
                           (lp keymap)))
                      (else
                       ;;(command/beep ch buf out return)
                       (lp keymap)))))))))))))

(define (edit-line . args)
  (with-leading-ports
   args
   (lambda (in out rest) ((apply make-line-editor rest) in out))))

(define (edit-line-repl . args)
  (with-leading-ports
   args
   (lambda (in out rest)
     (let ((eval (get-key rest 'eval: (lambda (x) x)))
           (print (get-key rest 'write: write))
           (history (or (get-key rest 'history:) (make-history))))
       (let ((edit-line
              (apply make-line-editor 'no-stty?: #t 'history: history rest)))
         ((if (get-key args 'no-stty?:) (lambda (out f) (f)) with-raw-io)
          out
          (lambda ()
            (let lp ()
              (let ((line (edit-line in out)))
                (if (pair? (history-future history))
                    (history-past-set! history (cdr (history-past history))))
                (history-commit! history line)
                (print (eval line) out)
                (newline out)
                (lp))))))))))
(define-library (chibi term ansi)
  (export

   black-escape red-escape yellow-escape green-escape
   blue-escape cyan-escape magenta-escape white-escape
   rgb-escape 
   gray-escape
   reset-color-escape

   black-background-escape red-background-escape
   yellow-background-escape green-background-escape
   blue-background-escape cyan-background-escape
   magenta-background-escape white-background-escape
   rgb-background-escape
   gray-background-escape
   reset-background-color-escape

   black red yellow green
   blue cyan magenta white
   black-background red-background yellow-background green-background
   blue-background cyan-background magenta-background white-background
   bold
   underline
   negative
   rgb rgb-background
   gray gray-background
   bold-escape reset-bold-escape
   underline-escape reset-underline-escape
   negative-escape reset-negative-escape

   ansi-escapes-enabled?)
  (import (scheme base)
          (scheme write)
          (scheme process-context))
  (include "ansi.scm"))
;; filesystem.scm -- additional filesystem utilities
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Creates the directory \var{dir}, including any parent directories
;;> as needed.  Returns \scheme{#t} on success and \scheme{#f} on
;;> failure.

(define (create-directory* dir . o)
  (let ((mode (if (pair? o) (car o) #o755)))
    (or (file-directory? dir)
        (create-directory dir mode)
        (let ((slash
               (string-find-right dir #\/ 0 (string-skip-right dir #\/))))
          (and (> slash 0)
               (let ((parent (substring-cursor dir 0 slash)))
                 (and (not (equal? parent dir))
                      (not (file-exists? parent))
                      (create-directory* parent mode)
                      (create-directory dir mode))))))))

;;> The fundamental directory iterator.  Applies \var{kons} to
;;> each filename in directory \var{dir} and the result of the
;;> previous application, beginning with \var{knil}.  With
;;> \var{kons} as \scheme{cons} and \var{knil} as \scheme{'()},
;;> equivalent to \scheme{directory-files}.

(define (directory-fold dir kons knil)
  (let ((dir (opendir dir)))
    (if (not dir)
        knil
        (let lp ((res knil))
          (let ((file (readdir dir)))
            (if file
                (lp (kons (dirent-name file) res))
                (begin (closedir dir) res)))))))

;;> Returns a list of the files in \var{dir} in an unspecified
;;> order.

(define (directory-files dir)
  (directory-fold dir cons '()))

;;> The fundamental directory traverser.

(define (directory-fold-tree file down up here . o)
  ;; TODO: Use link count to reduce stats.
  ;; TODO: Provide higher-level wrapper for filtering and avoids links.
  (let ((knil (and (pair? o) (car o)))
        (down (or down (lambda (f acc) acc)))
        (up (or up (lambda (f acc) acc)))
        (here (or here (lambda (f acc) acc))))
    (let fold ((file file) (acc knil))
      (cond
       ((file-directory? file)
        (let ((d (opendir file)))
          (if (not d)
              acc
              (let lp ((acc (down file acc)))
                (let ((e (readdir d)))
                  (cond
                   (e
                    (let ((f (dirent-name e)))
                      (if (member f '("." ".."))
                          (lp acc)
                          (let ((path (string-append file "/" f)))
                            (lp (fold path acc))))))
                   (else
                    (closedir d)
                    (up file acc))))))))
       (else
        (here file acc))))))

;;> Unlinks the file named \var{string} from the filesystem.
;;> Returns \scheme{#t} on success and \scheme{#f} on failure.

(define (delete-file file)
  (if (not (%delete-file file))
      (raise-continuable
       (make-exception 'file "couldn't delete file" file delete-file #f))))

;;> Recursively delete all files and directories under \var{dir}.
;;> Unless optional arg \var{ignore-errors?} is true, raises an error
;;> if any file can't be deleted.

(define (delete-file-hierarchy dir . o)
  (let ((ignore-errors? (and (pair? o) (car o))))
    (if (member dir '("" "/"))
        (error "won't delete unsafe directory" dir))
    (directory-fold-tree
     dir
     #f
     (lambda (d acc)
       (if (and (not (delete-directory d)) (not ignore-errors?))
           (error "couldn't delete directory" d)))
     (lambda (f acc)
       (if (and (not (delete-file f)) (not ignore-errors?))
           (error "couldn't delete file" f))))))

;;> Runs \var{thunk} with the current directory of the process temporarily
;;> set to \var{dir}.

(define (with-directory dir thunk)
  (let ((pwd (current-directory)))
    (dynamic-wind
      (lambda () (change-directory dir))
      thunk
      (lambda () (change-directory pwd)))))

;;> Returns the \scheme{status} object for the given \var{file},
;;> which should be a string indicating the path or a file
;;> descriptor.

(define (file-status file)
  (if (string? file) (stat file) (fstat file)))

(define (file-device x) (stat-dev (if (stat? x) x (file-status x))))
(define (file-inode x) (stat-ino (if (stat? x) x (file-status x))))
(define (file-mode x) (stat-mode (if (stat? x) x (file-status x))))
(define (file-num-links x) (stat-nlinks (if (stat? x) x (file-status x))))
(define (file-owner x) (stat-uid (if (stat? x) x (file-status x))))
(define (file-group x) (stat-gid (if (stat? x) x (file-status x))))
(define (file-represented-device x) (stat-rdev (if (stat? x) x (file-status x))))
(define (file-size x) (stat-size (if (stat? x) x (file-status x))))
(define (file-block-size x) (stat-blksize (if (stat? x) x (file-status x))))
(define (file-num-blocks x) (stat-blocks (if (stat? x) x (file-status x))))
(define (file-access-time x) (stat-atime (if (stat? x) x (file-status x))))
(define (file-modification-time x) (stat-mtime (if (stat? x) x (file-status x))))
(define (file-change-time x) (stat-ctime (if (stat? x) x (file-status x))))

;;> File status accessors.  \var{x} should be a string indicating
;;> the file to lookup the status for, or an existing status object.
;;> Raises an error in the string case for non-existing files.
;;/

(define-syntax file-test-mode
  (syntax-rules ()
    ((file-test-mode op x)
     (let* ((tmp x)
            (st (if (stat? tmp) tmp (file-status tmp))))
       (and st (op (stat-mode st)))))))

(define (file-regular? x) (file-test-mode S_ISREG x))
(define (file-directory? x) (file-test-mode S_ISDIR x))
(define (file-character? x) (file-test-mode S_ISCHR x))
(define (file-block? x) (file-test-mode S_ISBLK x))
(define (file-fifo? x) (file-test-mode S_ISFIFO x))
(define (file-link? x)
  (let ((st (if (stat? x) x (file-link-status x))))
    (and st (S_ISLNK (stat-mode st)))))
(define (file-socket? x) (file-test-mode S_ISSOCK x))
(define (file-exists? x) (and (if (stat? x) #t (file-status x)) #t))

;;> File type tests.  \var{x} should be a string indicating the
;;> file to lookup the status for, or an existing status object.
;;> Returns \scheme{#t} if the file exists and the given type
;;> is satisfied, and \scheme{#f} otherwise.
;;/

(define (file-is-readable? path) (zero? (file-access path access/read)))
(define (file-is-writable? path) (zero? (file-access path access/write)))
(define (file-is-executable? path) (zero? (file-access path access/execute)))

;;> File access tests.  Returns true iff the current real UID and GID
;;> have the corresponding permissions on path.  Equivalent to the
;;> test -r, -w, -x operators in sh.
;;/

;;> Equivalent to duplicating the file descriptor \var{old} to
;;> \var{new} and closing \var{old}.

(define (renumber-file-descriptor old new)
  (and (duplicate-file-descriptor-to old new)
       (close-file-descriptor old)))

;;> Returns the path the symbolic link \var{file} points to, or
;;> \scheme{#f} on error.

(define (read-link file)
  (let* ((buf (make-string 512))
         (res (readlink file buf 512)))
    (and (positive? res)
         (substring buf 0 res))))

;;> Utilities for gathering statistics on the heap.  Just measuring
;;> runtime memory usage doesn't give a good idea of how to optimize
;;> that usage, so this module is provided for profiling.

;;> \procedure{(heap-stats)}

;;> Returns an alist summarizing all heap allocated objects.  The
;;> \var{car} of each cell is the type-name, and the \var{cdr} is the
;;> count of objects of that type in the heap.  Garbage is collected
;;> before the counts are taken.

;;> \procedure{(heap-dump [depth])}

;;> Returns the same value as \scheme{(heap-stats)}, but also prints
;;> all objects on the heap as it runs.  \var{depth} indicates the
;;> printing depth for compound objects and defaults to 1.

;;> These functions just return \scheme{'()} when using the Boehm GC.

(define-library (chibi heap-stats)
  (export heap-stats heap-dump)
  (import (chibi))
  (include-shared "heap-stats"))
;; base.scm - base formatting monad
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> The minimal base formatting combinators and show interface.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> The environment monad with some pre-defined fields for combinator
;;> formatting.

(define-environment-monad Show-Env
  (sequence: sequence)
  (bind: fn)
  (bind-fork: fn-fork)
  (local: %with)
  (local!: update!)
  (return: return)
  (run: run)
  (fields:
   (port env-port env-port-set!)
   (row env-row env-row-set!)
   (col env-col env-col-set!)
   (width env-width env-width-set!)
   (radix env-radix env-radix-set!)
   (precision env-precision env-precision-set!)
   (pad-char env-pad-char env-pad-char-set!)
   (decimal-sep env-decimal-sep env-decimal-sep-set!)
   (decimal-align env-decimal-align env-decimal-align-set!)
   (string-width env-string-width env-string-width-set!)
   (ellipsis env-ellipsis env-ellipsis-set!)
   (writer env-writer env-writer-set!)
   (output env-output env-output-set!)))

;; The base formatting handles outputting raw strings and a simple,
;; configurable handler for formatting objects.

;; Utility - default value of string-width.
(define (substring-length str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (- end start)))

;; Raw output.  All primitive output should go through this operation.
;; Overridable, defaulting to output-default.
(define (output str)
  (fn (output) ((or output output-default) str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \procedure{(show out [args ...])}
;;>
;;> Run the combinators \var{args}, accumulating the output to
;;> \var{out}, which is either an output port or a boolean, with
;;> \scheme{#t} indicating \scheme{current-output-port} and
;;> \scheme{#f} to collect the output as a string.
(define (show out . args)
  (let ((proc (each-in-list args)))
    (cond
     ((output-port? out)
      (show-run out proc))
     ((eq? #t out)
      (show-run (current-output-port) proc))
     ((eq? #f out)
      (let ((out (open-output-string)))
        (show-run out proc) 
        (get-output-string out)))
     (else
      (error "unknown output to show" out)))))

;; Run with an output port with initial default values.
(define (show-run out proc)
  (run (sequence (update! (port out)
                          (col 0)
                          (row 0)
                          (width 78)
                          (radix 10)
                          (pad-char #\space)
                          (output output-default)
                          (string-width substring-length))
                 proc)))

;;> Shortcut syntax for \scheme{(bind (...) (each ...))}.

(define-syntax with
  (syntax-rules ()
    ((with params x) (%with params (displayed x)))
    ((with params . x) (%with params (each . x)))))

;;> The noop formatter.  Generates no output and leaves the state
;;> unmodified.
(define nothing (fn () (update!)))

;;> Formats a displayed version of x - if a string or char, outputs the
;;> raw characters (as with `display'), if x is already a formatter
;;> defers to that, otherwise outputs a written version of x.
(define (displayed x)
  (cond
   ((procedure? x) x)
   ((string? x) (output x))
   ((char? x) (output (string x)))
   (else (written x))))

;;> Formats a written version of x, as with `write'.  The formatting
;;> can be updated with the \scheme{'writer} field.
(define (written x)
  (fn (writer) ((or writer written-default) x)))

;;> Takes a single list of formatters, combined in sequence with
;;> \scheme{each}.
(define (each-in-list args)
  (if (pair? args)
      (sequence (displayed (car args)) (each-in-list (cdr args)))
      nothing))

;;> Combines each of the formatters in a sequence using
;;> \scheme{displayed}, so that strings and chars will be output
;;> directly and other objects will be \scheme{written}.
(define (each . args)
  (each-in-list args))

;;> Raw output - displays str to the formatter output port and updates
;;> row and col.
(define (output-default str)
  (fn (port row col string-width)
    (display str port)
    (let ((nl-index (string-find-right str #\newline)))
      (if (> nl-index 0)
          (update! (row (+ row (string-count str #\newline)))
                   (col (string-width str nl-index)))
          (update! (col (+ col (string-width str))))))))

;;> Captures the output of \var{producer} and formats the result with
;;> \var{consumer}.
(define (call-with-output producer consumer)
  (let ((out (open-output-string)))
    (fn-fork (with ((port out)) producer)
             (fn () (consumer (get-output-string out))))))

(define-library (chibi show pretty)
  (export pretty pretty-shared pretty-simply
          joined/shares
          )
  (import (scheme base) (scheme write) (chibi show) (chibi show base)
          (srfi 1) (srfi 69) (chibi string))
  (include "pretty.scm"))
;; pretty.scm -- pretty printing format combinator
;; Copyright (c) 2006-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define (take* ls n)   ; handles dotted lists and n > length
  (cond ((zero? n) '())
        ((pair? ls) (cons (car ls) (take* (cdr ls) (- n 1))))
        (else '())))

(define (drop* ls n)   ; may return the dot
  (cond ((zero? n) ls)
        ((pair? ls) (drop* (cdr ls) (- n 1)))
        (else ls)))

(define (make-space n) (make-string n #\space))
(define (make-nl-space n) (string-append "\n" (make-string n #\space)))

(define (joined/shares fmt ls shares . o)
  (let ((sep (displayed (if (pair? o) (car o) " "))))
    (fn ()
      (if (null? ls)
          nothing
          (let lp ((ls ls))
            (each
             (fmt (car ls))
             (let ((rest (cdr ls)))
               (cond
                ((null? rest) nothing)
                ((pair? rest)
                 (call-with-shared-ref/cdr rest
                                           shares
                                           (fn () (lp rest))
                                           sep))
                (else (each sep ". " (fmt rest)))))))))))

(define (try-fitted2 proc fail)
  (fn (width string-width output)
    (let ((out (open-output-string)))
      (call-with-current-continuation
       (lambda (abort)
         ;; Modify output to accumulate to an output string port,
         ;; and escape immediately with failure if we exceed the
         ;; column width.
         (define (output* str)
           (fn (col)
             (let lp ((i 0) (col col))
               (let ((nli (string-find str #\newline i))
                     (len (string-width str)))
                 (if (< nli len)
                     (if (> (+ (- nli i) col) width)
                         (abort fail)
                         (lp (+ nli 1) 0))
                     (let ((col (+ (- len i) col)))
                       (cond
                        ((> col width)
                         (abort fail))
                        (else
                         (output str)))))))))
         (fn-fork
          (with ((output output*)
                 (port out))
            proc)
          ;; fitted successfully
          (output (get-output-string out))))))))

(define (try-fitted proc . fail)
  (if (null? fail)
      proc
      (try-fitted2 proc (apply try-fitted fail))))

(define (fits-in-width width proc)
  (call-with-current-continuation
   (lambda (abort)
     (show
      #f
      (fn (output)
        (define (output* str)
          (each (output str)
                (fn (col)
                  (if (>= col width)
                      (abort #f)
                      nothing))))
        (with ((output output*))
          proc))))))

(define (fits-in-columns width ls writer)
  (let ((max-w (quotient width 2)))
    (let lp ((ls ls) (res '()) (widest 0))
      (cond
       ((pair? ls)
        (let ((str (fits-in-width max-w (writer (car ls)))))
          (and str
               (lp (cdr ls)
                   (cons str res)
                   (max (string-length str) widest)))))
       ((null? ls) (cons widest (reverse res)))
       (else #f)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; style

(define syntax-abbrevs
  '((quote . "'") (quasiquote . "`")
    (unquote . ",") (unquote-splicing . ",@")
    ))

(define (pp-let ls pp shares)
  (if (and (pair? (cdr ls)) (symbol? (cadr ls)))
      (pp-with-indent 2 ls pp shares)
      (pp-with-indent 1 ls pp shares)))

(define indent-rules
  `((lambda . 1) (define . 1)
    (let . ,pp-let) (loop . ,pp-let)
    (let* . 1) (letrec . 1) (letrec* . 1) (and-let* . 1) (let1 . 2)
    (let-values . 1) (let*-values . 1) (receive . 2) (parameterize . 1)
    (let-syntax . 1) (letrec-syntax . 1) (syntax-rules . 1) (syntax-case . 2)
    (match . 1) (match-let . 1) (match-let* . 1)
    (if . 3) (when . 1) (unless . 1) (case . 1) (while . 1) (until . 1)
    (do . 2) (dotimes . 1) (dolist . 1) (test . 1)
    (condition-case . 1) (guard . 1) (rec . 1)
    (call-with-current-continuation . 0)
    ))

(define indent-prefix-rules
  `(("with-" . -1) ("call-with-" . -1) ("define-" . 1))
  )

(define indent-suffix-rules
  `(("-case" . 1))
  )

(define (pp-indentation form)
  (let ((indent
         (cond
          ((assq (car form) indent-rules) => cdr)
          ((and (symbol? (car form))
                (let ((str (symbol->string (car form))))
                  (or (find (lambda (rx) (string-prefix? (car rx) str))
                            indent-prefix-rules)
                      (find (lambda (rx) (string-suffix? (car rx) str))
                            indent-suffix-rules))))
           => cdr)
          (else #f))))
    (if (and (number? indent) (negative? indent))
        (max 0 (- (+ (length+ form) indent) 1))
        indent)))

(define (with-reset-shares shares proc)
  (let ((orig-count (cdr shares)))
    (fn ()
      (let ((new-count (cdr shares)))
        (cond
         ((> new-count orig-count)
          (hash-table-walk
           (car shares)
           (lambda (k v)
             (if (and (cdr v) (>= (car v) orig-count))
                 (set-cdr! v #f))))
          (set-cdr! shares orig-count)))
        proc))))

(define (pp-with-indent indent-rule ls pp shares)
  (fn ((col1 col))
    (each
     "("
     (pp (car ls))
     (fn ((col2 col) width string-width)
       (let ((fixed (take* (cdr ls) (or indent-rule 1)))
             (tail (drop* (cdr ls) (or indent-rule 1)))
             (default
               (let ((sep (make-nl-space (+ col1 1))))
                 (each sep (joined/shares pp (cdr ls) shares sep))))
             ;; reset in case we don't fit on the first line
             (reset-shares (with-reset-shares shares nothing)))
         (call-with-output
          (each " "
                (joined/shares
                 (lambda (x) (pp-flat x pp shares)) fixed shares " "))
          (lambda (first-line)
            (cond
             ((< (+ col2 (string-width first-line)) width)
              ;; fixed values on first line
              (let ((sep (make-nl-space
                          (if indent-rule (+ col1 2) (+ col2 1)))))
                (each first-line
                      (cond
                       ((not (or (null? tail) (pair? tail)))
                        (each ". " (pp tail pp shares)))
                       ((> (length+ (cdr ls)) (or indent-rule 1))
                        (each sep (joined/shares pp tail shares sep)))
                       (else
                        nothing)))))
             (indent-rule
              ;; fixed values lined up, body indented two spaces
              (try-fitted
               (each
                reset-shares
                " "
                (joined/shares pp fixed shares (make-nl-space (+ col2 1)))
                (if (pair? tail)
                    (let ((sep (make-nl-space (+ col1 2))))
                      (each sep (joined/shares pp tail shares sep)))
                    nothing))
               (each reset-shares default)))
             (else
              ;; all on separate lines
              (each reset-shares default)))))))
     ")")))

(define (pp-app ls pp shares)
  (let ((indent-rule (pp-indentation ls)))
    (if (procedure? indent-rule)
        (indent-rule ls pp shares)
        (pp-with-indent indent-rule ls pp shares))))

;; the elements may be shared, just checking the top level list
;; structure
(define (proper-non-shared-list? ls shares)
  (let ((tab (car shares)))
    (let lp ((ls ls))
      (or (null? ls)
          (and (pair? ls)
               (not (hash-table-ref/default tab ls #f))
               (lp (cdr ls)))))))

(define (non-app? x)
  (if (pair? x)
      (or (not (or (null? (cdr x)) (pair? (cdr x))))
          (non-app? (car x)))
      (not (symbol? x))))

(define (pp-data-list ls pp shares)
  (each
   "("
   (fn (col width string-width)
     (let ((avail (- width col)))
       (cond
        ;; ((and (pair? (cdr ls)) (pair? (cddr ls)) (pair? (cdr (cddr ls)))
        ;;       (fits-in-columns width ls (lambda (x) (pp-flat x pp shares))))
        ;;  => (lambda (ls)
        ;;       ;; at least four elements which can be broken into columns
        ;;       (let* ((prefix (make-nl-space col))
        ;;              (widest (+ 1 (car ls)))
        ;;              (columns (quotient width widest))) ; always >= 2
        ;;         (let lp ((ls (cdr ls)) (i 1))
        ;;           (cond
        ;;            ((null? ls)
        ;;             nothing)
        ;;            ((null? (cdr ls))
        ;;             (displayed (car ls)))
        ;;            ((>= i columns)
        ;;             (each (car ls)
        ;;                   prefix
        ;;                   (fn () (lp (cdr ls) 1))))
        ;;            (else
        ;;             (let ((pad (- widest (string-width (car ls)))))
        ;;               (each (car ls)
        ;;                     (make-space pad)
        ;;                     (lp (cdr ls) (+ i 1))))))))))
        (else
         ;; no room, print one per line
         (joined/shares pp ls shares (make-nl-space col))))))
   ")"))

(define (pp-flat x pp shares)
  (cond
   ((pair? x)
    (cond
     ((and (pair? (cdr x)) (null? (cddr x))
           (assq (car x) syntax-abbrevs))
      => (lambda (abbrev)
           (each (cdr abbrev)
                 (call-with-shared-ref
                  (cadr x)
                  shares
                  (pp-flat (cadr x) pp shares)))))
     (else
      (each "("
            (joined/shares (lambda (x) (pp-flat x pp shares)) x shares " ")
            ")"))))
   ((vector? x)
    (each "#("
          (joined/shares
           (lambda (x) (pp-flat x pp shares)) (vector->list x) shares " ")
          ")"))
   (else
    (pp x))))

(define (pp-pair ls pp shares)
  (cond
   ;; one element list, no lines to break
   ((null? (cdr ls))
    (each "(" (pretty (car ls)) ")"))
   ;; quote or other abbrev
   ((and (pair? (cdr ls)) (null? (cddr ls))
         (assq (car ls) syntax-abbrevs))
    => (lambda (abbrev)
         (each (cdr abbrev) (pp (cadr ls)))))
   (else
    (try-fitted
     (fn () (pp-flat ls pp shares))
     (with-reset-shares
      shares
      (fn ()
        (if (and (non-app? ls)
                 (proper-non-shared-list? ls shares))
            (pp-data-list ls pp shares)
            (pp-app ls pp shares))))))))

(define (pp-vector vec pp shares)
  (each "#" (pp-data-list (vector->list vec) pp shares)))

;; adapted from `write-with-shares'
(define (pp obj shares)
  (fn (radix precision)
    (let ((write-number
           (cond
            ((and (not precision)
                  (assv radix '((16 . "#x") (10 . "") (8 . "#o") (2 . "#b"))))
             => (lambda (cell)
                  (lambda (n)
                    (if (or (exact? n) (eqv? radix 10))
                        (each (cdr cell) (number->string n (car cell)))
                        (with ((radix 10)) (numeric n))))))
            (else (lambda (n) (with ((radix 10)) (numeric n)))))))
      (let pp ((obj obj))
        (call-with-shared-ref
         obj shares
         (fn ()
           (cond
            ((pair? obj)
             (pp-pair obj pp shares))
            ((vector? obj)
             (pp-vector obj pp shares))
            ((number? obj)
             (write-number obj))
            (else
             (write-with-shares obj shares)))))))))

(define (pretty obj)
  (fn ()
    (each (pp obj (extract-shared-objects obj #t))
          fl)))

(define (pretty-shared obj)
  (fn ()
    (each (pp obj (extract-shared-objects obj #f))
          fl)))

(define (pretty-simply obj)
  (fn ()
    (each (pp obj (extract-shared-objects #f #f))
          fl)))

(define-library (chibi show base)
  (export
   show fn fn-fork with update! each each-in-list call-with-output
   displayed written written-shared written-simply numeric nothing
   ;; internal
   output-default extract-shared-objects write-to-string write-with-shares
   call-with-shared-ref call-with-shared-ref/cdr)
  (import (scheme base) (scheme write) (scheme complex) (scheme inexact)
          (srfi 1) (srfi 69) (chibi string) (chibi monad environment))
  (include "base.scm")
  (include "write.scm"))
;; show.scm -- additional combinator formatters
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library of procedures for formatting Scheme objects to text in
;;> various ways, and for easily concatenating, composing and
;;> extending these formatters.

;;> \section{Background}
;;>
;;> There are several approaches to text formatting.  Building strings
;;> to \scheme{display} is not acceptable, since it doesn't scale to
;;> very large output.  The simplest realistic idea, and what people
;;> resort to in typical portable Scheme, is to interleave
;;> \scheme{display} and \scheme{write} and manual loops, but this is
;;> both extremely verbose and doesn't compose well.  A simple concept
;;> such as padding space can't be achieved directly without somehow
;;> capturing intermediate output.
;;>
;;> The traditional approach is to use templates - typically strings,
;;> though in theory any object could be used and indeed Emacs'
;;> mode-line format templates allow arbitrary sexps.  Templates can
;;> use either escape sequences (as in C's \cfun{printf} and
;;> \hyperlink["http://en.wikipedia.org/wiki/Format_(Common_Lisp)"]{CL's}
;;> \scheme{format}) or pattern matching (as in Visual Basic's
;;> \cfun{Format},
;;> \hyperlink["http://search.cpan.org/~dconway/Perl6-Form-0.04/Form.pm"}{Perl6's}
;;> \cfun{form}, and SQL date formats).  The primary disadvantage of
;;> templates is the relative difficulty (usually impossibility) of
;;> extending them, their opaqueness, and the unreadability that
;;> arises with complex formats.  Templates are not without their
;;> advantages, but they are already addressed by other libraries such
;;> as
;;> \hyperlink["http://srfi.schemers.org/srfi-28/srfi-28.html"]{SRFI-28}
;;> and
;;> \hyperlink["http://srfi.schemers.org/srfi-48/srfi-48.html"]{SRFI-48}.
;;>
;;> This library takes a combinator approach.  Formats are nested chains
;;> of closures, which are called to produce their output as needed.
;;> The primary goal of this library is to have, first and foremost, a
;;> maximally expressive and extensible formatting library.  The next
;;> most important goal is scalability - to be able to handle
;;> arbitrarily large output and not build intermediate results except
;;> where necessary.  The third goal is brevity and ease of use.

;;> \section{Interface}

;;> \procedure{(show out [args ...])}
;;>
;;> The primary interface.  Analogous to CL's \scheme{format}, the first
;;> argument is either an output port or a boolean, with \scheme{#t}
;;> indicating \scheme{current-output-port} and \scheme{#f} indicating a
;;> string port.  The remaining arguments are formatters, combined as with
;;> \scheme{each}, run with output to the given destination.  If \var{out}
;;> is \scheme{#f} then the accumulated output is returned, otherwise
;;> the result is unspecified.

;;> \section{Formatters}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Spacing

;;> Output a single newline.
(define nl (displayed "\n"))

;;> "Fresh line" - output a newline iff we're not at the start of a
;;> fresh line.
(define fl
  (fn (col) (if (zero? col) nothing nl)))

;;> Move to a given tab-stop (using spaces, not tabs).
(define (tab-to . o)
  (fn (col pad-char)
    (let* ((tab-width (if (pair? o) (car o) 8))
           (rem (modulo col tab-width)))
      (if (positive? rem)
          (displayed (make-string (- tab-width rem) pad-char))
          nothing))))

;;> Move to an explicit column.
(define (space-to where)
  (fn (col pad-char)
    (displayed (make-string (max 0 (- where col)) pad-char))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; String transformations

(define (with-string-transformer proc . ls)
  (fn (output)
    (let ((output* (lambda (str) (fn () (output (proc str))))))
      (with ((output output*)) (each-in-list ls)))))

;;> Show each of \var{ls}, uppercasing all generated text.
(define (upcased . ls) (apply with-string-transformer string-upcase ls))

;;> Show each of \var{ls}, lowercasing all generated text.
(define (downcased . ls) (apply with-string-transformer string-downcase ls))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Padding and trimming

;;> Pad the result of \scheme{(each-in-list ls)} to at least
;;> \var{width} characters, equally applied to the left and right,
;;> with any extra odd padding applied to the right.  Uses the value
;;> of \scheme{pad-char} for padding, defaulting to \scheme{#\\space}.
(define (padded/both width . ls)
  (call-with-output
   (each-in-list ls)
   (lambda (str)
     (fn (string-width pad-char)
       (let ((diff (- width (string-width str))))
         (if (positive? diff)
             (let* ((diff/2 (quotient diff 2))
                    (left (make-string diff/2 pad-char))
                    (right (if (even? diff)
                               left
                               (make-string (+ 1 diff/2) pad-char))))
               (each right str left))
             (displayed str)))))))

;;> As \scheme{padded/both} but only applies padding on the right.
(define (padded width . ls)
  (fn ((col1 col))
    (each (each-in-list ls)
          (fn ((col2 col) pad-char)
            (displayed (make-string (max 0 (- width (- col2 col1)))
                                    pad-char))))))

;;> An alias for \scheme{padded}.
(define padded/right padded)

;;> As \scheme{padded/both} but only applies padding on the left.
(define (padded/left width . ls)
  (call-with-output
   (each-in-list ls)
   (lambda (str)
     (fn (string-width pad-char)
       (let ((diff (- width (string-width str))))
         (each (make-string diff pad-char) str))))))

;; General buffered trim - capture the output apply a trimmer.
(define (trimmed/buffered width producer proc)
  (call-with-output
   producer
   (lambda (str)
     (fn (string-width)
       (let* ((str-width (string-width str))
              (diff (- str-width width)))
         (displayed (if (positive? diff)
                        (proc str str-width diff)
                        str)))))))

;;> Trims the result of \scheme{(each-in-list ls)} to at most
;;> \var{width} characters, removed from the right.  If any characters
;;> are removed, then the value of \scheme{ellipsis} (default empty)
;;> is used in its place (trimming additional characters as needed to
;;> be sure the final output doesn't exceed \var{width}).
(define (trimmed width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width col)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len) width)))
         (each (if (negative? diff)
                   nothing
                   (substring str 0 (- width ell-len)))
               ell))))))

;;> An alias for \scheme{trimmed}.
(define trimmed/right trimmed)

;;> As \scheme{trimmed} but removes from the left.
(define (trimmed/left width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len) width)))
         (each ell
               (if (negative? diff)
                   nothing
                   (substring str diff))))))))

;;> As \scheme{trimmed} but removes equally from both the left and the
;;> right, removing extra odd characters from the right, and inserting
;;> \scheme{ellipsis} on both sides.
(define (trimmed/both width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len ell-len) width))
              (left (quotient diff 2))
              (right (- (string-width str) (quotient (+ diff 1) 2))))
         (if (negative? diff)
             ell
             (each ell (substring str left right) ell)))))))

;;> A \scheme{trimmed}, but truncates and terminates immediately if
;;> more than \var{width} characters are generated by \var{ls}.  Thus
;;> \var{ls} may lazily generate an infinite amount of output safely
;;> (e.g. \scheme{write-simple} on an infinite list).  The nature of
;;> this procedure means only truncating on the right is meaningful.
(define (trimmed/lazy width . ls)
  (fn (orig-output string-width)
    (call-with-current-continuation
     (lambda (return)
       (let ((chars-written 0)
             (output (or orig-output output-default)))
         (define (output* str)
           (let ((len (string-width str)))
             (set! chars-written (+ chars-written len))
             (if (> chars-written width)
                 (let* ((end (max 0 (- len (- chars-written width))))
                        (s (substring str 0 end)))
                   (each (output s)
                         (update! (output orig-output))
                         (fn () (return nothing))))
                 (output str))))
         (with ((output output*))
           (each-in-list ls)))))))

;;> Fits the result of \scheme{(each-in-list ls)} to exactly
;;> \var{width} characters, padding or trimming on the right as
;;> needed.
(define (fitted width . ls)
  (padded width (trimmed width (each-in-list ls))))

;;> An alias for \scheme{fitted}.
(define fitted/right fitted)

;;> As \scheme{fitted} but pads/trims from the left.
(define (fitted/left width . ls)
  (padded/left width (trimmed/left width (each-in-list ls))))

;;> As \scheme{fitted} but pads/trims equally from both the left and
;;> the right.
(define (fitted/both width . ls)
  (padded/both width (trimmed/both width (each-in-list ls))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Joining and interspersing

(define (joined/general elt-f last-f dot-f init-ls sep)
  (fn ()
    (let lp ((ls init-ls))
      (cond
       ((pair? ls)
        (each (if (eq? ls init-ls) nothing sep)
              ((if (and last-f (null? (cdr ls))) last-f elt-f) (car ls))
              (lp (cdr ls))))
       ((and dot-f (not (null? ls)))
        (each (if (eq? ls init-ls) nothing sep) (dot-f ls)))
       (else
        nothing)))))

;;> \procedure{(joined elt-f ls [sep])}
;;>
;;> Joins the result of applying \var{elt-f} to each element of the
;;> list \var{ls} together with \var{sep}, which defaults to the empty
;;> string.
(define (joined elt-f ls . o)
  (joined/general elt-f #f #f ls (if (pair? o) (car o) "")))

;;> As \scheme{joined} but treats the separator as a prefix, inserting
;;> before every element instead of between.
(define (joined/prefix elt-f ls . o)
  (if (null? ls)
      nothing
      (let ((sep (if (pair? o) (car o) "")))
        (each sep (joined elt-f ls sep)))))

;;> As \scheme{joined} but treats the separator as a suffix, inserting
;;> after every element instead of between.
(define (joined/suffix elt-f ls . o)
  (if (null? ls)
      nothing
      (let ((sep (if (pair? o) (car o) "")))
        (each (joined elt-f ls sep) sep))))

;;> As \scheme{joined} but applies \var{last-f}, instead of
;;> \var{elt-f}, to the last element of \var{ls}, useful for
;;> e.g. commas separating a list with "and" before the final element.
(define (joined/last elt-f last-f ls . o)
  (joined/general elt-f last-f #f ls (if (pair? o) (car o) "")))

;;> As \scheme{joined} but if \var{ls} is a dotted list applies
;;> \var{dot-f} to the dotted tail as a final element.
(define (joined/dot elt-f dot-f ls . o)
  (joined/general elt-f #f dot-f ls (if (pair? o) (car o) "")))
;; write.scm - written formatting, the default displayed for non-string/chars
;; Copyright (c) 2006-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{String utilities}

(define (write-to-string x)
  (let ((out (open-output-string)))
    (write x out)
    (get-output-string out)))

(define (string-replace-all str ch1 ch2)
  (let ((out (open-output-string)))
    (string-for-each
     (lambda (ch) (write-char (if (eqv? ch ch1) ch2 ch) out))
     str)
    (get-output-string out)))

(define (string-intersperse-right str sep rule)
  (let lp ((i (string-length str))
           (rule rule)
           (res '()))
    (let* ((offset (if (pair? rule) (car rule) rule))
           (i2 (if offset (- i offset) 0)))
      (if (<= i2 0)
          (apply string-append (cons (substring str 0 i) res))
          (lp i2
              (if (pair? rule) (cdr rule) rule)
              (cons sep (cons (substring str i2 i) res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; numeric formatting

(define (char-mirror c)
  (case c ((#\() #\)) ((#\[) #\]) ((#\{) #\}) ((#\<) #\>) (else c)))

(define (integer-log a base)
  (if (zero? a)
      0
      (exact (ceiling (/ (log (+ a 1)) (log base))))))

;; The original fmt algorithm was based on "Printing Floating-Point
;; Numbers Quickly and Accurately" by Burger and Dybvig
;; (FP-Printing-PLDI96.pdf).  It had grown unwieldy with formatting
;; special cases, so the below is a simplification which tries to rely
;; on number->string for common cases.

(define (numeric n)
  (fn (radix precision decimal-sep decimal-align comma-rule comma-sep sign-rule)
    (let ((dec-sep (or decimal-sep (if (eqv? comma-sep #\.) #\, #\.))))
      ;; General formatting utilities.
      (define (get-scale q)
        (expt radix (- (integer-log q radix) 1)))
      (define (char-digit d)
        (cond ((char? d) d)
              ((< d 10) (integer->char (+ d (char->integer #\0))))
              (else (integer->char (+ (- d 10) (char->integer #\a))))))
      (define (digit-value ch)
        (let ((res (- (char->integer ch) (char->integer #\0))))
          (if (<= 0 res 9)
              res
              ch)))
      (define (round-up ls)
        (let lp ((ls ls) (res '()))
          (cond
           ((null? ls)
            (cons 1 res))
           ((not (number? (car ls)))
            (lp (cdr ls) (cons (car ls) res)))
           ((= (car ls) (- radix 1))
            (lp (cdr ls) (cons 0 res)))
           (else
            (append (reverse res) (cons (+ 1 (car ls)) (cdr ls)))))))
      (define (maybe-round n d ls)
        (let* ((q (quotient n d))
               (digit (* 2 (if (>= q radix) (quotient q (get-scale q)) q))))
          (if (or (> digit radix)
                  (and (= digit radix)
                       (let ((prev (find integer? ls)))
                         (and prev (odd? prev)))))
              (round-up ls)
              ls)))
      (define (maybe-trim-zeros i res)
        (if (and (not precision) (positive? i))
            (let lp ((res res))
              (cond
               ((and (pair? res) (eqv? 0 (car res))) (lp (cdr res)))
               ((and (pair? res) (eqv? dec-sep (car res))) (cdr res))
               (else res)))
            res))
      ;; General slow loop to generate digits one at a time, for
      ;; non-standard radixes or writing rationals with a fixed
      ;; precision.
      (define (gen-general n)
        (let* ((p (exact n))
               (n (numerator p))
               (d (denominator p)))
          (let lp ((n n)
                   (i (- (integer-log p radix)))
                   (res '()))
            (cond
             ;; Use a fixed precision if specified, otherwise generate
             ;; 15 decimals.
             ((if precision (< i precision) (< i 16))
              (let ((res (if (zero? i)
                             (cons dec-sep (if (null? res) (cons 0 res) res))
                             res))
                    (q (quotient n d)))
                (cond
                 ((>= q radix)
                  (let* ((scale (get-scale q))
                         (digit (quotient q scale))
                         (n2 (- n (* d digit scale))))
                    (lp n2 (+ i 1) (cons digit res))))
                 (else
                  (lp (* (remainder n d) radix)
                      (+ i 1)
                      (cons q res))))))
             (else
              (list->string
               (map char-digit
                    (reverse (maybe-round n d (maybe-trim-zeros i res))))))))))
      ;; Generate a fixed precision decimal result by post-editing the
      ;; result of string->number.
      (define (gen-fixed n)
        (cond
         ((and (eqv? radix 10) (or (integer? n) (inexact? n)))
          (let* ((s (number->string n))
                 (len (string-length s))
                 (dec (string-find s #\.))
                 (digits (- len dec)))
            (cond
             ((< (string-find s #\e) len)
              (gen-general n))
             ((= dec len)
              (string-append s "." (make-string precision #\0)))
             ((<= digits precision)
              (string-append s (make-string (- precision digits -1) #\0)))
             (else
              (let* ((last (- len (- digits precision 1)))
                     (res (substring s 0 last)))
                (if (and
                     (< last len)
                     (let ((next (digit-value (string-ref s last))))
                       (or (> next 5)
                           (and (= next 5) (> last 0)
                                (odd? (digit-value
                                       (string-ref s (- last 1))))))))
                    (list->string
                     (reverse
                      (map char-digit
                           (round-up
                            (reverse (map digit-value (string->list res)))))))
                    res))))))
         (else
          (gen-general n))))
      ;; Generate any unsigned real number.
      (define (gen-positive-real n)
        (cond
         (precision
          (gen-fixed n))
         ((and (exact? n) (not (integer? n)))
          (string-append (number->string (numerator n) radix)
                         "/"
                         (number->string (denominator n) radix)))
         ((memv radix (if (exact? n) '(2 8 10 16) '(10)))
          (number->string n))
         (else
          (gen-general n))))
      ;; Insert commas according to the current comma-rule.
      (define (insert-commas str)
        (let* ((dec-pos (string-find str dec-sep))
               (left (substring str 0 dec-pos))
               (right (substring str dec-pos))
               (sep (cond ((char? comma-sep) (string comma-sep))
                          ((string? comma-sep) comma-sep)
                          ((eqv? #\, dec-sep) ".")
                          (else ","))))
          (string-append
           (string-intersperse-right left sep comma-rule)
           right)))
      ;; Post-process a positive real number with decimal char fixup
      ;; and commas as needed.
      (define (wrap-comma n)
        (let* ((s0 (gen-positive-real n))
               (s1 (if (and (char? dec-sep)
                            (not (eqv? #\. dec-sep)))
                       (string-replace-all s0 #\. dec-sep)
                       s0)))
          (if comma-rule (insert-commas s1) s1)))
      ;; Wrap the sign of a real number, forcing a + prefix or using
      ;; parentheses (n) for negatives according to sign-rule.
      (define (wrap-sign n sign-rule)
        (cond
         ((negative? n)
          (if (char? sign-rule)
              (string-append (string sign-rule)
                             (wrap-comma (abs n))
                             (string (char-mirror sign-rule)))
              (string-append "-" (wrap-comma (abs n)))))
         ((eq? #t sign-rule)
          (string-append "+" (wrap-comma n)))
         (else
          (wrap-comma n))))
      ;; Format a single real number with padding as necessary.
      (define (format n sign-rule)
        (let ((s (wrap-sign n sign-rule)))
          (let* ((dec-pos (if decimal-align (string-find s dec-sep) 0))
                 (diff (- (or decimal-align 0) dec-pos 1)))
            (if (positive? diff)
                (string-append (make-string diff #\space) s)
                s))))
      ;; Write any number.
      (define (write-complex n)
        (cond
         ((and radix (not (and (integer? radix) (<= 2 radix 36))))
          (error "invalid radix for numeric formatting" radix))
         ((zero? (imag-part n))
          (displayed (format (real-part n) sign-rule)))
         (else
          (each (format (real-part n) sign-rule)
                (format (imag-part n) #t)
                "i"))))
      (write-complex n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; shared structure utilities

(define (extract-shared-objects x cyclic-only?)
  (let ((seen (make-hash-table eq?)))
    ;; find shared references
    (let find ((x x))
      (cond ;; only interested in pairs and vectors (and records later)
       ((or (pair? x) (vector? x))
        ;; increment the count
        (hash-table-update!/default seen x (lambda (n) (+ n 1)) 0)
        ;; walk if this is the first time
        (cond
         ((> (hash-table-ref seen x) 1))
         ((pair? x)
          (find (car x))
          (find (cdr x)))
         ((vector? x)
          (do ((i 0 (+ i 1)))
              ((= i (vector-length x)))
            (find (vector-ref x i)))))
        ;; delete if this shouldn't count as a shared reference
        (if (and cyclic-only? (<= (hash-table-ref/default seen x 0) 1))
            (hash-table-delete! seen x)))))
    ;; extract shared references
    (let ((res (make-hash-table eq?))
          (count 0))
      (hash-table-walk
       seen
       (lambda (k v)
         (cond
          ((> v 1)
           (hash-table-set! res k (cons count #f))
           (set! count (+ count 1))))))
      (cons res 0))))

(define (maybe-gen-shared-ref cell shares)
  (cond
    ((pair? cell)
     (set-car! cell (cdr shares))
     (set-cdr! cell #t)
     (set-cdr! shares (+ (cdr shares) 1))
     (each "#" (number->string (car cell)) "="))
    (else nothing)))

(define (call-with-shared-ref obj shares proc)
  (let ((cell (hash-table-ref/default (car shares) obj #f)))
    (if (and (pair? cell) (cdr cell))
        (each "#" (number->string (car cell)) "#")
        (each (maybe-gen-shared-ref cell shares) proc))))

(define (call-with-shared-ref/cdr obj shares proc . o)
  (let ((sep (displayed (if (pair? o) (car o) "")))
        (cell (hash-table-ref/default (car shares) obj #f)))
    (cond
      ((and (pair? cell) (cdr cell))
       (each sep ". #" (number->string (car cell)) "#"))
      ((pair? cell)
       (each sep ". " (maybe-gen-shared-ref cell shares) "(" proc ")"))
      (else
       (each sep proc)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; written

(define (write-with-shares obj shares)
  (fn (radix precision)
    (let ((write-number
           ;; Shortcut for numeric values.  Try to rely on
           ;; number->string for standard radixes and no precision,
           ;; otherwise fall back on numeric but resetting to a usable
           ;; radix.
           (cond
            ((and (not precision)
                  (assv radix '((16 . "#x") (10 . "") (8 . "#o") (2 . "#b"))))
             => (lambda (cell)
                  (lambda (n)
                    (if (or (exact? n) (eqv? radix 10))
                        (each (cdr cell) (number->string n (car cell)))
                        (with ((radix 10)) (numeric n))))))
            (else (lambda (n) (with ((radix 10)) (numeric n)))))))
      ;; `wr' is the recursive writer closing over the shares.
      (let wr ((obj obj))
        (call-with-shared-ref
         obj shares
         (fn ()
           (cond
            ((pair? obj)
             (each "("
                   (fn ()
                     (let lp ((ls obj))
                       (let ((rest (cdr ls)))
                         (each (wr (car ls))
                               (cond
                                ((null? rest)
                                 nothing)
                                ((pair? rest)
                                 (each
                                  " "
                                  (call-with-shared-ref/cdr
                                   rest shares
                                   (fn () (lp rest)))))
                                (else
                                 (each " . " (wr rest))))))))
                   ")"))
            ((vector? obj)
             (let ((len (vector-length obj)))
               (if (zero? len)
                   (displayed "#()")
                   (each "#("
                         (wr (vector-ref obj 0))
                         (fn ()
                           (let lp ((i 1))
                             (if (>= i len)
                                 nothing
                                 (each " " (wr (vector-ref obj i))
                                       (fn () (lp (+ i 1)))))))
                         ")"))))
            ((number? obj)
             (write-number obj))
            (else
             (displayed (write-to-string obj))))))))))

;; The default formatter for `written', overriden with the `writer'
;; variable.  Intended to be equivalent to `write', using datum labels
;; for shared notation iff there are cycles in the object.

(define (written-default obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects obj #t))))

;; Writes the object showing the full shared structure.

(define (written-shared obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects obj #f))))

;; The only expensive part, in both time and memory, of handling
;; shared structures when writing is building the initial table, so
;; for the efficient version we just skip that and re-use the writing
;; code.

(define (written-simply obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects #f #f))))

;; Local variables:
;; eval: (put 'fn 'scheme-indent-function 1)
;; End:

;; Table mapping traced procedures to their original untraced values.
(define all-traces
  (make-parameter (make-hash-table eq?)))

;; The current number of traced procedure frames on the stack.
(define active-trace-depth
  (make-parameter 0))

(define (show-trace cell args)
  (let ((out (current-error-port)))
    (do ((i 0 (+ i 1)))
        ((>= i (active-trace-depth)))
      (display "| " out))
    (display "> " out)
    (write/ss (cons (car cell) args) out)
    (newline out)))

(define (show-trace-result cell args res)
  (let ((out (current-error-port)))
    (do ((i 0 (+ i 1)))
        ((>= i (active-trace-depth)))
      (display "| " out))
    (write/ss res out)
    (newline out)))

(define (make-tracer cell)
  (let ((proc (cdr cell)))
    (lambda args
      (show-trace cell args)
      (active-trace-depth (+ (active-trace-depth) 1))
      (let ((res (apply proc args)))
        (active-trace-depth (- (active-trace-depth) 1))
        (show-trace-result cell args res)
        res))))

(define-syntax trace
  (syntax-rules ()
    ((trace id)
     (trace-cell (env-cell (interaction-environment) 'id)))))

(define-syntax untrace
  (syntax-rules ()
    ((untrace id)
     (untrace-cell (env-cell (interaction-environment) 'id)))))

(define (warn . args)
  (let ((out (current-error-port)))
    (display "WARNING: " out)
    (for-each (lambda (x) (display x out)) args)
    (newline out)))

(define (trace-cell cell)
  (let ((tab (all-traces)))
    (cond
     ((not (pair? cell))
      (warn "No such binding."))
     ((hash-table-exists? tab cell)
      (warn "Procedure already being traced: " (car cell)))
     (else
      (hash-table-set! tab cell (cdr cell))
      (set-cdr! cell (make-tracer cell))))))

(define (untrace-cell cell)
  (let ((tab (all-traces)))
    (cond
     ((not (pair? cell))
      (warn "No such binding."))
     ((not (hash-table-exists? tab cell))
      (warn "Procedure not being traced: " (car cell)))
     (else
      (let ((proc (hash-table-ref tab cell)))
        (hash-table-delete! tab cell)
        (set-cdr! cell proc))))))

(define (untrace-all)
  (hash-table-walk (all-traces) (lambda (cell proc) (set-cdr! cell proc)))
  (all-traces (make-hash-table eq?)))
(define-library (chibi emscripten)
  (cond-expand
    (emscripten
      (import (chibi) (chibi ast))
      (export eval-script! integer-eval-script string-eval-script
              wait-on-event!)
      (include "emscripten.scm")
      (include-shared "emscripten"))))

(define-library (chibi show)
  (export
   show fn fn-fork with update! each each-in-list call-with-output
   displayed written written-shared written-simply numeric nothing
   nl fl space-to tab-to
   padded padded/left padded/right padded/both
   trimmed trimmed/left trimmed/right trimmed/both trimmed/lazy
   fitted fitted/left fitted/right fitted/both
   joined joined/prefix joined/suffix joined/last joined/dot
   upcased downcased)
  (import (scheme base) (scheme char) (chibi show base) (scheme write))
  (include "show/show.scm"))

;;> Simple generic function interface.

(define-library (chibi generic)
  (export define-generic define-method make-generic generic-add!)
  (import (chibi))
  (include "generic.scm"))
;; prime.scm -- prime number utilities
;; Copyright (c) 2004-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Prime and number theoretic utilities.

;;> Returns a pair whose car is the power of 2 in the factorization of
;;> n, and whose cdr is the product of all remaining primes.
(define (factor-twos n)
  (do ((p 0 (+ p 1))
       (r n (arithmetic-shift r -1)))
      ((odd? r) (cons p r))))

;;> Returns the multiplicative inverse of \var{a} modulo \var{b}.
(define (modular-inverse a b)
  (let lp ((a1 a) (b1 b) (x 0) (y 1) (last-x 1) (last-y 0))
    (if (zero? b1)
        (if (negative? last-x) (+ last-x b) last-x)
        (let ((q (quotient a1 b1)))
          (lp b1 (remainder a1 b1)
              (- last-x (* q x)) (- last-y (* q y))
              x y)))))

;;> Returns (remainder (expt a e) m).
(define (modular-expt a e m)
  (let lp ((tmp a) (e e) (res 1))
    (if (zero? e)
        res
        (lp (remainder (* tmp tmp) m)
            (arithmetic-shift e -1)
            (if (odd? e) (remainder (* res tmp) m) res)))))

;;> Returns true iff n and m are coprime.
(define (coprime? n m)
  (= 1 (gcd n m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Exact prime testing.

;; All primes under 1000.
(define prime-table
  '#(  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59
      61  67  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139
     149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233
     239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337
     347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439
     443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557
     563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653
     659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769
     773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883
     887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 ))

;;> Returns true iff \var{n} is definitely prime.  May take an
;;> impossibly long time for large values.
(define (provable-prime? n)
  (if (or (even? n) (<= n 2))
      (= 2 n)
      (let ((limit (exact (ceiling (sqrt n)))))
        (define (by-twos d)
          (cond ((> d limit) #t)
                ((zero? (remainder n d)) #f)
                (else (by-twos (+ d 2)))))
        (let ((len (vector-length prime-table)))
          (let lp ((i 0))
            (if (>= i len)
                (by-twos (vector-ref prime-table (- len 1)))
                (let ((d (vector-ref prime-table i)))
                  (cond
                   ((> d limit) #t)
                   ((zero? (remainder n d)) #f)
                   (else (lp (+ i 1)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Probable primes.

(define (modular-root-of-one? twos odd a n neg1)
  ;; Returns true iff any (modular-expt a odd*2^i n) for i=0..twos-1
  ;; returns 1 modulo n.
  (let ((b (modular-expt a odd n)))
    (let lp ((i 0) (b b))
      (cond ((or (= b 1) (= b neg1)))  ; in (= b 1) case we could factor
            ((>= i twos) #f)
            (else (lp (+ i 1) (remainder (* b b) n)))))))

;;> Returns true if we can show \var{n} to be composite by finding an
;;> exception to the Miller Rabin lemma.
(define (miller-rabin-composite? n)
  (let* ((neg1 (- n 1))
         (factors (factor-twos neg1))
         (twos (car factors))
         (odd (cdr factors))
         ;; Each iteration of Miller Rabin reduces the odds by 1/4, so
         ;; this is a 1 in 2^40 probability of false positive,
         ;; assuming good randomness from SRFI 27 and no bugs, further
         ;; reduced by preliminary sieving.
         (fixed-limit 16)
         (rand-limit (if (< n 341550071728321) fixed-limit 20)))
    (let try ((i 0))
      (and (< i rand-limit)
           (let ((a (if (< i fixed-limit)
                        (vector-ref prime-table i)
                        (+ (random-integer (- n 3)) 2))))
             (or (not (modular-root-of-one? twos odd a n neg1))
                 (try (+ i 1))))))))

;;> Returns true if \var{n} has a very high probability (enough that
;;> you can assume a false positive will never occur in your lifetime)
;;> of being prime.
(define (probable-prime? n)
  (cond
   ((< n 1) #f)
   (else
    (let ((len (vector-length prime-table)))
      (let lp ((i 0))
        (if (>= i len)
            (not (miller-rabin-composite? n))
            (let ((x (vector-ref prime-table i)))
              (cond
               ((>= x n) (= x n))
               ((zero? (remainder n x)) #f)
               (else (lp (+ i 1)))))))))))

;;> Returns true iff \var{n} is prime.  Uses \scheme{provable-prime?}
;;> for small \var{n}, falling back on \scheme{probable-prime?} for
;;> large values.
(define (prime? n)
  (and (> n 1)
       (if (< n #e1e10)
           (provable-prime? n)
           (probable-prime? n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Prime iteration and factorization

;;> Returns the nth prime, with 2 being the 0th prime.
(define (nth-prime i)
  (define (by-twos n j)
    (if (prime? n)
        (if (<= j 0) n (by-twos (+ n 2) (- j 1)))
        (by-twos (+ n 2) j)))
  (let ((len (vector-length prime-table)))
    (if (< i len)
        (vector-ref prime-table i)
        (by-twos (+ 2 (vector-ref prime-table (- len 1))) (- i len)))))

;;> Returns the first prime less than or equal to \var{n}, or #f if
;;> there are no such primes.
(define (prime-below n)
  (and (>= n 3)
       (let lp ((n (if (even? n) (- n 1) n)))
         (if (prime? n) n (lp (- n 2))))))

;;> Returns the first prime greater than or equal to \var{n}.  If the
;;> optional \var{limit} is given and not false, returns \scheme{#f}
;;> if no such primes exist below \var{limit}.
(define (prime-above n . o)
  (let ((limit (and (pair? o) (car o))))
    (let lp ((n (if (even? n) (+ n 1) n)))
      (cond
       ((and limit (>= n limit)) #f)
       ((prime? n) n)
       (else (lp (+ n 2)))))))

;;> Returns the factorization of \var{n} as a monotonically
;;> increasing list of primes.
(define (factor n)
  (cond
   ((negative? n)
    (cons -1 (factor (- n))))
   ((<= n 2)
    (list n))
   (else
    (let lp ((n n)
             (res (list)))
      (cond
       ((even? n)
        (lp (quotient n 2) (cons 2 res)))
       ((= n 1)
        (reverse res))
       (else
        (let lp ((i 3) (n n) (limit (exact (ceiling (sqrt n)))) (res res))
          (cond
           ((= n 1)
            (reverse res))
           ((> i limit)
            (reverse (cons n res)))
           ((zero? (remainder n i))
            (lp i (quotient n i) limit (cons i res)))
           (else
            (lp (+ i 2) n limit res))))))))))

;;> Returns the Euler totient function, the number of positive
;;> integers less than \var{n} that are relatively prime to \var{n}.
(define (totient n)
  (let ((limit (exact (ceiling (sqrt n)))))
    (let lp ((i 2) (count 1))
      (cond ((> i limit)
             (if (= count (- i 1))
                 (- n 1)                ; shortcut for prime
                 (let lp ((i i) (count count))
                   (cond ((>= i n) count)
                         ((= 1 (gcd n i)) (lp (+ i 1) (+ count 1)))
                         (else (lp (+ i 1) count))))))
            ((= 1 (gcd n i)) (lp (+ i 1) (+ count 1)))
            (else (lp (+ i 1) count))))))

;;> The aliquot sum s(n), equal to the sum of proper divisors of an
;;> integer n.
(define (aliquot n)
  (let ((limit (+ 1 (quotient n 2))))
    (let lp ((i 2) (sum 1))
      (cond ((> i limit) sum)
            ((zero? (remainder n i)) (lp (+ i 1) (+ sum i)))
            (else (lp (+ i 1) sum))))))

;;> Returns true iff \var{n} is a perfect number, i.e. the sum of its
;;> divisors other than itself equals itself.
(define (perfect? n)
  (and (> n 1) (= n (aliquot n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Random prime generation

;;> Returns a random prime between \var{lo}, inclusive, and \var{hi},
;;> exclusive.
(define (random-prime lo hi)
  (if (> lo hi)
      (error "bad range: " lo hi))
  (let ((n (bitwise-ior 1 (+ lo (random-integer (- hi lo))))))
    (or (prime-above n hi)
        (prime-above lo n)
        (error "couldn't find prime between: " lo hi))))

;;> Variant of \scheme{random-prime} which ensures the result is
;;> distinct from \var{p}.
(define (random-prime-distinct-from lo hi p)
  (let ((q (random-prime lo hi)))
    (if (= q p)
        (random-prime-distinct-from lo hi p)
        q)))

;;> Returns a random integer less than \var{n} relatively prime to
;;> \var{n}.
(define (random-coprime n)
  (let ((init (+ 2 (random-integer (- n 1)))))
    (let lp ((m init))
      (cond ((>= m n)
             (let lp ((m (- init 1)))
               (cond
                ((<= m 1) (error "couldn't find coprime to " n))
                ((coprime? n m) m)
                (else (lp (- m 1))))))
            ((coprime? n m) m)
            (else (lp (+ m 1)))))))

(define-library (chibi math prime)
  (import (scheme base) (scheme inexact) (srfi 27) (srfi 33))
  (export prime? nth-prime prime-above prime-below factor perfect?
          totient aliquot
          provable-prime? probable-prime?
          random-prime random-prime-distinct-from
          coprime? random-coprime modular-inverse modular-expt
          miller-rabin-composite?)
  (include "prime.scm"))
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for parsing and constructing URI objects.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; URI representation

(define-record-type Uri
  (%make-uri scheme user host port path query fragment)
  uri?
  (scheme uri-scheme)
  (user uri-user)
  (host uri-host)
  (port uri-port)
  (path uri-path)
  (query uri-query)
  (fragment uri-fragment))

;;> Accessors for the URI type.
;;/

;;> \procedure{(make-uri scheme [user host port path query fragment])}

(define (make-uri scheme . o)
  (let* ((user (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (host (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (port (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (path (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (query (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (fragment (and (pair? o) (car o))))
    (%make-uri scheme user host port path query fragment)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (uri-with-scheme u scheme)
  (%make-uri scheme (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-user u user)
  (%make-uri (uri-scheme u) user (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-host u host)
  (%make-uri (uri-scheme u) (uri-user u) host (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-port u port)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) port
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-path u path)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             path (uri-query u) (uri-fragment u)))

(define (uri-with-query u query)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) query (uri-fragment u)))

(define (uri-with-fragment u fragment)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) fragment))

;;> Functional updaters - returns a new uri identical to \var{u}
;;> with only the specified field changed.
;;/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parsing - without :// we just split into scheme & path

(define (char-uri-scheme-unsafe? ch)
  (not (or (char-alphabetic? ch) (char-numeric? ch) (memv ch '(#\+ #\- #\.)))))

;;> Parses a string with a default scheme and returns a new URI
;;> object.  If the string does not begin with a scheme it is take to
;;> be a simple path URI with the default scheme.  This is a
;;> lightweight permissive parser.

(define (string->path-uri scheme str . o)
  (define decode? (and (pair? o) (car o)))
  (define decode (if decode? uri-decode (lambda (x) x)))
  (define decode-query
    (if (and (pair? o) (pair? (cdr o)) (cadr o))
        (if decode? (lambda (q) (uri-query->alist q #t)) uri-query->alist)
        decode))
  (if (uri? str)
      str
      (let* ((start (string-cursor-start str))
             (end (string-cursor-end str))
             (colon0 (string-find str #\:))
             (colon
              (if (string-cursor>=?
                   (string-find str char-uri-scheme-unsafe? start colon0)
                   colon0)
                  colon0
                  end)))
        (if (string-cursor>=? colon end)
            (and scheme
                 (let* ((quest (string-find str #\?))
                        (pound
                         (string-find
                          str
                          #\#
                          (if (string-cursor<? quest end) quest start))))
                   (make-uri scheme #f #f #f
                             (decode
                              (substring-cursor
                               str start (if (< quest end) quest pound)))
                             (and (< quest end)
                                  (decode-query
                                   (substring-cursor str (+ quest 1) pound)))
                             (and (< pound end)
                                  (decode
                                   (substring-cursor str (+ pound 1) end))))))
            (let ((sc1 (+ colon 1))
                  (scheme (string->symbol
                           (string-downcase-ascii
                            (substring-cursor str start colon)))))
              (if (string-cursor>=? sc1 end)
                  (make-uri scheme)
                  (if (or (string-cursor>=? (+ sc1 1) end)
                          (not
                           (and (eqv? #\/ (string-cursor-ref str sc1))
                                (eqv? #\/ (string-cursor-ref str (+ sc1 1))))))
                      (make-uri scheme #f #f #f (substring-cursor str sc1 end))
                      (if (string-cursor>=? (+ sc1 2) end)
                          (make-uri scheme #f "")
                          (let* ((sc2 (+ sc1 2))
                                 (slash (string-find str #\/ sc2))
                                 (at (string-find-right str #\@ sc2 slash))
                                 (colon3
                                  (string-find
                                   str #\: (if (> at sc2) at sc2) slash))
                                 (quest (string-find str #\? slash))
                                 (pound
                                  (string-find
                                   str #\# (if (< quest end) quest slash))))
                            (%make-uri
                             scheme
                             (and (> at sc2)
                                  (decode (substring-cursor str sc2 at)))
                             (decode
                              (substring-cursor
                               str
                               (if (> at sc2) (+ at 1) sc2)
                               (if (< colon3 slash) colon3 slash)))
                             (and (< colon3 slash)
                                  (string->number
                                   (substring-cursor str (+ colon3 1) slash)))
                             (and (< slash end)
                                  (decode
                                   (substring-cursor
                                    str slash (if (< quest end) quest pound))))
                             (and (< quest end)
                                  (decode-query
                                   (substring-cursor str (+ quest 1) pound)))
                             (and (< pound end)
                                  (decode
                                   (substring-cursor str (+ pound 1) end)))
                             ))))))))))

;;> Parses a string and returns a new URI object.  If the string does
;;> not have a scheme, returns false.

(define (string->uri str . o)
  (apply string->path-uri #f str o))

;;> Convert a URI object to a string.  Returns #f if the uri has no scheme.

(define (uri->string uri . o)
  (define encode? (and (pair? o) (car o)))
  (define encode (if encode? uri-encode (lambda (x) x)))
  (if (string? uri)
      uri
      (let ((fragment (uri-fragment uri))
            (query (uri-query uri))
            (path (uri-path uri))
            (port (uri-port uri))
            (host (uri-host uri))
            (user (uri-user uri)))
        (string-append
         (if (and (not host) (memq (uri-scheme uri) '(http https)))
             ""
             (string-append (symbol->string (uri-scheme uri)) ":"))
         (if (or user host port) "//" "")
         (if user (encode user) "") (if user "@" "")
         (or host "")                   ; host shouldn't need encoding
         (if port ":" "") (if port (number->string port) "")
         (if path (encode path) "")
         (if query "?" "")
         (if (pair? query) (uri-alist->query query) (or query ""))
         (if fragment "#" "") (if fragment (encode fragment) "")))))

;;> Returns true iff the given URI string has a scheme.

(define uri-has-scheme?
  (let ((no-scheme (list 'no-scheme)))
    (lambda (url)
      (not (eq? no-scheme (uri-scheme (string->path-uri no-scheme url)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; query encoding and decoding

(define (uri-safe-char? ch)
  (or (char-alphabetic? ch)
      (char-numeric? ch)
      (case ch
        ((#\- #\_ #\. #\! #\~ #\* #\' #\( #\)) #t)
        (else #f))))

(define (collect str from to res)
  (if (>= from to)
      res
      (cons (substring-cursor str from to) res)))

;;> \procedure{(uri-encode str [plus?])}

;;> Return the URI encoded version of the string \var{str},
;;> using hex escapes as needed and replacing spaces with "+"
;;> iff the optional argument \var{plus?} is true.

(define (uri-encode str . o)
  (define (encode-1-space ch)
    (if (eqv? ch #\space)
        "+"
        (encode-1-normal ch)))
  (define (encode-1-normal ch)
    (let* ((i (char->integer ch))
           (hex (number->string i 16)))
      (if (< i 16)
          (string-append "%0" hex)
          (string-append "%" hex))))
  (let ((start 0)
        (end (string-cursor-end str))
        (encode-1 (if (and (pair? o) (car o))
                      encode-1-space
                      encode-1-normal)))
    (let lp ((from start) (to start) (res '()))
      (if (string-cursor>=? to end)
          (if (zero? from)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (if (uri-safe-char? ch)
                (lp from next res)
                (lp next next (cons (encode-1 ch)
                                    (collect str from to res)))))))))

;;> \procedure{(uri-decode str [plus?])}

;;> Decodes any URI hex escapes in the given string, and
;;> translates any pluses ("+") to space iff the optional
;;> argument \var{plus?} is true.

(define (uri-decode str . o)
  (let ((space-as-plus? (and (pair? o) (car o)))
        (start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp ((from start) (to start) (res '()))
      (if (string-cursor>=? to end)
          (if (zero? from)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (cond
             ((eqv? ch #\%)
              (if (string-cursor>=? next end)
                  (lp next next (collect str from to res))
                  (let ((next2 (string-cursor-next str next)))
                    (if (string-cursor>=? next2 end)
                        (lp next2 next2 (collect str from to res))
                        (let* ((next3 (+ next2 1))
                               (hex (substring-cursor str next next3))
                               (i (string->number hex 16)))
                          (lp next3 next3 (cons (string (integer->char i))
                                                (collect str from to res))))))))
             ((and space-as-plus? (eqv? ch #\+))
              (lp next next (cons " " (collect str from to res))))
             (else
              (lp from next res))))))))

;;> \procedure{(uri-query->alist str [plus?])}

;;> Parses the query part of a URI as a delimited list of
;;> URI encoded \rawcode{VAR=VALUE} pairs, decodes them and
;;> returns the result as an alist.

(define (uri-query->alist str . o)
  (define (split-char? c) (if (eqv? c #\&) #t (eqv? c #\;)))
  (let ((end (string-cursor-end str))
        (plus? (and (pair? o) (car o))))
    (let lp ((i 0) (res '()))
      (if (string-cursor>=? i end)
          (reverse res)
          (let* ((j (string-find str split-char? i))
                 (k (string-find str #\= i j))
                 (cell
                  (if (< k end)
                      (cons (uri-decode (substring-cursor str i k) plus?)
                            (uri-decode (substring-cursor str (+ k 1) j) plus?))
                      (cons (uri-decode (substring-cursor str i j) plus?) #f))))
            (lp (+ j 1) (cons cell res)))))))

;;> \procedure{(uri-alist->query ls [plus?])}

;;> The reverse of the above, formats the alist as a URI
;;> query string.

(define (uri-alist->query ls . o)
  (define plus? (and (pair? o) (car o)))
  (define (encode key val res)
    (let ((res (cons (uri-encode key plus?) res)))
      (if val (cons (uri-encode val plus?) (cons "=" res)) res)))
  (if (null? ls)
      ""
      (let lp ((x (car ls)) (ls (cdr ls)) (res '()))
        (let ((res (encode (car x) (cdr x) res)))
          (if (null? ls)
              (string-concatenate (reverse res))
              (lp (car ls) (cdr ls) (cons "&" res)))))))

;;> Returns a new URI from \var{path}, a string or URI object, as
;;> would be interpreted from as a reference from \var{uri}.  Thus if
;;> any components of \var{path} are missing, or if \var{path} is a
;;> raw path, it is taken relative to \var{uri}.

(define (uri-resolve path uri)
  (or (string->uri path)
      (let ((uri (string->uri uri)))
        (and uri
             (uri-with-path
              (uri-with-fragment (uri-with-query uri #f) #f)
              (path-resolve path
                            (if (string-suffix? (uri-path uri) "/")
                                (uri-path uri)
                                (path-directory (uri-path uri)))))))))

(define-library (chibi optional)
  (export let-optionals let-optionals* opt-lambda
          let-keywords let-keywords* keyword-ref keyword-ref*)
  (cond-expand
   (chibi
    (import (chibi))
    (begin
      (define-syntax symbol->keyword*
        (er-macro-transformer
         (lambda (expr rename compare)
           (if (and (pair? (cdr expr)) (pair? (cadr expr))
                    (compare 'quote (car (cadr expr))))
               `(,(rename 'quote)
                 ,(string->symbol
                   (string-append
                    (symbol->string
                     (identifier->symbol (cadr (cadr expr)))) ":")))
               `(string->symbol
                 (string-append (symbol->string ,(cadr expr)) ":"))))))))
   (else
    (import (scheme base))
    (begin
      (define-syntax let-optionals*
        (syntax-rules ()
          ((let-optionals* opt-ls () . body)
           (begin . body))
          ((let-optionals* (op . args) vars . body)
           (let ((tmp (op . args)))
             (let-optionals* tmp vars . body)))
          ((let-optionals* tmp ((var default) . rest) . body)
           (let ((var (if (pair? tmp) (car tmp) default))
                 (tmp2 (if (pair? tmp) (cdr tmp) '())))
             (let-optionals* tmp2 rest . body)))
          ((let-optionals* tmp tail . body)
           (let ((tail tmp)) . body))))
      (define-syntax symbol->keyword*
        (syntax-rules ()
          ((symbol->keyword* sym)
           (string->symbol (string-append (symbol->string sym) ":")))
          )))))
  (include "optional.scm"))
;; channel.scm -- thread-safe channel (FIFO) library
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Channel
  (%make-channel mutex condvar front rear)
  channel?
  (mutex channel-mutex channel-mutex-set!)
  (condvar channel-condvar channel-condvar-set!)
  (front channel-front channel-front-set!)
  (rear channel-rear channel-rear-set!))

(define (make-channel)
  (%make-channel (make-mutex) (make-condition-variable) '() '()))

(define (channel-empty? chan)
  (null? (channel-front chan)))

(define (channel-send! chan obj)
  (mutex-lock! (channel-mutex chan))
  (let ((new (list obj))
        (rear (channel-rear chan)))
    (channel-rear-set! chan new)
    (cond
     ((pair? rear)
      (set-cdr! rear new))
     (else  ; sending to empty channel
      (channel-front-set! chan new)
      (condition-variable-broadcast! (channel-condvar chan)))))
  (mutex-unlock! (channel-mutex chan)))

(define (channel-receive! chan)
  (mutex-lock! (channel-mutex chan))
  (let ((front (channel-front chan)))
    (cond
     ((null? front)  ; receiving from empty channel
      (mutex-unlock! (channel-mutex chan) (channel-condvar chan))
      (channel-receive! chan))
     (else
      (channel-front-set! chan (cdr front))
      (if (null? (cdr front))
          (channel-rear-set! chan '()))
      (mutex-unlock! (channel-mutex chan))
      (car front)))))

;;> Library for weak data structures.

(define-library (chibi weak)
  (export make-ephemeron ephemeron? ephemeron-broken?
          ephemeron-key ephemeron-value
          ;; make-weak-vector weak-vector? weak-vector-length
          ;; weak-vector-ref weak-vector-set!
          )
  (include-shared "weak"))

(define-library (chibi sxml)
  (export sxml->xml sxml-display-as-html sxml-display-as-text sxml-strip
          html-escape html-tag->string)
  (import (scheme base) (scheme write))
  (include "sxml.scm"))
;; config.scm -- general configuration management
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> This is a library for unified configuration management.
;;> Essentially it provides an abstract collection data type for
;;> looking up named values, two or more of which can be chained
;;> together.  Values from more recent collections can be preferred as
;;> with an environment, or the values at multiple levels can be
;;> flattened together.  Convenience routines are provided from
;;> loading these collections from files while allowing extensions
;;> such as configurations from command-line options.

;;> \section{Background}
;;>
;;> As any application grows to sufficient complexity, it acquires
;;> options and behaviors that one may want to modify at startup or
;;> runtime.  The traditional approach is a combination of
;;> command-line options, config files, environment variables, and/or
;;> other specialized settings.  These all have various pros and cons:
;;>
;;> \table[(@ (border 1) (style border-collapse:collapse) (width "100%"))]{
;;> \tr{\th{name} \th{pros} \th{cons}}
;;> \tr{\td{environment variables}
;;>     \td{implicit - no need to retype; can share between applications}
;;>     \td{unclear when set; unexpected differences between users; limited size}}
;;> \tr{\td{command-line options}
;;>     \td{explicit - visible each time a command is run; }
;;>     \td{verbose; limited size}}
;;> \tr{\td{config files}
;;>     \td{implicit; preserved - can be shared and version controlled}
;;>     \td{requires a parser}}
;;> }
;;>
;;> Environment variables are convenient for broad preferences, used
;;> by many different applications, and unlikely to change per user.
;;> Command-line options are best for settings that are likely to
;;> change between invocations of a program.  Anything else is best
;;> stored in a config file.  If there are settings that multiple
;;> users of a group or whole system are likely to want to share, then
;;> it makes sense to cascade multiple config files.

;;> \section{Syntax}
;;>
;;> With any other language there is a question of config file syntax,
;;> and a few popular choices exist such as .ini syntax.  With Scheme
;;> the obvious choice is sexps, generally as an alist.  We use a
;;> single alist for the whole file, with symbols for keys and
;;> arbitrary sexps for values.  The alists are intended primarily for
;;> editing by hand and need not be dotted, but the interface allows
;;> dotted values.  Disambiguation is handled as with two separate
;;> functions, \scheme{(conf-get config key)} and
;;> \scheme{(conf-get-list config key)}, which both retrieve the value
;;> associated with \var{key} from \var{config}, in the latter case
;;> coercing to a list.  The result is determined according to the
;;> structure of the alist cell as follows:
;;>
;;> \table[(@ (border 1) (style border-collapse:collapse) (width "100%"))]{
;;> \tr{\th{Cell} \th{\scheme{conf-get} result} \th{\scheme{conf-get-list} result}}
;;> \tr{\td{\scheme{(key)}} \td{\scheme{()}} \td{\scheme{()}}}
;;> \tr{\td{\scheme{(key . non-list-value)}} \td{\scheme{non-list-value}} \td{\scheme{(non-list-value)}}}
;;> \tr{\td{\scheme{(key non-list-value)}} \td{\scheme{non-list-value}} \td{\scheme{(non-list-value)}}}
;;> \tr{\td{\scheme{(key (value1 value2 ...))}} \td{\scheme{(value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}}}
;;> \tr{\td{\scheme{(key value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}}}
;;> }
;;>
;;> Thus writing the non-dotted value will always do what you want.
;;> Specifically, the only thing to be careful of is if you want a
;;> single-element list value, even with \scheme{conf-get}, you should
;;> write \scheme{(key (value))}.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Interface}

;;> Returns true iff \var{x} is a config object.

(define-record-type Config
  (make-conf alist parent source timestamp)
  conf?
  (alist conf-alist conf-alist-set!)
  (parent conf-parent conf-parent-set!)
  (source conf-source conf-source-set!)
  (timestamp conf-timestamp conf-timestamp-set!))

(define (assq-tail key alist)
  (let lp ((ls alist))
    (and (pair? ls)
         (if (and (pair? (car ls)) (eq? key (caar ls)))
             ls
             (lp (cdr ls))))))

(define (assq-chain key alist)
  (let ((x (assq-tail (car key) alist)))
    (and x
         (if (null? (cdr key))
             (car x)
             (or (assq-chain (cdr key) (cdar x))
                 (assq-chain key (cdr x)))))))

(define (assq-split key alist)
  (let lp ((ls alist) (rev '()))
    (cond
     ((null? ls) #f)
     ((and (pair? (car ls)) (eq? key (caar ls))) (cons (reverse rev) ls))
     (else (lp (cdr ls) (cons (car ls) rev))))))

(define (read-from-file file . opt)
  (guard (exn (else (and (pair? opt) (car opt))))
    (call-with-input-file file read)))

(define (alist? x)
  (and (list? x) (every pair? x)))

;;> \procedure{(assoc-get alist key [equal? [default]])}

;;> Utility analogous to \scheme{conf-get} on a pure alist.  Returns
;;> the value of the cell in \var{alist} whose car is \var{equal?} to
;;> \var{key}, where the value is determined as the \var{cadr} if the
;;> cell is a proper list of two elements and the \var{cdr} otherwise.
;;> If no cell is found, returns \var{default}, or \scheme{#f} if
;;> unspecified.

(define (assoc-get alist key . o)
  (let ((equal (or (and (pair? o) (car o)) equal?)))
    (let lp ((ls alist))
      (cond
       ((not (pair? ls)) (and (pair? o) (pair? (cdr o)) (cadr o)))
       ((and (pair? (car ls)) (equal key (caar ls)))
        (if (and (pair? (cdar ls)) (null? (cdr (cdar ls))))
            (car (cdar ls))
            (cdar ls)))
       (else (lp (cdr ls)))))))

;;> \procedure{(assoc-get-list alist key [default])}

;;> Equivalent to \scheme{assoc-get} but coerces its result to a list
;;> as described in the syntax section.

(define (assoc-get-list alist key . o)
  (let ((res (assoc-get alist key)))
    (if res
        (if (or (pair? res) (null? res)) res (list res))
        (if (pair? o) (car o) '()))))

;;> Returns just the base of \var{config} without any parent.

(define (conf-head config)
  (make-conf
   (conf-alist config) #f (conf-source config) (conf-timestamp config)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Loading from files.

;;> \procedure{(conf-load file [conf])}

;;> Loads the config file \var{file}, prepending to \var{conf} if
;;> provided.

(define (conf-load file . o)
  (make-conf
   (read-from-file file '())
   (and (pair? o) (car o))
   file
   (current-second)))

;;> Search for and load any files named \var{file} in the
;;> \var{config-path}, which should be a list of strings.

(define (conf-load-in-path config-path file)
  (cond
   ((equal? file "")
    (error "can't load from empty filename" file))
   ((eqv? #\/ (string-ref file 0))
    (conf-load file))
   (else
    (let lp ((ls (reverse config-path)) (res #f))
      (if (null? ls)
          (or res (make-conf '() #f #f (current-second)))
          (let ((path (string-append (car ls) "/" file)))
            (if (file-exists? path)
                (lp (cdr ls) (conf-load path res))
                (lp (cdr ls) res))))))))

;;> \procedure{(conf-load-cascaded config-path file [include-keyword])}

;;> Similar to conf-load-in-path, but also recursively loads any
;;> "include" config files, indicated by a top-level
;;> \var{include-keyword} with either a string or symbol value.
;;> Includes are loaded relative to the current file, and cycles
;;> automatically ignored.

(define (conf-load-cascaded config-path file . o)
  (define (path-directory file)
    (let lp ((i (string-length file)))
      (cond ((zero? i) "./")
            ((eqv? #\/ (string-ref file (- i 1))) (substring file 0 i))
            (else (lp (- i 1))))))
  (define (path-relative file from)
    (if (eqv? #\/ (string-ref file 0))
        file
        (string-append (path-directory from) file)))
  (let ((include-keyword (if (pair? o) (car o) 'include)))
    (let load ((ls (list (cons file (and (pair? o) (pair? (cdr o)) (cadr o)))))
               (seen '())
               (res '()))
      (cond
       ((null? ls)
        res)
       (else
        (let ((file (if (symbol? (caar ls))
                        (symbol->string (caar ls))
                        (caar ls)))
              (depth (cdar ls)))
          (cond
           ((member file seen)
            (load (cdr ls) seen res))
           ((and (number? depth) (<= depth 0))
            (load (cdr ls) seen res))
           (else
            (let* ((config (conf-load-in-path config-path file))
                   (includes (conf-get-list config include-keyword)))
              (load (append (cdr ls)
                            (map (lambda (x)
                                   (cons (path-relative x file)
                                         (and (number? depth) (- depth 1))))
                                 includes))
                    (cons file seen)
                    (append res config)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (conf-get-cell config key)
  (cond
   ((pair? key)
    (cond
     ((null? (cdr key)) (conf-get-cell config (car key)))
     ((assq-chain key (conf-alist config)))
     ((conf-parent config) => (lambda (p) (conf-get-cell p key)))
     (else #f)))
   (else
    (let search ((config config))
      (and config
           (or (assq key (conf-alist config))
               (search (conf-parent config))))))))

;;> \procedure{(conf-get config key [default])}

;;> Basic config lookup - retrieves the value from \var{config}
;;> associated with \var{key}.  If not present, return \var{default}.
;;> In \scheme{conf-get} and related accessors \var{key} can be either
;;> a symbol, or a list of symbols.  In the latter case, each symbol
;;> is used as a key in turn, with the value taken as an alist to
;;> further lookup values in.

(define (conf-get config key . opt)
  (let ((cell (conf-get-cell config key)))
    (if (not cell)
        (and (pair? opt) (car opt))
        (if (and (pair? (cdr cell)) (null? (cddr cell)))
            (cadr cell)
            (cdr cell)))))

;;> \procedure{(conf-get-list config key [default])}

;;> Equivalent to \scheme{conf-get} but coerces its result to a list
;;> as described in the syntax section.

(define (conf-get-list config key . opt)
  (let ((res (conf-get config key)))
    (if res
        (if (or (pair? res) (null? res)) res (list res))
        (if (pair? opt) (car opt) '()))))

;;> Equivalent to \scheme{conf-get} but always returns the
;;> \scheme{cdr} as-is without possibly taking its \scheme{car}.

(define (conf-get-cdr config key . opt)
  (let ((cell (conf-get-cell config key)))
    (if (not cell)
        (and (pair? opt) (car opt))
        (cdr cell))))

;;> Equivalent to \scheme{conf-get-list} but returns a list of all
;;> cascaded configs appended together.

(define (conf-get-multi config key)
  (if (not config)
      '()
      (append (conf-get-list (conf-head config) key)
              (conf-get-multi (conf-parent config) key))))

;;> Extends the config with anadditional alist.

(define (conf-extend config alist . o)
  (let ((source (and (pair? o) (car o))))
    (if (pair? alist)
        (make-conf alist config source (current-second))
        config)))

;;> Joins two configs.

(define (conf-append a b)
  (let ((parent (if (conf-parent a) (conf-append (conf-parent a) b) b)))
    (make-conf (conf-alist a) parent (conf-source a) (conf-timestamp a))))

;;> Utility to create an alist cell representing the chained key
;;> \var{key} mapped to \var{value}.

(define (conf-unfold-key key value)
  (if (null? (cdr key))
      (cons (car key) value)
      (list (car key) (conf-unfold-key (cdr key) value))))

;;> Replace a new definition into the first config alist.

(define (conf-set config key value)
  (make-conf
   (let lp ((key (if (not (list? key)) (list key) key))
            (alist (conf-alist config)))
     (cond
      ((null? (cdr key))
       (cons (cons (car key) value)
             (remove (lambda (x) (and (pair? x) (eq? (car key) (car x))))
                     alist)))
      ((assq-split (car key) alist)
       => (lambda (x)
            (let ((left (car x))
                  (right (cdr x)))
              (append left
                      (cons (cons (car key) (lp (cdr key) (cdar right)))
                            (cdr right))))))
      (else
       (cons (conf-unfold-key key value) alist))))
   (conf-parent config)
   (conf-source config)
   (conf-timestamp config)))

;;> Lift specialized sections to the top-level of a config.

(define (conf-specialize config key name)
  (let lp ((cfg config) (res '()))
    (if (not cfg)
        (make-conf (reverse res) config #f (current-second))
        (let* ((specialized (assq key (conf-alist cfg)))
               (named (and specialized (assq name (cdr specialized))))
               (next (conf-parent cfg)))
          (if named
              (lp next (cons (cdr named) res))
              (lp next res))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Config Verification}

(define (conf-default-warn . args)
  (for-each
   (lambda (a) ((if (string? a) display write) a (current-error-port)))
   args)
  (newline (current-error-port))
  #f)

(define (conf-verify-symbol->predicate sym)
  (case sym
    ((integer) integer?)
    ((number) number?)
    ((list) list?)
    ((alist) alist?)
    ((boolean) boolean?)
    ((char) char?)
    ((string) string?)
    ((symbol) symbol?)
    ((pair) pair?)
    ((filename dirname) string?)
    (else (error "no known conf predicate for" sym))))

;; non-short-circuit versions to report all warnings

(define (and* . args)
  (every (lambda (x) x) args))

(define (every* pred ls)
  (apply and* (map pred ls)))

(define (conf-verify-match def cell warn)
  (define (cell-value)
    (if (and (pair? (cdr cell)) (null? (cddr cell))) (cadr cell) (cdr cell)))
  (define (cell-list)
    (if (and (pair? (cdr cell)) (null? (cddr cell)) (not (pair? (cadr cell))))
        (list (cadr cell))
        (cdr cell)))
  (cond
   ((procedure? def)
    (or (def (cell-value))
        (warn "bad conf value for " (car cell) ": " (cell-value))))
   ((symbol? def)
    (case def
      ((existing-filename)
       (cond
        ((not (string? (cell-value)))
         (warn "bad conf value for " (car cell)
               ": expected a filename but got " (cell-value)))
        ((not (file-exists? (cell-value)))
         (warn "conf setting ~S references a non-existent file: ~S"
               (car cell) (cell-value)))
        (else
         #t)))
      ((existing-dirname)
       (cond
        ((not (string? (cell-value)))
         (warn "bad conf value for " (car cell)
               ": expected a dirname but got " (cell-value)))
        ((not (file-directory? (cell-value)))
         (cond
          ((file-exists? (cell-value))
           (warn "conf setting " (car cell)
                 " expected a directory but found a file: " (cell-value)))
          (else
           (warn "conf setting " (car cell)
                 " references a non-existent directory: " (cell-value)))))
        (else
         #t)))
      ((integer number char string symbol filename dirname boolean pair)
       (or ((conf-verify-symbol->predicate def) (cell-value))
           (warn "bad conf value for " (car cell)
                 ": expected " def " but got " (cell-value))))
      ((list alist)
       (or ((conf-verify-symbol->predicate def) (cell-list))
           (warn "bad conf value for " (car cell)
                 ": expected " def " but got " (cell-list))))
      (else
       (warn "bad conf spec list: " def))))
   ((pair? def)
    (case (car def)
      ((cons)
       (and*
        (conf-verify-match
         (cadr def) (cons `(car ,(car cell)) (car (cell-list))) warn)
        (conf-verify-match
         (car (cddr def)) (cons `(car ,(car cell)) (cdr (cell-list))) warn)))
      ((list)
       (and (list? (cell-list))
            (every* (lambda (x)
                      ;; (cons `(list ,(car cell)) x)
                      (conf-verify-match (cadr def) x warn))
                    (cell-list))))
      ((alist)
       (let ((key-def (cadr def))
             (val-def (if (pair? (cddr def)) (car (cddr def)) (lambda (x) #t))))
         (and (alist? (cell-list))
              (every* (lambda (x)
                        (and (pair? x)
                             (conf-verify-match key-def (car x) warn)
                             (conf-verify-match val-def (cell-value x) warn)))
                      (cell-list)))))
      ((conf)
       (and (alist? (cell-list))
            (conf-verify (cdr def) (list (cell-list)) warn)))
      ((or)
       (or (any (lambda (x) (conf-verify-match x cell (lambda (x) x)))
                (cdr def))
           (warn "bad spec value for " (car cell)
                 ": expected " def " but got " (cell-value))))
      ((member)
       (or (member (cell-value) (cdr def))
           (warn "bad spec value " (cell-value)
                 " for " (car cell) ", expected one of " (cdr def))))
      ((quote)
       (or (equal? (cadr def) (cell-value))
           (warn "bad conf value for " (car cell)
                 ": expected '" (cadr def) " but got " (cell-value))))
      (else
       (warn "bad conf list spec name: " (car def)))))
   (else
    (or (equal? def (cell-value))
        (warn "bad conf value for " (car cell)
              ": expected " def " but got " (cell-value))))))

(define (conf-verify-one spec cell warn)
  (cond
   ((not (pair? cell))
    (warn "bad config entry: " cell))
   ((not (symbol? (car cell)))
    (warn "non-symbol config entry name: " (car cell)))
   (else
    (let ((def (assq (car cell) spec)))
      (cond
       ((not def)
        (warn "unknown config entry: " (car cell)))
       ((null? (cdr def)))
       (else (conf-verify-match (cadr def) cell warn)))))))

(define (conf-verify spec config . o)
  (let ((warn (if (pair? o) (car o) conf-default-warn)))
    (let lp ((config config))
      (cond
       (config
        (for-each
         (lambda (cell) (conf-verify-one spec cell warn))
         (conf-alist config))
        (lp (conf-parent config)))))))

(define-library (chibi system)
  (export get-host-name
          user-information user? user-name user-password
          user-id user-group-id user-gecos user-home user-shell
          group-information group-name group-password group-id
          current-user-id current-group-id
          current-effective-user-id current-effective-group-id
          set-current-user-id! set-current-effective-user-id!
          set-current-group-id! set-current-effective-group-id!
          current-session-id create-session
          set-root-directory!)
  (import (chibi))
  (include-shared "system")
  (body
   (define (user-information user)
     (car (if (string? user)
              (getpwnam_r user (make-string 1024))
              (getpwuid_r user (make-string 1024)))))
   (define (group-information group)
     (car (if (string? group)
              (getgrnam_r group (make-string 1024))
              (getgrgid_r group (make-string 1024)))))))
;; quoted-printable.scm -- RFC2045 implementation
;; Copyright (c) 2005-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> RFC 2045 quoted printable encoding and decoding utilities.  This
;;> API is backwards compatible with the Gauche library
;;> rfc.quoted-printable.

;;> \schemeblock{
;;> (define (mime-encode-header header value charset)
;;>   (let ((prefix (string-append header ": "))
;;>         (str (ces-convert value "UTF8" charset)))
;;>     (string-append
;;>      prefix
;;>      (quoted-printable-encode-header charset str (string-length prefix)))))
;;> }

(define *default-max-col* 76)

;; Allow for RFC1522 quoting for headers by always escaping ? and _
(define (qp-encode bv start-col max-col separator)
  (define (hex i) (+ i (if (<= i 9) 48 55)))
  (let ((end (bytevector-length bv))
        (buf (make-bytevector max-col))
        (out (open-output-bytevector)))
    (let lp ((i 0) (col start-col))
      (cond
       ((= i end)
        (write-bytevector (bytevector-copy buf 0 col) out)
        (get-output-bytevector out))
       ((>= col (- max-col 3))
        (write-bytevector (bytevector-copy buf 0 col) out)
        (lp i 0))
       (else
        (let ((c (bytevector-u8-ref bv i)))
          (cond
           ((and (<= 33 c 126) (not (memq c '(61 63 95))))
            (bytevector-u8-set! buf col c)
            (lp (+ i 1) (+ col 1)))
           (else
            (bytevector-u8-set! buf col (char->integer #\=))
            (bytevector-u8-set! buf (+ col 1) (hex (arithmetic-shift c -4)))
            (bytevector-u8-set! buf (+ col 2) (hex (bitwise-and c #b1111)))
            (lp (+ i 1) (+ col 3))))))))))

;;> Return a quoted-printable encoded representation of the input
;;> according to the official standard as described in RFC2045.
;;>
;;> ? and _ are always encoded for compatibility with RFC1522
;;> encoding, and soft newlines are inserted as necessary to keep each
;;> lines length less than \var{max-col} (default 76).  The starting
;;> column may be overridden with \var{start-col} (default 0).

(define (quoted-printable-encode-string src . o)
  (if (string? src)
      (utf8->string
       (apply quoted-printable-encode-bytevector
              (string->utf8 src)
              o))
      (apply quoted-printable-encode-bytevector src o)))

(define (quoted-printable-encode-bytevector . o)
  (let* ((src (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) '()))
         (start-col (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (max-col (if (pair? o) (car o) *default-max-col*))
         (o (if (pair? o) (cdr o) '()))
         (sep (if (pair? o) (car o) (string->utf8 "=\r\n"))))
    (qp-encode (if (bytevector? src) src (read-bytevector 1000000000 src))
               start-col max-col sep)))

;;> Variation of the above to read and write to ports.

(define (quoted-printable-encode . o)
  (write-string (apply quoted-printable-encode-string o)))

;;> Return a quoted-printable encoded representation of string as
;;> above, wrapped in =?ENC?Q?...?= as per RFC1522, split across
;;> multiple MIME-header lines as needed to keep each lines length
;;> less than \var{max-col}.  The string is encoded as is, and the
;;> encoding \var{enc} is just used for the prefix, i.e. you are
;;> responsible for ensuring \var{str} is already encoded according to
;;> \var{enc}.

(define (quoted-printable-encode-header encoding . o)
  (let* ((src (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) '()))
         (start-col (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (max-col (if (pair? o) (car o) *default-max-col*))
         (o (if (pair? o) (cdr o) '()))
         (nl (if (pair? o) (car o) "\r\n")))
    (let* ((prefix (string-append "=?" encoding "?Q?"))
           (prefix-length (+ 2 (string-length prefix)))
           (separator (string->utf8 (string-append "?=" nl "\t" prefix)))
           (effective-max-col (- max-col prefix-length)))
      (bytevector-append
       (string->utf8 prefix)
       (qp-encode (if (string? src) src (read-string #f src))
                  start-col effective-max-col separator)
       (string->utf8 "?=")))))

;;> Return a quoted-printable decoded representation of \var{str}.  If
;;> \var{mime-header?} is specified and true, _ will be decoded as as
;;> space in accordance with RFC1522.  No errors will be raised on
;;> invalid input.

(define (quoted-printable-decode-string src . o)
  (if (string? src)
      (utf8->string
       (apply quoted-printable-decode-bytevector
              (string->utf8 src)
              o))
      (apply quoted-printable-decode-bytevector src o)))

(define (quoted-printable-decode-bytevector  . o)
  (define (hex? c)
    (or (char<=? #\0 (integer->char c) #\9)
        (char<=? #\A (integer->char c) #\F)))
  (define (unhex1 i)
    (if (>= i 65) (- i 55) (- i 48)))
  (define (unhex c1 c2)
    (+ (arithmetic-shift (unhex1 c1) 4) (unhex1 c2)))
  (let ((src (if (pair? o) (car o) (current-input-port)))
        (mime-header? (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (let* ((bv (if (bytevector? src) src (read-bytevector 1000000000 src)))
           (end (bytevector-length bv))
           (out (open-output-bytevector)))
      (let lp ((i 0))
        (cond
         ((>= i end)
          (get-output-bytevector out))
         (else
          (let ((c (bytevector-u8-ref bv i)))
            (case c
              ((61)                    ; = escapes
               (cond
                ((< (+ i 2) end)
                 (let ((c2 (bytevector-u8-ref bv (+ i 1))))
                   (cond
                    ((eq? c2 10) (lp (+ i 2)))
                    ((eq? c2 13)
                     (lp (if (eq? 10 (bytevector-u8-ref bv (+ i 2)))
                             (+ i 3)
                             (+ i 2))))
                    ((hex? c2)
                     (let ((c3 (bytevector-u8-ref bv (+ i 2))))
                       (if (hex? c3) (write-u8 (unhex c2 c3) out))
                       (lp (+ i 3))))
                    (else (lp (+ i 3))))))))
              ((95)                    ; maybe translate _ to space
               (write-u8 (if mime-header? 32 c) out)
               (lp (+ i 1)))
              ((32 9)          ; strip trailing whitespace
               (let lp2 ((j (+ i 1)))
                 (cond
                  ((not (= j end))
                   (case (bytevector-u8-ref bv j)
                     ((32 9) (lp2 (+ j 1)))
                     ((10)
                      (lp (+ j 1)))
                     ((13)
                      (let ((k (+ j 1)))
                        (lp (if (and (< k end)
                                     (eq? 10 (bytevector-u8-ref bv k)))
                                (+ k 1) k))))
                     (else
                      (write-bytevector (bytevector-copy bv i j) out)
                      (lp j)))))))
              (else                     ; a literal char
               (write-u8 c out)
               (lp (+ i 1)))))))))))

;;> Variation of the above to read and write to ports.

(define (quoted-printable-decode . o)
  (write-string (apply quoted-printable-decode-string o)))
;; reload.scm -- automatic module reloading
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define last-modified-time (current-seconds))

(define reload-verbose? (make-parameter #f))

(define (warn msg . args)
  (let ((err (current-error-port)))
    (display msg err)
    (display ":" err)
    (for-each (lambda (a)
                (display " " err)
                (if (string? a) (display a err) (write a err)))
              args)
    (newline err)))

(define (reload module-name)
  (if (reload-verbose?)
      (warn "Reloading module" module-name))
  (let ((old-module (find-module module-name)))
    ;; Remove old entry in modules list.
    (delete-module! module-name)
    (protect (exn (else (warn "Error loading module definition" module-name)
                        (print-exception exn)
                        (print-stack-trace)
                        (add-module! module-name old-module)))
      (load-module-definition module-name)
      (let ((module (find-module module-name)))
        (cond
         ((not module) (warn "Couldn't find module" module-name))
         (else
          (protect (exn (else (warn "Error loading module" module-name)
                              (print-exception exn)
                              (print-stack-trace)
                              (delete-module! module-name)
                              (add-module! module-name old-module)))
            (let ((env (eval-module module-name module)))
              (%import (module-env module) env (env-exports env) #f)))))))))

(define (file-modified? path)
  (and path (> (file-modification-time path) last-modified-time)))

(define (module-definition-modified? module-name module)
  (file-modified? (find-module-file (module-name->file module-name))))

(define (module-includes-modified? module-name module)
  (let ((dir (module-name-prefix module-name)))
    (any
     (lambda (x)
       (and (pair? x) (memq (car x) '(include include-ci))
            (any file-modified?
                 (map (lambda (f) (find-module-file (string-append dir f)))
                      (cdr x)))))
     (module-meta-data module))))

(define (module-modified? module-name module)
  (or (module-definition-modified? module-name module)
      (module-includes-modified? module-name module)))

(define (reload-modified-modules)
  (for-each
   (lambda (x)
     (if (module-modified? (car x) (cdr x))
         (reload (car x))))
   *modules*)
  (set! last-modified-time (current-seconds)))

(define-library (chibi reload)
  (import (chibi)
          (meta)
          (srfi 39)
          (only (chibi time) current-seconds)
          (only (chibi filesystem) file-modification-time))
  (include "reload.scm")
  (export reload reload-modified-modules reload-verbose?))
;; memoize.scm -- caching and memoization utilities
;; Copyright (c) 2003-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Memory and persistent caching with various levels of control, based
;;> on a combination of lru-cache from Hato and an older memoization
;;> library for Gauche.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; types

(define-record-type Lru-Cache
  (%make-lru-cache table front back size size-limit compute-size)
  lru-cache?
  (table lru-table)
  (front lru-front lru-front-set!)
  (back lru-back lru-back-set!)
  (size lru-size lru-size-set!)
  (size-limit lru-size-limit)
  (compute-size lru-compute-size))

(define-record-type Lru-Entry
  (make-lru-entry key value size prev)
  lru-entry?
  (key lru-entry-key)
  (value lru-entry-value lru-entry-value-set!)
  (size lru-entry-size lru-entry-size-set!)
  (prev lru-entry-prev lru-entry-prev-set!))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; high-level interface

;;> Analagous to the procedure form of \scheme{define} but
;;> automatically memoizes the function.  Uses \scheme{equal?} for
;;> equality comparisons and reasonable defaults - for finer grained
;;> control use \scheme{memoize}.

(define-syntax define-memoized
  (syntax-rules ()
    ((define-memoized (proc x ...) . body)
     (define proc
       (make-memoizer (lambda (x ...) . body) (length '(x ...)) (make-lru-cache))))
    ((define-memoized (proc . x) . body)
     (define proc
       (make-memoizer (lambda x . body) #f (make-lru-cache ))))))

(define (make-memoizer proc arity cache)
  (let ((ref! (if (lru-cache? cache) lru-ref! hash-table-ref!)))
    (case arity
      ((0)
       proc)
      ((1)
       (lambda (x) (ref! cache x proc)))
      ((2)
       (lambda (x y)
         (ref! cache (cons x y) (lambda (xy) (proc (car xy) (cdr xy))))))
      (else
       (lambda args
         (ref! cache args (lambda (args) (apply proc args))))))))

;;> Returns a memoized version of the procedure \var{proc}.  By
;;> default uses a least-recently-used (LRU) cache, which can be tuned
;;> with the following keyword arguments:
;;>
;;> \items[
;;> \item{cache: an explicit pre-existing cache (LRU or hash-table)}
;;> \item{equal: an equality predicate defaulting to \scheme{equal?}}
;;> \item{hash: a hash function to match the equality predicate, defaulting to \scheme{hash} from \scheme{(srfi 69)}}
;;> \item{init-size: a hint for the initial size of the backing hash table}
;;> \item{size-limit: the maximum size of the cache}
;;> \item{compute-size: compute the size of a cache entry}
;;> ]
;;>
;;> \var{compute-size} is a procedure of two arguments, the key and
;;> value to be stored, and defaults to a constant 1 per entry.  After
;;> every insertion the oldest elements will be removed until the size
;;> is under \var{size-limit}.  You may find
;;>
;;>   \scheme{(lambda (k v) (+ (object-size k) (object-size v)))}
;;>
;;> using \scheme{object-size} from \scheme{(chibi ast)} to be a
;;> useful \var{compute-size}.
;;>
;;> If \var{size-limit} is \scheme{#f} then the cache is unlimited,
;;> and a simple hash-table will be used in place of an LRU cache.

(define (memoize proc . o)
  (let-keywords* o
      ((equal equal: equal?)
       (hash hash: hash)
       (arity arity: (and (not (procedure-variadic? proc))
                          (procedure-arity proc)))
       (init-size init-size: 31)
       (limit size-limit: 1000)
       (compute-size compute-size: (lambda (k v) 1))
       (cache-init cache: '()))
    (let ((cache (cond ((lru-cache? cache-init)
                        cache-init)
                       (limit
                        (make-lru-cache 'equal: equal
                                        'hash: hash
                                        'init-size: init-size
                                        'size-limit: limit
                                        'compute-size: compute-size))
                       (else
                        (make-hash-table equal hash)))))
      ;; allow an alist initializer for the cache
      (if (pair? cache-init)
          (for-each (lambda (x) (lru-add! cache (car x) (cdr x)))
                    cache-init))
      (make-memoizer proc arity cache))))

;;> Equivalent to memoize except that the procedure's first argument
;;> must be a pathname.  If the corresponding file has been modified
;;> since the memoized value, the value is recomputed.  Useful to
;;> automatically reflect external changes to a file-backed resource.
;;> The additional keyword argument \scheme{reloader?:}, if true,
;;> indicates that the result of loading is itself a procedure which
;;> should check for updates on each call.

(define (memoize-file-loader proc . o)
  (let* ((f (lambda (file . rest)
              (let ((mtime (file-modification-time file)))
                (cons mtime (apply proc file rest)))))
         (g (apply memoize f o))
         (reloader? (cond ((memq 'reloader?: o) => cdr) (else #f))))
    (lambda (file . rest)
      (let ((cell (apply g file rest)))
        (let-syntax ((update!
                      (syntax-rules ()
                        ((update! default)
                         (let ((mtime (file-modification-time file)))
                           (if (> mtime (car cell))
                               (let ((res (apply proc file rest)))
                                 (set-car! cell mtime)
                                 (set-cdr! cell res)
                                 res)
                               default))))))
          (update! (if (and reloader? (procedure? (cdr cell)))
                       (lambda args (apply (update! (cdr cell)) args))
                       (cdr cell))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; persistent memoization

(define (get-memo-directory proc-name)
  (let ((uid (current-user-id)))
    (if (zero? uid)
        (make-path "/var/run/memo.d" proc-name)
        (make-path (user-home (user-information uid)) ".memo.d" proc-name))))

(define (encode-file-name str)
  (define (file-name-safe-char? ch)
    (or (char-alphabetic? ch) (char-numeric? ch)
        (memv ch '(#\_ #\- #\+ #\. #\,))))
  (define (encode-char ch)
    (let* ((i (char->integer ch))
           (hex (number->string i 16)))
      (if (< i 16)
          (string-append "%0" hex)
          (string-append "%" hex))))
  (define (collect str from to res)
    (if (>= from to)
        res
        (cons (substring-cursor str from to) res)))
  (let ((end (string-cursor-end str)))
    (let lp ((from 0) (to 0) (res '()))
      (if (string-cursor>=? to end)
          (if (zero? from)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (if (file-name-safe-char? ch)
                (lp from next res)
                (lp next next (cons (encode-char ch)
                                    (collect str from to res)))))))))

(define (default-args-encoder args)
  (encode-file-name
   (string-append (call-with-output-string (lambda (out) (write/ss args out)))
                  ".memo")))

;;> Returns a memoized version of the procedure \var{proc} which
;;> stores the memoized results persistently in a file.  Garbage
;;> collection of the files is left as an external task for monitoring
;;> tools or cron jobs.
;;>
;;> Accepts the following keyword arguments:
;;>
;;> \items[
;;> \item{args-encoder: procedure which takes the arguments as a single list, and returns a string representation suitable for use as a (base) file name}
;;> \item{proc-name: the name of the procedure, to use a a subdir of memo-dir to distinguish from other memoized procedures}
;;> \item{memo-dir: the directory to store results in, defaulting to ~/.memo/}
;;> \item{file-validator: validator to run on the existing file - if it returns false, the file is considered bad and the result recomputed}
;;> \item{validator: validator to run on the result of reading the file}
;;> \item{read: the read procedure to extract the result from the file}
;;> \item{write: the write procedure to write the result to the file}
;;> ]

(define (memoize-to-file proc . o)
  (let-keywords* o
      ((args-encoder args-encoder: default-args-encoder)
       (proc-name proc-name: (or (procedure-name proc) "lambda"))
       (memo-dir memo-dir: (get-memo-directory proc-name))
       (file-validator file-validator: (lambda args #t))
       (validator validator: (lambda args #t))
       (read read: read/ss)
       (write write: write/ss))
    (lambda args
      (let ((file (make-path memo-dir (apply args-encoder args))))
        (define (compute)
          (let ((res (apply proc args)))
            (create-directory* (path-directory file))
            (call-with-output-file file
              (lambda (out) (write res out)))
            res))
        (if (and (file-exists? file)
                 (apply file-validator file args))
            (let ((res (call-with-input-file file read)))
              (if (validator res)
                  res
                  (compute)))
            (compute))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; low-level utilities

;;> Creates a new empty LRU object.  The same keyword arguments as in
;;> \scheme{memoize} are available, except of course for \var{cache}.

(define (make-lru-cache . o)
  (let-keywords* o ((equal equal: equal?)
                    (hash hash: hash)
                    (init-size init-size: 31)
                    (compute-size compute-size: (lambda (k v) 1))
                    (size-limit size-limit: 1000))
    (let ((tab (make-hash-table equal hash init-size)))
      (%make-lru-cache tab '() '() 0 size-limit compute-size))))

;; add entry to the back of the queue
(define (lru-enq! lru entry)
  (let ((cell (list entry)))
    (if (null? (lru-front lru))         ; empty
        (lru-front-set! lru cell)
        (set-cdr! (lru-back lru) cell))
    (lru-back-set! lru cell)))

;; pop the front of the queue
(define (lru-deq! lru)
  (let ((cell (lru-front lru)))
    (if (null? cell)
        (error "lru queue is empty")
        (let ((rest (cdr cell)))
          (lru-front-set! lru rest)
          (if (null? rest)
              (lru-back-set! lru '()))
          (car cell)))))

;; shift the given entry, anywhere in the queue, to the end
(define (lru-shift-to-last! lru entry)
  (let ((prev (lru-entry-prev entry))
        (last-pair (lru-back lru)))
    (cond
     ((null? prev)
      ;; first entry, just pop and re-queue it, and update prev pointers
      (lru-enq! lru (lru-deq! lru))
      (lru-entry-prev-set! entry last-pair)
      (lru-entry-prev-set! (car (lru-front lru)) '()))
     ((eq? (cdr prev) last-pair)
      ;; already at the end, nothing to do
      )
     (else
      ;; a middle element, splice it out and re-queue
      (let ((cell (cdr prev)))
        (set-cdr! prev (cdr cell))      ; splice out
        (if (pair? (cdr cell))
            (lru-entry-prev-set! (cadr cell) prev))
        (lru-enq! lru entry)            ; reinsert at end
        (lru-entry-prev-set! entry last-pair))))))

(define (lru-shrink! lru)
  (let ((size-limit (lru-size-limit lru))
        (size (lru-size lru)))
    (if (> size size-limit)
        (let lp ((size size))
          (if (> size size-limit)
              (let ((x (lru-deq! lru)))
                (let ((next (lru-front lru)))
                  (if (pair? next)
                      (lru-entry-prev-set! (car next) '())))
                (hash-table-delete! (lru-table lru) (lru-entry-key x))
                (lp (- size (lru-entry-size x))))
              (lru-size-set! lru size))))))

;;> Looks up \var{key} in the cache LRU.  If not found returns #f,
;;> unless \var{compute} is given in which case \var{compute} is
;;> applied to \var{key} to determine the return value.  This does not
;;> update the cache.

(define (lru-ref lru key . o)
  (let ((entry (hash-table-ref/default (lru-table lru) key #f)))
    (cond (entry
           (lru-shift-to-last! lru entry)
           (lru-entry-value entry))
          ((pair? o)
           ((car o) key))
          (else
           (error "no lru entry for" key)))))

;;> Identical to lru-ref except that it updates the cache on a miss.

(define (lru-ref! lru key compute)
  (cond ((hash-table-ref/default (lru-table lru) key #f)
         => (lambda (entry)
              (lru-shift-to-last! lru entry)
              (lru-entry-value entry)))
        (else
         (let ((value (compute key)))
           (lru-add! lru key value)
           value))))

(define (lru-add! lru key value)
  (let* ((size ((lru-compute-size lru) key value))
         (last-pair (lru-back lru))
         (entry (make-lru-entry key value size last-pair)))
    (hash-table-set! (lru-table lru) key entry)
    (lru-enq! lru entry)
    (lru-size-set! lru (+ size (lru-size lru)))
    (lru-shrink! lru)))

;;> Directly set a value in the cache.

(define (lru-set! lru key value)
  (let ((entry (hash-table-ref/default (lru-table lru) key #f)))
    (cond (entry
           (lru-shift-to-last! lru entry)
           (lru-entry-value-set! entry value)
           (let ((prev-size (lru-entry-size entry))
                 (size ((lru-compute-size lru) key value)))
             (lru-entry-size-set! entry size)
             (lru-size-set! lru (+ (lru-size lru) (- size prev-size)))))
          (else
           (lru-add! lru key value)))
    (lru-shrink! lru)))

(define (hash-table-ref! table key proc)
  (hash-table-ref table key
                  (lambda ()
                    (let ((res (proc key)))
                      (hash-table-set! table key res)
                      res))))

(define-library (chibi doc)
  (import
   (except (chibi) eval) (scheme eval) (srfi 1) (srfi 95)
   (chibi modules) (chibi ast) (chibi io) (chibi match)
   (chibi time) (chibi filesystem) (chibi process)
   (chibi string) (chibi scribble) (chibi sxml) (chibi highlight)
   (chibi type-inference))
  (export procedure-docs print-procedure-docs
          print-module-docs print-module-binding-docs
          generate-docs expand-docs fixup-docs
          extract-module-docs extract-file-docs
          make-default-doc-env make-module-doc-env)
  (include "doc.scm"))

(define-library (chibi io)
  (export read-string read-string! read-line write-line
          port-fold port-fold-right port-map
          port->list port->string-list port->sexp-list
          port->string port->bytevector
          file->string file->bytevector
          file-position set-file-position! seek/set seek/cur seek/end
          make-custom-input-port make-custom-output-port
          make-custom-binary-input-port make-custom-binary-output-port
          make-null-output-port make-null-input-port
          make-broadcast-port make-concatenated-port
          make-generated-input-port make-filtered-output-port
          make-filtered-input-port string-count-chars
          open-input-bytevector open-output-bytevector get-output-bytevector
          string->utf8 utf8->string
          write-string write-u8 read-u8 peek-u8 send-file
          is-a-socket?
          call-with-input-file call-with-output-file)
  (import (chibi) (chibi ast))
  (include-shared "io/io")
  (include "io/io.scm"))

(define-library (chibi mime)
  (export assq-ref mime-header-fold mime-headers->list
          mime-parse-content-type mime-decode-header
          mime-message-fold mime-message->sxml mime-write-headers)
  (import (chibi) (chibi base64) (chibi quoted-printable)
          (chibi string) (chibi io)
          (only (scheme base) bytevector-append write-bytevector))
  (include "mime.scm"))
;; io.scm -- various input/output utilities
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define eof
  (call-with-input-string " "
    (lambda (in) (read-char in) (read-char in))))

;; Copy whole characters from the given cursor positions.
;; Return the src cursor position of the next unwritten char,
;; which may be before `to' if the char would overflow.
;; Now provided as a primitive from (chibi ast).
;; (define (string-cursor-copy! dst start src from to)
;;   (let lp ((i from)
;;            (j (string-offset->index dst start)))
;;     (let ((i2 (string-cursor-next src i)))
;;       (cond ((> i2 to) i)
;;             (else
;;              (string-set! dst j (string-cursor-ref src i))
;;              (lp i2 (+ j 1)))))))

(define (utf8->string vec . o)
  (if (pair? o)
      (let ((start (car o))
            (end (if (pair? (cdr o)) (cadr o) (bytevector-length vec))))
        (utf8->string (subbytes vec start end)))
      (string-copy (utf8->string! vec))))

(define (string->utf8 str . o)
  (if (pair? o)
      (let ((start (car o))
            (end (if (pair? (cdr o)) (cadr o) (string-length str))))
        (string->utf8 (substring str start end)))
      (%string->utf8 str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; reading and writing

;; Display \var{str} to the given output port, defaulting to
;; \scheme{(current-output-port)}, followed by a newline.

(define (write-line str . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (display str out)
    (newline out)))

;;> \procedure{(write-string str [out [start [end]]])}

;;> Writes the characters from \var{start} to \var{end} of string
;;> \var{str} to output port \var{out}, where \var{start} defaults
;;> to 0 and \var{end} defaults to \scheme{(string-length \var{str})}.

(define (write-string str . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (o (if (pair? o) (cdr o) o)))
    (if (pair? o)
        (let ((start (car o))
              (end (if (pair? (cdr o)) (cadr o) (string-length str))))
          (cond-expand
           (string-streams
            (if (zero? start)
                (%write-string str end out)
                (display (substring str start end) out)))
           (else
            (display (substring str start end) out))))
        (display str out))))

;;> \procedure{(read-line [in [n]])}

;;> Read a line from the input port \var{in}, defaulting to
;;> \scheme{(current-input-port)}, and return the result as
;;> a string not including the newline.  Reads at most \var{n}
;;> characters, defaulting to 8192.

(cond-expand
 ((not string-streams)
  (define (%read-line n in)
    (let ((out (open-output-string)))
      (let lp ((i 0))
        (let ((ch (peek-char in)))
          (cond
           ((eof-object? ch)
            (let ((res (get-output-string out)))
              (and (not (equal? res "")) res)))
           ((eqv? ch #\newline)
            (read-char in)
            (get-output-string out))
           ((eqv? ch #\return)
            (read-char in)
            (if (eqv? #\newline (peek-char in))
                (read-char in))
            (get-output-string out))
           ((>= i n)
            (get-output-string out))
           (else
            (write-char (read-char in) out)
            (lp (+ i 1))))))))))

(define (read-line . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (n (if (and (pair? o) (pair? (cdr o))) (car (cdr o)) 8192)))
    (let ((res (%read-line n in)))
      (cond-expand
       (string-streams
        (port-line-set! in (+ 1 (port-line in)))))
      (if (not res)
          eof
          (let ((len (string-length res)))
            (cond
             ((and (> len 0) (eqv? #\newline (string-ref res (- len 1))))
              (if (and (> len 1) (eqv? #\return (string-ref res (- len 2))))
                  (substring res 0 (- len 2))
                  (substring res 0 (- len 1))))
             ((and (> len 0) (eqv? #\return (string-ref res (- len 1))))
              (substring res 0 (- len 1)))
             (else
              res)))))))

;;> \procedure{(read-string n [in])}

;;> Reads \var{n} characters from input-port \var{in},
;;> defaulting to \scheme{(current-input-port)}, and
;;> returns the result as a string.  Returns \scheme{""}
;;> if \var{n} is zero.  May return a string with fewer
;;> than \var{n} characters if the end of file is reached,
;;> or the eof-object if no characters are available.

(cond-expand
 ((not string-streams)
  (define (%read-string n in)
    (let ((out (open-output-string)))
      (let lp ((i 0))
        (cond ((or (= i n) (eof-object? (peek-char in)))
               (list i (get-output-string out)))
              (else (write-char (read-char in) out) (lp (+ i 1)))))))))

(define (read-string n . o)
  (if (zero? n)
      ""
      (let ((in (if (pair? o) (car o) (current-input-port))))
        (let ((res (%read-string n in)))
          (cond
           ((if (pair? res) (= 0 (car res)) #t)
            eof)
           (else
            (port-line-set! in (+ (string-count-chars #\newline (cadr res) 0)
                                  (port-line in)))
            (cadr res)))))))

;;> \procedure{(read-string! str n [in])}

;;> Reads \var{n} characters from port \var{in}, which
;;> defaults to \scheme{(current-input-port)}, and writes
;;> them into the string \var{str} starting at index 0.
;;> Returns the number of characters read.
;;> An error is signalled if the length of \var{str} is smaller
;;> than \var{n}.

(cond-expand
 ((not string-streams)
  (define (%read-string! str n in)
    (let lp ((i 0))
      (cond ((or (= i n) (eof-object? (peek-char in))) i)
            (else (string-set! str i (read-char in)) (lp (+ i 1))))))))

(define (read-string! str n . o)
  (if (> n (string-length str))
      (error "string to small to read chars" str n))
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (res (%read-string! str n in)))
    (port-line-set! in (+ (string-count-chars #\newline str 0 n) (port-line in)))
    res))

;;> Sends the entire contents of a file or input port to an output port.

(define (send-file fd-port-or-filename . o)
  (let* ((in (if (string? fd-port-or-filename)
                 (open-input-file fd-port-or-filename)
                 fd-port-or-filename))
         (out (if (pair? o) (car o) (current-output-port)))
         (fd (if (port? in) (port-fileno in) in))
         (sock (if (port? out) (port-fileno out) out)))
    (define (copy-bytes)
      (let ((b (read-u8 in)))
        (cond ((not (eof-object? b))
               (write-u8 b out)
               (copy-bytes)))))
    (if (and fd sock (is-a-socket? sock))
        (let lp ((start 0))
          (let ((res (%send-file fd sock start)))
            (cond
             ((not res) (copy-bytes))
             ((not (zero? res)) (lp (+ start res))))))
        (copy-bytes))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; higher order port operations

;;> The fundamental port iterator.

(define (port-fold kons knil . o)
  (let ((read (if (pair? o) (car o) read))
        (in (if (and (pair? o) (pair? (cdr o)))
                (car (cdr o))
                (current-input-port))))
    (let lp ((acc knil))
      (let ((x (read in)))
        (if (eof-object? x) acc (lp (kons x acc)))))))

(define (port-fold-right kons knil . o)
  (let ((read (if (pair? o) (car o) read))
        (in (if (and (pair? o) (pair? (cdr o)))
                (car (cdr o))
                (current-input-port))))
    (let lp ()
      (let ((x (read in)))
        (if (eof-object? x) knil (kons x (lp)))))))

(define (port-map fn . o)
  (reverse (apply port-fold (lambda (x ls) (cons (fn x) ls)) '() o)))

(define (port->list read in)
  (port-map (lambda (x) x) read in))

(define (port->sexp-list in)
  (port->list read in))

(define (port->string-list in)
  (port->list read-line in))

(define (port->string in)
  (string-concatenate (port->list (lambda (in) (read-string 1024 in)) in)))

(define (port->bytevector in)
  (let ((out (open-output-bytevector)))
    (do ((c (read-u8 in) (read-u8 in)))
        ((eof-object? c) (get-output-bytevector out))
      (write-u8 c out))))

(define (file->string path)
  (call-with-input-file path port->string))

(define (file->bytevector path)
  (call-with-input-file path port->bytevector))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; custom port utilities

;;> \var{read} is a procedure of three arguments:
;;> \scheme{(lambda (str start end) ...)} which should fill \var{str} from
;;> \var{start} to \var{end} with bytes, returning the actual number
;;> of bytes filled.

(define (make-custom-input-port read . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-input-port read seek close)))

;;> \var{write} is a procedure of three arguments:
;;> \scheme{(lambda (str start end) ...)} which should write the bytes of
;;> \var{str} from \var{start} to \var{end}, returning the actual
;;> number of bytes written.

(define (make-custom-output-port write . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-output-port write seek close)))

;;> Similar to \scheme{make-custom-input-port} but returns a binary
;;> port, and \var{read} receives a bytevector to fill instead of a
;;> string.

(define (make-custom-binary-input-port read . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-binary-input-port read seek close)))

;;> Similar to \scheme{make-custom-output-port} but returns a binary
;;> port, and \var{write} receives data from a bytevector instead of a
;;> string.

(define (make-custom-binary-output-port write . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-binary-output-port write seek close)))

;;> A simple /dev/null port which accepts and does nothing with any
;;> data written to it.

(define (make-null-output-port)
  (make-custom-output-port (lambda (str start end) 0)))

;;> A port to broadcast everything written to it to multiple output
;;> ports.

(define (make-broadcast-port . ports)
  (make-custom-output-port
   (lambda (str start end)
     (let ((str (if (zero? start) str (substring str start)))
           (n (- end start)))
       (for-each (lambda (p) (%write-string str n p)) ports)
       n))))

;;> An output port which runs all output (in arbitrary string chunks)
;;> through the \var{filter} procedure.

(define (make-filtered-output-port filter out)
  (make-custom-output-port
   (lambda (str start end)
     (let* ((len (string-length str))
            (s1 (if (and (zero? start) (= end len)) str (substring str start end)))
            (s2 (filter s1)))
       (if (string? s2)
           (%write-string s2 (string-length s2) out))))))

;;> An input port which acts as all of the \var{ports} concatenated
;;> together in order.

(define (make-concatenated-port . ports)
  (make-custom-input-port
   (lambda (str start end)
     (if (null? ports)
         0
         (let ((str (if (zero? start) str (substring str start)))
               (n (- end start)))
           (let lp ((i (read-string! str n (car ports))))
             (cond
              ((>= i n)
               i)
              (else
               (set! ports (cdr ports))
               (cond
                ((null? ports)
                 i)
                (else
                 (let* ((s (read-string (- n i) (car ports)))
                        (len (if (string? s) (string-length s) 0)))
                   (if (and (string? str) (> len 0))
                       (string-cursor-copy! str i s 0 len))
                   (lp (+ i len)))))))))))))

;;> A /dev/null input port which always returns \scheme{eof-object}.

(define (make-null-input-port)
  (make-concatenated-port))

;;> A utility to represent a port generated in chunks by the thunk
;;> \var{generator}, which should return a single string representing
;;> the next input to buffer, or \scheme{#f} when there is no more
;;> input.

(define (make-generated-input-port generator)
  (let ((buf "")
        (len 0)
        (offset 0))
    (make-custom-input-port
     (lambda (str start end)
       (let ((n (- end start)))
         (cond
          ((>= (- len offset) n)
           ;; buf contains enough to fill str
           (let* ((offset2
                   (string-cursor-copy! str start buf offset (+ offset n)))
                  (end2 (+ (- offset2 offset) start)))
             (set! offset offset2)
             end2))
          (else
           ;; copy the rest of buf into str
           (string-cursor-copy! str start buf offset len)
           ;; i is the position to copy into str, from start to end
           (let lp ((i (+ start (- len offset))))
             (set! buf (generator))
             (cond
              ((not (string? buf))
               (set! buf "")
               (set! len 0)
               (set! offset 0)
               (+ i start))
              (else
               (set! len (string-size buf))
               (cond
                ((>= len (- n i))
                 (let* ((offset2 (string-cursor-copy! str i buf 0 (- n i)))
                        (end2 (+ i offset2)))
                   (set! offset offset2)
                   end2))
                (else
                 (let ((offset2 (string-cursor-copy! str i buf 0 len)))
                   (lp (+ i offset2)))))))))))))))

;;> An input port which runs all input (in arbitrary string chunks)
;;> through the \var{filter} procedure.

(define (make-filtered-input-port filter in)
  (make-generated-input-port
   (lambda ()
     (let ((res (read-string 1024 in)))
       (if (string? res) (filter res) res)))))

(define-library (chibi pathname)
  (export path-strip-directory path-directory
          path-extension path-strip-extension path-replace-extension
          path-absolute? path-relative? path-strip-leading-parents
          path-relative-to path-resolve path-normalize make-path)
  (import (chibi) (chibi string))
  (include "pathname.scm"))

(define-library (chibi string)
  (export
   string-cursor-start string-cursor-end string-cursor-ref
   string-cursor<? string-cursor<=? string-cursor>? string-cursor>=?
   string-cursor=? string-cursor-next string-cursor-prev substring-cursor
   string-null? string-every string-any
   string-join string-split string-count
   string-trim string-trim-left string-trim-right
   string-mismatch string-mismatch-right
   string-prefix? string-suffix?
   string-find string-find-right string-find? string-skip string-skip-right
   string-fold string-fold-right string-map string-for-each
   string-contains make-string-searcher
   string-downcase-ascii string-upcase-ascii)
  (import (chibi) (chibi ast) (chibi char-set base))
  (include "string.scm"))

(define-library (chibi ast)
  (export
   analyze optimize env-cell ast->sexp macroexpand type-of
   Object Input-Port Output-Port Opcode Procedure Bytecode Macro Env
   Number Bignum Flonum Integer Complex Char Boolean
   Symbol String Byte-Vector Vector Pair File-Descriptor
   Context Lam Cnd Set Ref Seq Lit Sc Exception Core
   syntactic-closure? lambda? cnd? set? ref? seq? lit? type? core?
   environment? bytecode? exception? macro? context? file-descriptor?
   syntactic-closure-expr syntactic-closure-env syntactic-closure-vars
   copy-lambda make-lambda make-cnd make-ref make-set make-seq make-lit
   make-macro
   lambda-name lambda-params lambda-body lambda-defs lambda-locals
   lambda-flags lambda-free-vars lambda-set-vars lambda-return-type
   lambda-param-types lambda-source
   lambda-name-set! lambda-params-set! lambda-body-set! lambda-defs-set!
   lambda-locals-set! lambda-flags-set! lambda-free-vars-set!
   lambda-set-vars-set! lambda-return-type-set! lambda-param-types-set!
   lambda-source-set!
   cnd-test cnd-pass cnd-fail
   cnd-test-set! cnd-pass-set! cnd-fail-set!
   set-var set-value set-var-set! set-value-set!
   ref-name ref-cell ref-name-set! ref-cell-set!
   seq-ls seq-ls-set! lit-value lit-value-set!
   exception-kind exception-message exception-irritants exception-source
   opcode-name opcode-num-params opcode-return-type opcode-param-type
   opcode-class opcode-code opcode-data opcode-variadic?
   macro-procedure macro-env macro-source
   procedure-code procedure-vars procedure-name procedure-name-set!
   procedure-arity procedure-variadic?
   bytecode-name bytecode-literals bytecode-source
   port-line port-line-set!
   extend-env env-parent env-parent-set! env-lambda env-lambda-set!
   env-define! env-push! env-syntactic? env-syntactic?-set! core-code
   type-name type-cpl type-parent type-slots type-num-slots type-printer
   object-size integer->immediate gc atomically thread-list abort
   string-contains string-cursor-copy! errno integer->error-string
   flatten-dot update-free-vars! setenv unsetenv safe-setenv)
  (import (chibi))
  (include-shared "ast")
  (include "ast.scm"))

;;> A library for generating SXML docs from Scribble, directly or
;;> extracted from literate docs.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utils

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (string-concatenate-reverse ls)
  (string-concatenate (reverse ls)))

(define (string-strip str . o)
  (let ((bad (if (pair? o) (car o) " \t\n")))
    (call-with-output-string
      (lambda (out)
        (call-with-input-string str
          (lambda (in)
            (let lp ()
              (let ((ch (read-char in)))
                (cond
                 ((not (eof-object? ch))
                  (if (not (string-find? bad ch))
                      (write-char ch out))
                  (lp)))))))))))

(define (string-first-token str sep)
  (let ((len (string-length str)))
    (let lp ((i 0))
      (cond ((= i len) str)
            ((not (string-find? sep (string-ref str i))) (lp (+ i 1)))
            (else
             (let lp ((j (+ i 1)))
               (cond ((= j len) "")
                     ((string-find? sep (string-ref str j)) (lp (+ j 1)))
                     (else
                      (let lp ((k (+ j 1)))
                        (cond
                         ((or (= k len) (string-find? sep (string-ref str k)))
                          (substring str j k))
                         (else
                          (lp (+ k 1)))))))))))))

(define (intersperse ls x)
  (if (or (null? ls) (null? (cdr ls)))
      ls
      (let lp ((ls (cdr ls)) (res (list (car ls))))
        (let ((res (cons (car ls) (cons x res))))
          (if (null? (cdr ls))
              (reverse res)
              (lp (cdr ls) res))))))

(define (normalize-sxml x)
  (cond
   ((pair? x)
    (let lp ((ls x) (res '()))
      (cond ((null? ls)
             (string-concatenate-reverse res))
            ((string? (car ls))
             (lp (cdr ls) (cons (car ls) res)))
            ((pair? res)
             (cons (string-concatenate-reverse res)
                   (cons (car ls) (normalize-sxml (cdr ls)))))
            (else
             (cons (car ls) (normalize-sxml (cdr ls)))))))
   (else x)))

(define (map-sxml proc x)
  (if (pair? x)
      (cons (map-sxml proc (car x))  (map-sxml proc (cdr x)))
      (proc x)))

(define (sxml-body x)
  (cond ((not (and (pair? x) (pair? (cdr x)))) '())
        ((and (pair? (cadr x)) (eq? '@ (car (cadr x)))) (cddr x))
        (else (cdr x))))

(define (sxml->sexp-list x)
  (call-with-input-string (sxml-strip x) port->sexp-list))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Extract the literate Scribble docs for module \var{mod-name} and
;;> print them to \var{out}, rendered with \var{render} which defaults
;;> to \scheme{sxml-display-as-text}.

(define (print-module-docs mod-name . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text)))
    (render
     (generate-docs
      `((title ,(write-to-string mod-name))
        ,@(extract-module-docs mod-name #f))
      (make-module-doc-env mod-name))
     out)))

;;> Extract the literate Scribble docs for just the binding for
;;> \var{var} in module \var{mod-name}, and print them as in
;;> \scheme{print-module-docs}.

(define (print-module-binding-docs mod-name var . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text)))
    (render
     (generate-docs
      (extract-module-docs mod-name #t (list var))
      (make-module-doc-env mod-name))
     out)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Extract the literate Scribble docs for \var{proc} which should be
;;> a procedure and return them as sxml.

(define (procedure-docs proc)
  (let ((mod (and (procedure? proc) (containing-module proc))))
    (and mod
         (generate-docs
          (extract-module-docs (car mod) #t (list (procedure-name proc)))
          (make-module-doc-env (car mod))))))

;;> Extract the literate Scribble docs for \var{proc} which should be
;;> a procedure and render them as in \scheme{print-module-docs}.

(define (print-procedure-docs proc . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text))
        (docs (procedure-docs proc)))
    (if docs (render docs out))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; doc environments

(define (env-ref env name . o)
  (cond ((assq name (car env)) => cdr)
        ((pair? o) (car o))
        (else #f)))

(define (env-set! env name value)
  (cond ((assq name (car env)) => (lambda (cell) (set-cdr! cell value)))
        (else (set-car! env (cons (cons name value) (car env))))))

(define (env-extend env vars vals)
  (list (append (map cons vars vals) (car env))))

;;> Return a new document environment suitable for passing to
;;> \scheme{expand-docs}, with default rules for sections, code
;;> blocks, procedure and macro signatures, etc.

(define (make-default-doc-env)
  `(((title . ,(expand-section 'h1))
     (section . ,(expand-section 'h2))
     (subsection . ,(expand-section 'h3))
     (subsubsection . ,(expand-section 'h4))
     (subsubsubsection . ,(expand-section 'h5))
     (procedure . ,expand-procedure)
     (macro . ,expand-macro)
     (centered . center)
     (smaller . small)
     (larger . large)
     (bold . b)
     (italic . i)
     (emph . em)
     (subscript . sub)
     (superscript . sup)
     (itemlist . ul)
     (item . li)
     (var . code)
     (cfun . code)
     (cmacro . code)
     (ctype . code)
     (url . ,expand-url)
     (hyperlink . ,expand-hyperlink)
     (rawcode . code)
     (code . ,expand-code)
     (codeblock . ,expand-codeblock)
     (ccode
      . ,(lambda (x env)
           (expand-code `(,(car x) language: c ,@(cdr x)) env)))
     (ccodeblock
      . ,(lambda (x env)
           (expand-codeblock `(,(car x) language: c ,@(cdr x)) env)))
     (scheme
      . ,(lambda (x env)
           (expand-code `(,(car x) language: scheme ,@(cdr x)) env)))
     (schemeblock
      . ,(lambda (x env)
           (expand-codeblock `(,(car x) language: scheme ,@(cdr x)) env)))
     (command . ,expand-command)
     (author . ,expand-author)
     (margin-note . ,expand-note)
     (example . ,expand-example)
     (example-import . ,expand-example-import)
     )))

;;> Return a new document environment as in
;;> \scheme{make-default-doc-env}, with an \scheme{example-env}
;;> binding mapped to an environment importing \scheme{(scheme base)}
;;> and the module \var{mod-name}.  This binding is used when
;;> expanding examples in the docs.

(define (make-module-doc-env mod-name)
  (env-extend (make-default-doc-env)
              '(example-env)
              (list (environment '(scheme base)
                                 '(only (chibi) import)
                                 mod-name))))

(define (section-name tag name)
  (string-strip
   (call-with-output-string
     (lambda (out)
       (display tag out)
       (write-char #\_ out)
       (display name out)))))

(define (expand-section tag)
  (lambda (sxml env)
    (if (null? (cdr sxml))
        (error "section must not be empty" sxml)
        (let* ((name (and (eq? 'tag: (cadr sxml))
                          (pair? (cddr sxml))
                          (sxml-strip (car (cddr sxml)))))
               (body (map (lambda (x) (expand-docs x env))
                          (if name (cdr (cddr sxml)) (cdr sxml))))
               (name (or name (sxml-strip (cons tag body)))))
          `(div (a (@ (name . ,(section-name tag name)))) (,tag ,@body))))))

(define (expand-url sxml env)
  (if (not (= 2 (length sxml)))
      (error "url expects one argument" sxml)
      (let ((url (expand-docs (cadr sxml) env)))
        `(a (@ (href . ,url)) ,url))))

(define (expand-hyperlink sxml env)
  (if (not (>= (length sxml) 3))
      (error "hyperlink expects at least two arguments" sxml)
      (let ((url (expand-docs (cadr sxml) env)))
        `(a (@ (href . ,url))
            ,(map (lambda (x) (expand-docs x env)) (cddr sxml))))))

(define (expand-note sxml env)
  `(div (@ (id . "notes"))
        ,@(map (lambda (x) (expand-docs x env)) (cdr sxml))))

(define (expand-author sxml env)
  `(div (@ (id . "notes"))
        ,@(map (lambda (x) (expand-docs x env)) (cdr sxml))
        (br)
        ,(seconds->string (current-seconds))))

(define (expand-code sxml env)
  (let* ((hl (if (and (pair? (cdr sxml)) (eq? 'language: (cadr sxml)))
                 (highlighter-for (car (cddr sxml)))
                 highlight))
         (body (if (and (pair? (cdr sxml)) (eq? 'language: (cadr sxml)))
                   (cdr (cddr sxml))
                   (cdr sxml))))
    `(code ,@(map-sxml (lambda (x) (if (string? x) (hl x) x))
                       (normalize-sxml
                        (map (lambda (x) (expand-docs x env)) body))))))

(define (expand-codeblock sxml env)
  `(pre ,(expand-code sxml env)))

(define (expand-example x env)
  (let ((expr `(begin ,@(sxml->sexp-list x)))
        (example-env (or (env-ref env 'example-env) (current-environment))))
    `(div
      ,(expand-codeblock `(,(car x) language: scheme ,@(cdr x)) env)
      (code
       (div (@ (class . "result"))
            ,(call-with-output-string
               (lambda (out)
                 (protect (exn (#t (print-exception exn out)))
                   (let ((res (eval expr example-env)))
                     (display "=> " out)
                     (write res out))))))))))

(define (expand-example-import x env)
  (eval `(import ,@(cdr x))
        (or (env-ref env 'example-env) (current-environment)))
  "")

(define (expand-command sxml env)
  `(pre (@ (class . "command"))
        (code ,@(map (lambda (x) (expand-docs x env)) (cdr sxml)))))

(define (expand-tagged tag ls env)
  (cons tag (map (lambda (x) (expand-docs x env)) ls)))

;;> Given the sxml document \var{sxml}, expands macros defined in the
;;> document environment \var{env} into standard html tags.

(define (expand-docs sxml env)
  (cond
   ((pair? sxml)
    (cond
     ((symbol? (car sxml))
      (let ((op (env-ref env (car sxml))))
        (cond
         ((procedure? op)
          (op sxml env))
         ((symbol? op)
          (expand-tagged op (cdr sxml) env))
         (else
          (expand-tagged (car sxml) (cdr sxml) env)))))
     (else
      (map (lambda (x) (expand-docs x env)) sxml))))
   (else
    sxml)))

(define (expand-procedure sxml env)
  ((expand-section 'h3) `(,(car sxml) (rawcode ,@(cdr sxml))) env))

(define (expand-macro sxml env)
  (expand-procedure sxml env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; adjustments for html

(define header-index
  (let* ((headers '(h1 h2 h3 h4 h5 h6))
         (len (length headers)))
    (lambda (h) (- len (length (memq h headers))))))

;; return a list of (index . link-to-header) for all headers
(define (extract-contents x)
  (match x
    (('div ('a ('@ ('name . name)) . _)
           ((and h (or 'h1 'h2 'h3 'h4 'h5 'h6)) . section))
     (let* ((raw-text (sxml-strip (cons h section)))
            (text (if (string-prefix? "(" raw-text)
                      (let ((end (string-find
                                  raw-text
                                  (lambda (ch)
                                    (or (char-whitespace? ch)
                                        (eqv? ch #\)))))))
                        (substring raw-text 1 end))
                      raw-text)))
       `((,(header-index h)
          (a (@ (href . ,(string-append "#" name)))
             ,text)))))
    ((a . b)
     (append (extract-contents a) (extract-contents b)))
    (else
     '())))

;; nest the (index . link-to-header)s into ol
(define (get-contents x)
  (if (null? x)
      '()
      (let ((d (caar x)))
        (let lp ((ls (cdr x)) (parent (car (cdar x))) (kids '()) (res '()))
          (define (collect)
            (cons `(li ,parent ,(get-contents (reverse kids))) res))
          ;; take a span of all sub-headers, recurse and repeat on next span
          (cond
           ((null? ls)
            `(ol ,@(reverse (collect))))
           ((> (caar ls) d)
            (lp (cdr ls) parent (cons (car ls) kids) res))
           (else
            (lp (cdr ls) (car (cdar ls)) '() (collect))))))))

(define (fix-header x)
  `(html (head ,@(cond ((assq 'title x) => (lambda (x) (list x)))
                       (else '()))
               "\n"
               (style (@ (type . "text/css"))
                 "
body {color: #000; background-color: #FFF}
div#menu  {font-size: smaller; position: absolute; top: 50px; left: 0; width: 190px; height: 100%}
div#main  {position: absolute; top: 0; left: 200px; width: 540px; height: 100%}
div#notes {position: relative; top: 2em; left: 570px; max-width: 200px; height: 0px; font-size: smaller;}
div#footer {padding-bottom: 50px}
.result { color: #000; background-color: #FFEADF; width: 100%; padding: 3px}
.command { color: #000; background-color: #FFEADF; width: 100%; padding: 5px}
"
                 ,(highlight-style))
               "\n")
         (body
          (div (@ (id . "menu"))
               ,(let ((contents (get-contents (extract-contents x))))
                  (match contents
                    ;; flatten if we have only a single heading
                    (('ol (li y sections ...))
                     sections)
                    (else contents))))
          (div (@ (id . "main"))
               ,@(map (lambda (x)
                        (if (and (pair? x) (eq? 'title (car x)))
                            (cons 'h1 (cdr x))
                            x))
                      x)
               (div (@ (id . "footer")))))))

(define (fix-paragraphs x)
  (let lp ((ls x) (p '()) (res '()))
    (define (collect)
      (if (pair? p) (cons `(p ,@(reverse p)) res) res))
    (define (inline? x)
      (or (string? x)
          (and (pair? x) (symbol? (car x))
               (memq (car x) '(a b i u span code small large sub sup em)))))
    (define (enclosing? x)
      (and (pair? x) (symbol? (car x))
           (memq (car x) '(div body))))
    (cond
     ((null? ls)
      (reverse (collect)))
     ((equal? "\n" (car ls))
      (if (and (pair? p) (equal? "\n" (car p)))
          (let lp2 ((ls (cdr ls)))
            (if (and (pair? ls) (equal? "\n" (car ls)))
                (lp2 (cdr ls))
                (lp ls '() (collect))))
          (lp (cdr ls) (cons (car ls) p) res)))
     ((inline? (car ls))
      (lp (cdr ls) (cons (car ls) p) res))
     ((enclosing? (car ls))
      (lp (cdr ls) '() (cons (car ls) (collect))))
     (else
      (lp (cdr ls) '() (cons (car ls) (collect)))))))

(define (fix-begins x)
  x)

;;> Resolves paragraphs and adds a header to convert \var{sxml} to a
;;> standalone document renderable in html.

(define (fixup-docs sxml)
  (fix-header (fix-paragraphs (fix-begins sxml))))

;;> Composes \scheme{expand-docs} and \scheme{fixup-docs}.

(define (generate-docs sxml . o)
  (let ((env (if (pair? o) (car o) (make-default-doc-env))))
    (fixup-docs (expand-docs sxml env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; extraction

(define (skip-horizontal-whitespace in)
  (cond ((memv (peek-char in) '(#\space #\tab))
         (read-char in)
         (skip-horizontal-whitespace in))))

(define (external-clause? x)
  (not (and (pair? (cdr x)) (pair? (cadr x)) (string? (car (cadr x))))))

(define (contains? tree x)
  (or (eq? tree x)
      (and (pair? tree)
           (or (contains? (car tree) x)
               (contains? (cdr tree) x)))))

(define (form-defined-name form)
  (match form
    (('define (name . x) . y) name)
    (((or 'define 'define-syntax) name . x)
     name)
    (((or 'define-c 'define-c-const)
      t (name . x) . y)
     name)
    (((or 'define-c 'define-c-const)
      t name . x)
     name)
    (else #f)))

;; Try to determine the names of optional parameters checking common
;; patterns.
(define (get-optionals ls body)
  (let lp ((ls ls) (pre '()))
    (cond
     ((pair? ls) (lp (cdr ls) (cons (car ls) pre)))
     ((null? ls) (reverse pre))
     (else
      (let* ((o ls)
             (o? (lambda (x) (eq? x o))))
        (let extract ((x body)
                      (vars '())
                      (i 0))
          (match x
            ((('define x val) . rest)
             (if (contains? val o)
                 (extract #f vars i)
                 (extract rest vars i)))
            ((((or 'let 'let* 'letrec 'letrec*) (y ...) . body))
             (let ((ordered? (memq (car x) '(let* letrec*))))
               (let lp ((ls y) (vars vars) (j i))
                 (cond
                  ((pair? ls)
                   (match (car ls)
                     (((? o?) ('if ('pair? (? o?)) ('cdr (? o?)) default))
                      (lp (cdr ls) vars (+ j 1)))
                     (((? o?) expr)
                      (extract #f vars i))
                     ((v ('if ('pair? (? o?)) ('car (? o?)) default))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     ((v ('and ('pair? (? o?)) ('car (? o?))))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     ((v ('if ('and ('pair? (? o?)) ('pair? ('cdr (? o?))))
                             ('cadr (? o?))
                             default))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     (else
                      (lp (cdr ls) vars j))))
                  (else
                   (extract body vars j))))))
            ((((or 'let-optionals 'let-optionals*) ls ((var default) ...)
               . body))
             (let lp ((ls var) (vars vars) (i i))
               (cond
                ((pair? ls)
                 (lp (cdr ls) (cons (cons (caar ls) i) vars) (+ i 1)))
                (else
                 (extract body vars i)))))
            (else
             (let ((opts (map car (sort vars < cdr)))
                   (dotted? (contains? x o)))
               (append (reverse pre)
                       (cond
                        ((and (pair? opts) dotted?)
                         (list (append opts o)))
                        (dotted?
                         o)
                        (else
                         (list opts)))))))))))))

(define (get-procedure-signature mod id proc)
  (cond ((and (procedure? proc) (procedure-signature id mod))
         => (lambda (sig)
              (list (cons (or id (procedure-name proc)) (cdr sig)))))
        (else '())))

(define (get-value-signature mod id proc name value)
  (match value
    (('(or let let* letrec letrec*) vars body0 ... body)
     (get-value-signature mod id proc name body))
    (('lambda args . body) (list (cons name (get-optionals args body))))
    ((('lambda args body0 ... body) vals ...)
     (get-value-signature mod id proc name body))
    (('begin body0 ... body) (get-value-signature mod id proc name body))
    (else (get-procedure-signature mod id proc))))

;; TODO: analyze and match on AST instead of making assumptions about
;; bindings
(define (get-signature mod id proc source form)
  (match form
    (('define (name args ...) . body)
     (list (cons name args)))
    (('define (name . args) . body)
     (list (cons name (get-optionals args body))))
    (('define name value)
     (get-value-signature mod id proc name value))
    (('define-syntax name ('syntax-rules () (clause . body) ...))
     ;; TODO: smarter summary merging forms
     (map (lambda (x) (cons name (cdr x)))
          (filter external-clause? clause)))
    (else
     (get-procedure-signature mod id proc))))

(define (get-ffi-signatures form)
  (match form
    (('define-c ret-type (or (name _) name) (args ...))
     (list (cons name
                 (map (lambda (x) (if (pair? x) (last x) x))
                      (remove (lambda (x)
                                (and (pair? x)
                                     (memq (car x) '(value result))))
                              args)))))
    (('define-c-const type (or (name _) name))
     (list (list 'const: type name)))
    (((or 'define-c-struct 'define-c-class 'define-c-type) name . rest)
     (let lp ((ls rest) (res '()))
       (cond
        ((null? ls)
         (reverse res))
        ((eq? 'predicate: (car ls))
         (lp (cddr ls) (cons (list (cadr ls) 'obj) res)))
        ((eq? 'constructor: (car ls))
         (lp (cddr ls)
             (cons (if (pair? (cadr ls)) (cadr ls) (list (cadr ls))) res)))
        ((pair? (car ls))
         (lp (cdr ls)
             (append (if (pair? (cddr (cdar ls)))
                         (list (list (car (cddr (cdar ls))) name (caar ls)))
                         '())
                     (list (list (cadr (cdar ls)) name))
                     res)))
        ((symbol? (car ls))
         (lp (cddr ls) res))
        (else
         (lp (cdr ls) res)))))
    (else
     '())))

(define section-number
  (let ((sections '(section subsection subsubsection subsubsubsection)))
    (lambda (x)
      (cond ((memq x sections) => length)
            ((memq x '(procedure macro)) (section-number 'subsection))
            (else 0)))))

(define (section>=? x n)
  (and (pair? x)
       (if (memq (car x) '(div))
           (find (lambda (y) (section>=? y n)) (sxml-body x))
           (>= (section-number (car x)) n))))

(define (extract-sxml tag x)
  (and (pair? x)
       (cond ((if (pair? tag) (memq (car x) tag) (eq? tag (car x))) x)
             ((memq (car x) '(div))
              (any (lambda (y) (extract-sxml tag y)) (sxml-body x)))
             (else #f))))

(define (section-describes? x name)
  (let ((name (symbol->string name)))
    (and (pair? x) (pair? (cdr x))
         (let* ((str (sxml-strip (cadr x)))
                (op (string-first-token str " \t\r\n()#")))
           (or (string=? op name)
               ;; FIXME: hack for loop iterators
               (and (string=? op "for")
                    (string-contains str (string-append "(" name " "))))))))

;; write a signature handling a trailing list as [optional] parameters
(define (write-signature sig)
  (if (and (list? sig)
           (> (length sig) 1)
           (pair? (last sig))
           (not (any pair? (drop-right sig 1))))
      (call-with-output-string
        (lambda (out)
          (display "(" out)
          (write (car sig) out)
          (let lp ((ls (cdr sig)))
            (cond
             ((pair? (car ls))
              (display " [" out)
              (write (caar ls) out)
              (let lp ((ls (cdar ls)))
                (cond
                 ((pair? ls)
                  (display " " out)
                  (write (car ls) out)
                  (lp (cdr ls)))
                 ((not (null? ls))
                  (display " . " out)
                  (write ls out))))
              (display "])" out))
             (else
              (display " " out)
              (write (car ls) out)
              (lp (cdr ls)))))))
      (write-to-string sig)))

(define (insert-signature orig-ls name sig)
  (cond
   ((not (pair? sig))
    orig-ls)
   (else
    (let ((name
           (cond
            (name)
            ((not (pair? (car sig))) (car sig))
            ((eq? 'const: (caar sig)) (cadr (cdar sig)))
            (else (caar sig)))))
      (let lp ((ls orig-ls) (rev-pre '()))
        (cond
         ((or (null? ls)
              (section>=? (car ls) (section-number 'subsection)))
          `(,@(reverse rev-pre)
            ,@(if (and (pair? ls)
                       (section-describes?
                        (extract-sxml '(subsection procedure macro)
                                      (car ls))
                        name))
                  '()
                  `((subsection
                     tag: ,(write-to-string name)
                     (rawcode
                      ,@(if (and (pair? (car sig)) (eq? 'const: (caar sig)))
                            `((i ,(write-to-string (car (cdar sig))) ": ")
                              ,(write-to-string (cadr (cdar sig))))
                            (intersperse (map write-signature sig) '(br)))))))
            ,@ls))
         (else
          (lp (cdr ls) (cons (car ls) rev-pre)))))))))

;;> Extract inline Scribble documentation (with the ;;> prefix) from
;;> the source file \var{file}, associating any signatures from the
;;> provided defs when available and not overridden in the docs.

(define (extract-file-docs mod file all-defs strict? . o)
  ;; extract (<file> . <line>) macro source or
  ;; (<offset> <file . <line>>) procedure source
  (define (source-line source)
    (and (pair? source)
         (if (string? (car source))
             (and (equal? file (car source))
                  (number? (cdr source))
                  (cdr source))
             (and (number? (car source))
                  (pair? (cdr source))
                  (equal? file (cadr source))
                  (cddr source)))))
  (define (read-to-paren in)
    (let lp1 ((res '()))
      (let ((ch (peek-char in)))
        (cond
         ((or (eof-object? ch) (eqv? #\) ch)) (read-char in) (reverse res))
         ((char-whitespace? ch) (read-char in) (lp1 res))
         ((eq? ch #\;)
          (let lp2 ()
            (let ((ch2 (read-char in)))
              (if (or (eof-object? ch2) (eqv? #\newline ch2))
                  (lp1 res)
                  (lp2)))))
         ;; TODO: support #; and #| comments at end of list
         (else (lp1 (cons (read in) res)))))))
  (call-with-input-file file
    (lambda (in)
      (let* ((lang (or (and (pair? o) (car o)) 'scheme))
             ;; filter to only defs found in this file
             (defs (filter-map
                    (lambda (x)
                      (let ((line (source-line (third x))))
                        (and line 
                             ;; (name value line)
                             `(,(car x) ,(cadr x) ,line))))
                    all-defs)))
        (let lp ((lines '())
                 (cur '())
                 (res '())
                 (ids '())
                 (depth 0)
                 (last-line 0))
          (define (collect)
            (if (pair? lines)
                (append
                 (reverse
                  (call-with-input-string
                      (string-concatenate (reverse lines) "\n")
                    scribble-parse))
                 cur)
                cur))
          (define (get-ids sxml)
            (match sxml
              (((or 'procedure 'macro) str)
               (list
                (string->symbol
                 (string-trim (car (string-split str))
                              (lambda (ch) (or (eq? ch #\() (eq? ch #\))))))))
              ((x ...) (append-map get-ids x))
              (else '())))
          (skip-horizontal-whitespace in)
          (cond
           ((eof-object? (peek-char in))
            (append (collect) res))
           ((eqv? #\newline (peek-char in))
            (read-char in)
            (lp lines cur res ids depth last-line))
           ((eqv? #\; (peek-char in))
            (read-char in)
            (cond
             ((and (eqv? #\; (peek-char in))
                   (begin (read-char in) (eqv? #\> (peek-char in))))
              (read-char in)
              (if (eqv? #\space (peek-char in)) (read-char in))
              (lp (cons (read-line in) lines) cur res ids depth last-line))
             (else
              (let lp ()
                (cond ((eqv? #\; (peek-char in))
                       (read-char in)
                       (lp))))
              (let* ((line (read-line in))
                     (cur (collect))
                     (ids (append (get-ids cur) ids)))
                ;; ";;/" attaches the docs to the preceding form
                ;; rather than the next
                (cond
                 ((equal? line "/")
                  (lp '() '() (append cur res) ids depth last-line))
                 (else
                  (cond
                   ((and (not (equal? line ""))
                         (eqv? #\/ (string-ref line 0)))
                    (display "WARNING: ;;/ line should be empty"
                             (current-error-port))
                    (write line (current-error-port))
                    (newline (current-error-port))))
                  (lp '() cur res ids depth last-line)))))))
           ((eqv? #\) (peek-char in))
            (read-char in)
            (if (zero? depth)
                (error "unexpected ) at line" last-line)
                (lp lines cur res ids (- depth 1) last-line)))
           ((not (eqv? #\( (peek-char in)))
            ;; ignore non-list top-level expression
            (read in)
            (lp lines cur res ids depth (port-line in)))
           (else  ;; found a top-level expression
            (read-char in)
            (let ((op (read in)))
              (case op
                ((begin define-library)
                 ;; allowed nested docs in these forms
                 (lp lines cur res ids (+ depth 1) (port-line in)))
                (else
                 ;; read until closing paren
                 (let* ((cur (collect))
                        (ids (append (get-ids cur) ids))
                        (form (cons op (read-to-paren in)))
                        (id (form-defined-name form))
                        (line (port-line in))
                        ;; find all procedures defined by form
                        (procs2 (filter (lambda (x) (<= last-line (third x) line))
                                        (filter third defs)))
                        (procs (if (= 2 (length procs2))
                                   (cdr procs2)
                                   procs2))
                        ;; the the signature for the form
                        (sigs
                         (cond
                          ((eq? lang 'ffi)
                           (filter
                            (lambda (x)
                              (assq (if (eq? 'const: (car x)) (third x) (car x))
                                    all-defs))
                            (get-ffi-signatures form)))
                          ((= 1 (length procs))
                           (get-signature
                            mod id (caar procs) (cdar procs) form))
                          (else
                           (get-signature
                            mod id (and id (module-ref mod id)) #f form)))))
                   (cond
                    ((and strict?
                          (or (not (pair? sigs)) (not (assq (caar sigs) defs))))
                     ;; drop unrelated docs in strict mode
                     (lp '() '() res ids depth line))
                    ((and (eq? lang 'ffi) (pair? sigs))
                     (lp '() '() (append (insert-signature cur #f sigs) res)
                         ids depth line))
                    ((and (memq lang '(scheme module)) (= 1 (length procs)))
                     (lp '() '()
                         (append (insert-signature cur (caar procs) sigs) res)
                         ids depth line))
                    ((and (null? procs)
                          (and (not (memq id ids)) (assq id all-defs)))
                     (let ((sigs (if (and (null? sigs) id)
                                     (list id)
                                     sigs)))
                       (lp '() '() (append (insert-signature cur #f sigs) res)
                           ids depth line)))
                    (else
                     (lp '() '() (append cur res) ids depth line))))))))))))))

;; utility to get the source position of an object
(define (object-source x)
  (cond ((opcode? x) #f)
        ((bytecode? x)
         (let ((src (bytecode-source x)))
           (if (and (vector? src) (positive? (vector-length src)))
               (vector-ref src 0)
               src)))
        ((procedure? x) (object-source (procedure-code x)))
        ((macro? x) (macro-source x))
        (else #f)))

;;> Extract the literate Scribble docs from module \var{mod-name} and
;;> return them as sxml.  If \var{strict?} is true ignore docs for
;;> unexported values, defined by the optional \var{exports} which
;;> defaults to all the module exports.

(define (extract-module-docs mod-name strict? . o)
  (let ((mod (load-module mod-name)))
    (if (not mod)
        (error "couldn't find module" mod-name)
        (let* ((exports (if (pair? o) (car o) (module-exports mod)))
               (defs
                 (map (lambda (x)
                        (let ((val (module-ref mod x)))
                          `(,x ,val ,(object-source val))))
                      exports)))
          (append
           (cond
            ((find-module-file (module-name->file mod-name))
             => (lambda (f)
                  (reverse (extract-file-docs mod f defs strict? 'module))))
            (else '()))
           (reverse
            (append-map (lambda (x)
                          (extract-file-docs mod x defs strict? 'module))
                        (module-include-library-declarations mod)))
           (reverse
            (append-map (lambda (x) (extract-file-docs mod x defs strict?))
                        (module-includes mod)))
           (reverse
            (append-map (lambda (x) (extract-file-docs mod x defs strict? 'ffi))
                        (module-shared-includes mod))))))))
;; mime.scm -- RFC2045 MIME library
;; Copyright (c) 2005-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library to parse MIME headers and bodies into SXML.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define mime-line-length-limit 4096)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; association lists

;;> \procedure{(assq-ref ls key [default])}
;;> Returns the \scheme{cdr} of the cell in \var{ls} whose
;;> \scheme{car} is \scheme{eq?} to \var{key}, or \var{default}
;;> if not found.  Useful for retrieving values associated with
;;> MIME headers.

(define (assq-ref ls key . o)
  (cond ((assq key ls) => cdr) (else (and (pair? o) (car o)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple matching instead of regexps

(define (match-mbox-from-line line)
  (let ((len (string-length line)))
    (and (> len 5)
         (string=? (substring line 0 5) "From ")
         (let lp ((i 6))
           (cond
             ((= i len) (list (substring line 5 len) ""))
             ((memq (string-ref line i) '(#\space #\tab))
              (list (substring line 5 i) (substring line (+ i 1) len)))
             (else (lp (+ i 1))))))))

(define (string-scan-colon-or-maybe-equal str)
  (let ((len (string-length str)))
    (let lp ((i 0) (best #f))
      (if (= i len)
          best
          (let ((c (string-ref str i)))
            (cond ((or (char-alphabetic? c)
                       (char-numeric? c)
                       (memv c '(#\- #\_)))
                   (lp (+ i 1) best))
                  ((eq? c #\:)
                   (if (= i 0) #f i))
                  ((eqv? c #\=)
                   (lp (+ i 1) (or best i)))
                  (else
                   best)))))))

(define (string-skip-white-space str i)
  (let ((lim (string-length str)))
    (let lp ((i i))
      (cond ((>= i lim) lim)
            ((char-whitespace? (string-ref str i)) (lp (+ i 1)))
            (else i)))))

(define (match-mime-header-line line)
  (let ((i (string-scan-colon-or-maybe-equal line)))
    (and i
         (let ((j (string-skip-white-space line (+ i 1))))
           (list (string->symbol (string-downcase-ascii (substring line 0 i)))
                 (substring line j (string-length line)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dummy encoder

(define (ces-convert bv . o)
  (let ((enc (if (pair? o) (car o) "utf8")))
    ;; TODO: add conversion routines for non-utf8 encodings
    (utf8->string bv)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;> \section{RFC2822 Headers}

;;> \procedure{(mime-header-fold kons knil [source [limit [kons-from]]])}
;;>
;;> Performs a fold operation on the MIME headers of source which can be
;;> either a string or port, and defaults to current-input-port.  \var{kons}
;;> is called on the three values:
;;>    \scheme{(kons header value accumulator)}
;;> where accumulator begins with \var{knil}.  Neither the header nor the
;;> value are modified, except wrapped lines are handled for the value.
;;>
;;> The optional procedure \var{kons-from} is a procedure to be called when
;;> the first line of the headers is an "From <address> <date>" line, to
;;> enable this procedure to be used as-is on mbox files and the like.
;;> It defaults to \var{kons}, and if such a line is found the fold will begin
;;> with \scheme{(kons-from '%from <address> (kons-from '%date <date> knil))}.
;;>
;;> The optional \var{limit} gives a limit on the number of headers to read.

(define (mime-header-fold kons knil . o)
  (let ((src (and (pair? o) (car o)))
        (limit (and (pair? o) (pair? (cdr o)) (car (cdr o))))
        (kons-from (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o))) (car (cddr o)) kons)))
    ((if (string? src) mime-header-fold-string mime-header-fold-port)
     kons knil (or src (current-input-port)) limit kons-from)))

(define (mime-header-fold-string kons knil str limit kons-from)
  (call-with-input-string str
    (lambda (in) (mime-header-fold-port kons knil in limit kons-from))))

(define (mime-header-fold-port kons knil port limit kons-from)
  (define (out line acc count)
    (cond
     ((or (and limit (> count limit)) (eof-object? line) (string=? line ""))
      acc)
     ((match-mime-header-line line)
      => (lambda (m) (in (car m) (list (cadr m)) acc (+ count 1))))
     (else
      ;;(warn "invalid header line: ~S\n" line)
      (out (read-line port mime-line-length-limit) acc (+ count 1)))))
  (define (in header value acc count)
    (let ((line (read-line port mime-line-length-limit)))
      (cond
       ((and limit (> count limit))
        acc)
       ((or (eof-object? line) (string=? line ""))
        (kons header (string-join (reverse value)) acc))
       ((char-whitespace? (string-ref line 0))
        (in header (cons line value) acc (+ count 1)))
       (else
        (out line
             (kons header (string-join (reverse value)) acc)
             (+ count 1))))))
  (let ((first-line (read-line port mime-line-length-limit)))
    (cond
     ((eof-object? first-line)
      knil)
     ((and kons-from (match-mbox-from-line first-line))
      => (lambda (m) ; special case check on first line for mbox files
           (out (read-line port mime-line-length-limit)
                (kons-from '%from (car m)
                           (kons-from '%date (cadr m) knil))
                0)))
     (else
      (out first-line knil 0)))))

;;> \procedure{(mime-headers->list [source])}
;;> Return an alist of the MIME headers from source with headers all
;;> downcased.

(define (mime-headers->list . o)
  (reverse
   (apply
    mime-header-fold
    (lambda (h v acc) (cons (cons h v) acc))
    '()
    o)))

(define (mime-split-name+value s)
  (let ((i (string-find s #\=)))
    (if i
        (cons (string->symbol
               (string-downcase-ascii (string-trim (substring s 0 i))))
              (if (= i (string-length s))
                  ""
                  (if (eqv? #\" (string-ref s (+ i 1)))
                      (substring s (+ i 2) (- (string-length s) 1))
                      (substring s (+ i 1) (string-length s)))))
        (cons (string->symbol (string-downcase-ascii (string-trim s))) ""))))

;;> \procedure{(mime-parse-content-type str)}
;;> Parses \var{str} as a Content-Type style-value returning the list
;;> \scheme{(type (attr . val) ...)}.

;;> \example{
;;> (mime-parse-content-type "text/html; CHARSET=UTF-8; filename=index.html")
;;> }

(define (mime-parse-content-type str)
  (let ((res (map mime-split-name+value
                  (string-split str (lambda (ch)
                                      (or (eqv? ch #\;) (eqv? ch #\,)))))))
    (if (and (pair? res) (pair? (car res)) (equal? "" (cdar res)))
        (cons (caar res) (cdr res))
        res)))

;;> \procedure{(mime-decode-header str)}
;;> Replace all occurrences of RFC1522 =?ENC?...?= escapes in \var{str} with
;;> the appropriate decoded and charset converted value.

(define (mime-decode-header str)
  (let* ((len (string-length str))
         (limit (- len 8))) ; need at least 8 chars: "=?Q?X??="
    (let lp ((i 0) (from 0) (res '()))
      (if (>= i limit)
        (string-join (reverse (cons (substring str from len) res)))
        (if (and (eqv? #\= (string-ref str i))
                 (eqv? #\? (string-ref str (+ i 1))))
          (let* ((j (string-find str #\? (+ i 3)))
                 (k (string-find str #\? (+ j 3))))
            (if (and j k (< (+ k 1) len)
                     (eqv? #\? (string-ref str (+ j 2)))
                     (memq (string-ref str (+ j 1)) '(#\Q #\B #\q #\b))
                     (eqv? #\= (string-ref str (+ k 1))))
              (let ((decode (if (memq (string-ref str (+ j 1)) '(#\Q #\q))
                               quoted-printable-decode-string
                               base64-decode-string))
                    (cset (substring str (+ i 2) j))
                    (content (substring str (+ j 3) k))
                    (k2 (+ k 2)))
                (lp k2 k2 (cons (ces-convert (decode content) cset)
                                (cons (substring str from i) res))))
              (lp (+ i 2) from res)))
          (lp (+ i 1) from res))))))

;;> Write out an alist of headers in mime format.

(define (mime-write-headers headers out)
  (for-each
   (lambda (h)
     (display (car h) out) (display ": " out)
     (display (cdr h) out) (display "\r\n" out))
   headers))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; message parsing

(define (read-line/binary in)
  (let ((out (open-output-bytevector)))
    (let lp ()
      (let ((ch (read-u8 in)))
        (cond ((eof-object? ch)
               (let ((res (get-output-bytevector out)))
                 (if (zero? (bytevector-length res))
                     ch
                     res)))
              ((eqv? ch 10)
               (get-output-bytevector out))
              (else
               (write-u8 ch out)
               (lp)))))))

(define (bv-length-before-cr bv)
  (let ((len (bytevector-length bv)))
    (if (and (> len 0) (= 13 (bytevector-u8-ref bv (- len 1))))
        (- len 1)
        len)))

(define (mime-read-to-boundary/binary port boundary next final)
  (let* ((boundary (if (string? boundary) (string->utf8 boundary) boundary))
         (boundary-cr (and boundary (bytevector-append boundary #u8(13))))
         (final-boundary
          (and boundary (bytevector-append boundary #u8(45 45))))
         (final-boundary-cr
          (and final-boundary (bytevector-append final-boundary #u8(13))))
         (out (open-output-bytevector)))
    (let lp ((prev #f))
      (let ((line (read-line/binary port)))
        (cond
         ((or (eof-object? line)
              (equal? line final-boundary)
              (equal? line final-boundary-cr))
          (if prev
              (write-bytevector prev out 0 (bv-length-before-cr prev)))
          (final (get-output-bytevector out)))
         ((or (equal? line boundary) (equal? line boundary-cr))
          (if prev
              (write-bytevector prev out 0 (bv-length-before-cr prev)))
          (next (get-output-bytevector out)))
         (else
          (cond (prev
                 (write-bytevector prev out)
                 (write-u8 10 out)))
          (lp line)))))))

(define (mime-read-to-boundary/text port boundary next final)
  (let ((final-boundary (and boundary (string-append boundary "--"))))
    (let lp ((res '()))
      (let ((line (read-line port mime-line-length-limit)))
        (cond
         ((or (eof-object? line) (equal? line final-boundary))
          (final (string-join (reverse res)
                              (call-with-output-string newline))))
         ((equal? line boundary)
          (next (string-join (reverse res)
                             (call-with-output-string newline))))
         (else
          (lp (cons line res))))))))

(define (mime-read-to-boundary port boundary next final)
  ((if (binary-port? port)
       mime-read-to-boundary/binary
       mime-read-to-boundary/text)
   port boundary next final))

(define (mime-convert-part part text? cte enc)
  (let ((res (cond
              ((and (string? cte) (string-ci=? cte "quoted-printable"))
               (if text?
                   (quoted-printable-decode-string part)
                   (quoted-printable-decode-bytevector
                    (if (string? part) (string->utf8 part) part))))
              ((and (string? cte) (string-ci=? cte "base64"))
               (if text?
                   (base64-decode-string part)
                   (base64-decode-bytevector
                    (if (string? part) (string->utf8 part) part))))
              ((and (not text?) (string? part))
               (string->utf8 part))
              (else
               part))))
    (cond
     ((and text? (bytevector? res)) (ces-convert res enc))
     (else res))))

(define (mime-read-part port type cte enc boundary next final)
  (let ((text? (and (symbol? type)
                    (string-prefix? "text/" (symbol->string type)))))
    (mime-read-to-boundary
     port boundary
     (lambda (x) (next (mime-convert-part x text? cte enc)))
     (lambda (x) (final (mime-convert-part x text? cte enc))))))

;;> \section{RFC2045 MIME Encoding}

;;> \procedure{(mime-message-fold src kons knil [down up headers])}
;;> Performs a tree fold operation on the given string or port
;;> \var{src} as a MIME body corresponding to the headers give in
;;> \var{headers}.  If \var{headers} are false or not provided they
;;> are first read from \var{src}.
;;>
;;> \var{kons} is called on the successive values:
;;>
;;> \schemeblock{(kons parent-headers part-headers part-body accumulator)}
;;>
;;> where \var{part-headers} are the headers for the given MIME part (the
;;> original headers for single-part MIME), \var{part-body} is the
;;> appropriately decoded and charset-converted body of the message,
;;> and the \var{accumulator} begins with \var{knil}.
;;>
;;> If a multipart body is found, then a tree fold is performed,
;;> calling \var{down} once to get a new accumulator to pass to
;;> \var{kons}, and \var{up} on the result when returning.  Their
;;> signatures are:
;;>
;;> \schemeblock{(down headers seed)}
;;> \schemeblock{(up headers parent-seed seed)}
;;>
;;> The default \var{down} simply returns null, and the default
;;> \var{up} wraps the seed in the following sxml:
;;>
;;> \schemeblock{
;;>  ((mime (@ headers ...)
;;>     seed ...)
;;>   parent-seed ...)
;;> }

(define (mime-message-fold src kons init-seed . o)
  (let ((port (if (string? src) (open-input-string src) src)))
    (let ((kons-down
           (or (and (pair? o) (car o)) (lambda (headers seed) '())))
          (kons-up
           (or (and (pair? o) (pair? (cdr o)) (car (cdr o)))
               (lambda (headers parent-seed seed)
                 `((mime (@ ,@headers)
                         ,@(if (pair? seed) (reverse seed) seed))
                   ,@parent-seed))))
          (headers
           (or (and (pair? o) (pair? (cdr o)) (pair? (cdr (cdr o)))
                    (car (cdr (cdr o))))
               (mime-headers->list port))))
      (let tfold ((parent-headers '())
                  (headers headers)
                  (seed init-seed)
                  (boundary #f)
                  (next (lambda (x) x))
                  (final (lambda (x) x)))
        (let* ((ctype (mime-parse-content-type
                       (assq-ref headers 'content-type "text/plain")))
               (type (car ctype))
               (enc (string-trim
                     (or (assq-ref ctype 'charset)
                         (assq-ref headers 'charset "ascii"))))
               (cte (string-trim
                     (or (assq-ref headers 'content-transfer-encoding)
                         (assq-ref headers 'encoding "7-bit")))))
          (cond
           ((and (symbol? type)
                 (string-prefix? "multipart/" (symbol->string type))
                 (assq-ref (cdr ctype) 'boundary))
            => (lambda (boundary2)
                 (let ((boundary2 (string-append "--" boundary2)))
                   ;; skip preamble
                   (mime-read-to-boundary port boundary2 (lambda (x) x) (lambda (x) x))
                   (let lp ((part-seed (kons-down headers seed)))
                     (let ((part-headers (mime-headers->list port)))
                       (flush-output (current-error-port))
                       (tfold headers part-headers
                              part-seed boundary2
                              lp
                              (lambda (x)
                                ;; skip epilogue
                                (if boundary
                                    (mime-read-to-boundary
                                     port boundary
                                     (lambda (x) x) (lambda (x) x)))
                                (next (kons-up headers seed x)))))))))
           (else
            (mime-read-part
             port type cte enc boundary
             (lambda (x) (next (kons parent-headers headers x seed)))
             (lambda (x) (final (kons parent-headers headers x seed)))))))))))

;;> \procedure{(mime-message->sxml [src [headers]])}
;;> 
;;> Parse the given source as a MIME message and return
;;> the result as an SXML object of the form:
;;> \scheme{(mime (@ (header . value) ...) parts ...)}.

(define (mime-message->sxml . o)
  (car
   (apply
    mime-message-fold
    (if (pair? o) (car o) (current-input-port))
    (lambda (parent-headers headers body seed)
      ;; Discard empty bodies.
      (if (and (equal? body "") (null? headers))
          seed
          `((mime (@ ,@headers) ,body) ,@seed)))
    '() #f #f (if (pair? o) (cdr o) '()))))

(define-library (chibi memoize)
  (import (chibi) (chibi optional) (chibi time) (chibi io)
          (chibi pathname) (chibi filesystem) (chibi system)
          (srfi 9) (srfi 38) (srfi 69))
  (cond-expand
   (chibi
    (import (chibi ast)))
   (else
    (begin
      (define (procedure-name x) #f)
      (define (procedure-arity x) #f)
      (define (procedure-variadic? x) #f))))
  (export define-memoized memoize memoize-to-file memoize-file-loader
          make-lru-cache lru-cache? lru-ref lru-ref! lru-set!
          hash-table-ref!)
  (include "memoize.scm"))

(define (get-host uri headers)
  (cond
   ((assq 'host headers)
    => (lambda (x)
         (let ((s (string-trim (cdr x))))
           (substring-cursor s 0 (string-find s #\:)))))
   ((uri-host uri))
   (else "localhost")))

(define (line-handler handler)
  (lambda (in out sock addr)
    (let ((line (read-line in)))
      (if (eof-object? line)
          #f
          (handler line in out sock addr)))))

(define (parse-command line)
  (let ((ls (string-split line #\space)))
    (cons (string->symbol (car ls)) (cdr ls))))

(define (command-handler handler)
  (line-handler
   (cond
    ((hash-table? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (cond
          ((hash-table-ref/default handler (car ls))
           => (lambda (handler)
                (handler (car ls) (cdr ls) in out sock addr)))))))
    ((list? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (cond
          ((assq (car ls) handler)
           => (lambda (cell)
                ((cdr cell) (car ls) (cdr ls) in out sock addr)))))))
    ((procedure? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (handler (car ls) (cdr ls) in out sock addr))))
    (else
     (error "invalid handler" handler)))))

(define (load-mime-types ht file)
  (protect
      (exn
       (else
        (display "couldn't load mime types from " (current-error-port))
        (write file (current-error-port))
        (newline (current-error-port))
        (print-exception exn)))
    (call-with-input-file file
      (lambda (in)
        (let lp ()
          (let ((line (read-line in)))
            (cond
             ((not (eof-object? line))
              (let ((ls (string-split
                         (cond ((string-find line #\#)
                                => (lambda (i) (substring line 0 i)))
                               (else line)))))
                (if (and (pair? ls) (pair? (cdr ls)))
                    (for-each
                     (lambda (x)
                       (hash-table-set! ht (string->symbol x) (car ls)))
                     (cdr ls)))
                (lp))))))))))

(define file-mime-type
  (let ((ext-types #f))
    (lambda (file . o)
      ;; set mime types on first use
      (if (not ext-types)
          (let ((ht (make-hash-table eq?)))
            (cond
             ((any file-exists? '("/etc/mime.types"
                                  "/etc/httpd/mime.types"
                                  "/etc/apache2/mime.types"))
              => (lambda (file) (load-mime-types ht file))))
            (set! ext-types ht)))
      (let* ((ext (path-extension file))
             (mtype (or (and ext (hash-table-ref/default
                                  ext-types
                                  (string->symbol
                                   (string-downcase-ascii ext))
                                  #f))
                        "application/octet-stream")))
        ;; TODO: auto-detect charset
        (if (equal? mtype "text/html")
            (string-append mtype "; charset=UTF-8")
            mtype)))))

(define (call-with-temp-file template proc)
  (let ((base (string-append
               "/tmp/" (path-strip-extension template)
               "-" (number->string (current-process-id)) "-"
               (number->string (round (current-seconds))) "-"))
        (ext (path-extension template)))
    (let lp ((i 0))
      (let ((path (string-append base (number->string i) "." ext)))
        (cond
         ((> i 100)  ;; give up after too many tries regardless
          (error "Repeatedly failed to generate temp file in /tmp"))
         ((file-exists? path)
          (lp (+ i 1)))
         (else
          (let ((fd (open path
                          (bitwise-ior open/write open/create open/exclusive))))
            (if (not fd)
                (if (file-exists? path) ;; created between test and open
                    (lp (+ i 1))
                    (error "Couldn't generate temp file in /tmp " path))
                (let* ((out (open-output-file-descriptor fd #o700))
                       (res (proc path out)))
                  (close-output-port out)
                  (delete-file path)
                  res)))))))))
;; http.scm -- http client
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utils

(define (string-char-index str c . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i start))
      (cond
       ((= i end) #f)
       ((eq? c (string-ref str i)) i)
       (else (lp (+ i 1)))))))

(define (string-split str ch)
  (let ((len (string-length str)))
    (let lp ((i 0) (res '()))
      (let ((j (string-char-index str ch i)))
        (if j
            (lp (+ j 1) (cons (substring str i j) res))
            (reverse (cons (substring str i len) res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; client utils

(define http-user-agent "chibi")

(define http-redirect-limit 10)
(define http-chunked-buffer-size 4096)
(define http-chunked-size-limit 409600)

(define (string-scan str ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i start))
      (and (< i end)
           (if (eqv? ch (string-ref str i))
               i
               (lp (+ i 1)))))))

(define (http-parse-response line)
  (let* ((len (string-length line))
         (i (or (string-scan line #\space 0 len) len))
         (j (or (string-scan line #\space (+ i 1) len) len))
         (n (and (< i j) (string->number (substring line (+ i 1) j)))))
    (if (not (integer? n))
        (error "bad response" line i j)
        (list (substring line 0 i)
              n
              (if (>= j len) "" (substring line (+ j 1) len))))))

(define (make-generated-binary-input-port generator)
  (let ((buf #u8())
        (len 0)
        (offset 0))
    (make-custom-binary-input-port
     (lambda (bv start end)
       (let ((n (- end start)))
         (cond
          ((>= (- len offset) n)
           (bytevector-copy! bv start buf offset (+ offset n))
           (set! offset (+ offset n))
           n)
          (else
           (bytevector-copy! bv start buf offset (+ offset len))
           (let lp ((i (+ start (- len offset))))
             (set! buf (generator))
             (cond
              ((not (bytevector? buf))
               (set! buf #u8())
               (set! len 0)
               (set! offset 0)
               (- i start))
              (else
               (set! len (bytevector-length buf))
               (set! offset 0)
               (cond
                ((>= (- len offset) (- n i))
                 (bytevector-copy! bv i buf offset (+ offset (- n i)))
                 (set! offset (+ offset (- n i)))
                 n)
                (else
                 (bytevector-copy! bv i buf offset len)
                 (lp (+ i (- len offset)))))))))))))))

(define (http-wrap-chunked-input-port in)
  (define (read-chunk in)
    (let* ((line (read-line in))
           (n (and (string? line) (string->number line 16))))
      (cond
       ((not (and (integer? n) (<= 0 n http-chunked-size-limit)))
        (error "invalid chunked size line" line))
       ((zero? n) "")
       (else (read-bytevector n in)))))
  (make-generated-binary-input-port
   (lambda () (read-chunk in))))

(define (http-generate-boundary)
  (string-append "chibi-boundary-"
                 (number->string (random-integer 1000000000))))

;; A body can be a raw string or bytevector, or an alist of name/value
;; pairs.
(define (http-send-body headers body out)
  (cond
   ((string? body)
    (display body out))
   ((bytevector? body)
    (write-bytevector body out))
   ((pair? body)
    (let* ((ctype (cond ((or (assq 'Content-Type headers)
                             (assq 'content-type headers))
                         => (lambda (x)
                              (mime-parse-content-type (cdr x))))
                        (else #f)))
           (boundary (and ctype (assq-ref (cdr ctype) 'boundary))))
      (for-each
       (lambda (x)
         (display "\r\n--" out)
         (if boundary (display boundary out))
         (let* ((content
                 (if (pair? (cdr x))
                     (cond ((assq 'value (cdr x)) => cdr)
                           ((assq 'file (cdr x)) =>
                            (lambda (x)
                              (port->bytevector
                               (open-binary-input-file (cdr x)))))
                           (else (error "unknown content: " x)))
                     (cdr x)))
                (content-type
                 (cond ((and (pair? (cdr x))
                             (or (assq 'content-type (cdr x))
                                 (assq 'Content-Type (cdr x))))
                        => cdr)
                       ((string? content) "text/plain")
                       (else "application/octet-stream"))))
           (display "\r\nContent-Disposition: form-data; name=\"" out)
           (display (car x) out)
           (display "\"" out)
           (cond ((and (pair? (cdr x)) (assq 'file (cdr x)))
                  => (lambda (x)
                       (display "; filename=\"" out)
                       (display (cdr x) out)
                       (display "\"" out))))
           (display "\r\nContent-Type: " out)
           (display content-type out)
           (display "\r\n\r\n" out)
           (http-send-body headers content out)))
       body)
      (display "\r\n--" out)
      (if boundary (display boundary out))
      (display "--\r\n" out)))
   (body
    (error "unknown body" body))))

(define (http-call-method method url in-headers body limit)
  (if (<= limit 0)
      (error "http-get: redirect limit reached" (uri->string url))
      (let* ((uri (if (uri? url) url (string->uri url)))
             (host (and uri (uri-host uri))))
        (if (not host)
            (error "invalid url" url)
            (let* ((io (open-net-io
                        host
                        (or (uri-port uri)
                            (if (eq? 'https (uri-scheme uri)) 443 80))))
                   (in (cadr io))
                   (out (car (cddr io))))
              (display method out)
              (display " " out)
              (display (or (uri-path uri) "/") out)
              (display " HTTP/1.0\r\n" out)
              (display "Host: " out) (display host out) (display "\r\n" out)
              (cond
               ((not (assq-ref in-headers 'user-agent))
                (display "User-Agent: " out)
                (display http-user-agent out)
                (display "\r\n" out)))
              (for-each
               (lambda (x)
                 (display (car x) out)  (display ": " out)
                 (display (cdr x) out) (display "\r\n" out))
               in-headers)
              (display "Connection: close\r\n\r\n" out)
              (http-send-body in-headers body out)
              (flush-output-port out)
              (let* ((resp (http-parse-response (read-line in)))
                     (headers (mime-headers->list in))
                     (status (quotient (cadr resp) 100)))
                (case status
                  ((2)
                   (let ((enc (assq-ref headers 'transfer-encoding)))
                     (cond
                      ((equal? enc "chunked")
                       (cons headers (http-wrap-chunked-input-port in)))
                      (else
                       (cons headers in)))))
                  ((3)
                   (close-input-port in)
                   (close-output-port out)
                   (let ((url2 (assq-ref headers 'location)))
                     (if url2
                         (http-get/raw url2 in-headers (- limit 1))
                         (error "redirect with no location header" url url2))))
                  (else
                   (close-input-port in)
                   (close-output-port out)
                   (error "couldn't retrieve url" (uri->string url) resp)))))))))

(define (http-get/raw url headers limit)
  (http-call-method 'GET url headers #f limit))

(define (http-get/headers url . headers)
  (http-get/raw url
                (if (pair? headers) (car headers) '())
                http-redirect-limit))

(define (http-get url . headers)
  (cdr (apply http-get/headers url headers)))

(define (http-head url . headers)
  (car (http-call-method 'HEAD url
                         (if (pair? headers) (car headers) '()) #f
                         http-redirect-limit)))

(define (http-post url body . o)
  (let* ((headers (if (pair? o) (car o) '()))
         (headers
          (if (or (assq headers 'content-type)
                  (assq headers 'Content-Type))
              headers
              (let ((boundary (http-generate-boundary)))
                `((Content-Type . ,(string-append
                                    "multipart/form-data; boundary="
                                    boundary))
                  ,@headers))))
         (body
          (let ((out (open-output-bytevector)))
            (http-send-body headers body out)
            (get-output-bytevector out)))
         (headers
          (if (or (assq headers 'content-length)
                  (assq headers 'Content-Length))
              headers
              `((Content-Length . ,(bytevector-length body))
                ,@headers))))
    (cdr (http-call-method 'POST url headers body http-redirect-limit))))

(define (http-put url body . headers)
  (cdr (http-call-method 'PUT url
                         (if (pair? headers) (car headers) '()) body
                         http-redirect-limit)))

(define (http-delete url . headers)
  (cdr (http-call-method 'DELETE url
                         (if (pair? headers) (car headers) '()) #f
                         http-redirect-limit)))

(define (call-with-input-url url proc)
  (let* ((p (http-get url))
         (res (proc p)))
    (close-input-port p)
    res))

(define (call-with-input-url/headers url proc)
  (let* ((h+p (http-get/headers url))
         (res (proc (car h+p) (cdr h+p))))
    (close-input-port (cdr h+p))
    res))

(define (with-input-from-url url thunk)
  (let ((p (http-get url)))
    (let ((res (parameterize ((current-input-port p)) (thunk))))
      (close-input-port p)
      res)))

(define (http-get-to-file url path)
  (call-with-input-url url
    (lambda (in)
      (let ((out (open-binary-output-file path)))
        (let lp ()
          (let ((c (read-u8 in)))
            (cond ((not (eof-object? c))
                   (write-u8 c out)
                   (lp)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; server utils

;; read and parse a request line
(define (http-parse-request . o)
  (let ((line (string-split
               (read-line (if (pair? o) (car o) (current-input-port)) 4096))))
    (cons (string->symbol (car line)) (cdr line))))

;; Parse a form body with a given URI and MIME headers (as parsed with
;; mime-headers->list).  Returns an alist of (name . value) for every
;; query or form parameter.
(define (http-parse-form uri headers . o)
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (type (assq-ref headers
                         'content-type
                         "application/x-www-form-urlencoded")) 
         (query0 (or (uri-query (if (string? uri) (string->uri uri) uri)) '()))
         (query (if (string? query0) (uri-query->alist query0) query0)))
    (cond
     ((and (>= (string-length type) 10)
           (string-ci=? "multipart/" (substring type 0 10)))
      (let ((mime (mime-message->sxml in headers)))
        (append
         (let lp ((ls (cddr mime))
                  (res '()))
           (cond
            ((null? ls)
             res)
            ((and (pair? (car ls))
                  (eq? 'mime (caar ls))
                  (pair? (cdar ls))
                  (pair? (car (cdar ls)))
                  (memq (caar (cdar ls)) '(^ @)))
             (let* ((disp0 (assq-ref (cdar (cdar ls)) 'content-disposition ""))
                    (disp (mime-parse-content-type disp0))
                    (name (assq-ref disp 'name)))
               (if name
                   (lp (cdr ls) (cons (cons name (cadr (cdar ls))) res))
                   (lp (cdr ls) res))))
            (else
             (lp (cdr ls) res))))
         query)))
     (else
      query))))

;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define default-max-requests 10000)

(define (make-socket-listener-thunk listener port)
  (lambda ()
    (let ((addr (get-address-info #f port)))
      (cond
       ((accept listener
                (address-info-address addr)
                (address-info-address-length addr))
        => (lambda (sock) (list sock addr)))
       (else #f)))))

(define (make-listener-thunk x)
  (cond
   ((integer? x)
    (make-socket-listener-thunk
     (make-listener-socket (get-address-info #f x))
     x))
   ((address-info? x)
    (make-socket-listener-thunk (make-listener-socket x) 80))
   ((fileno? x)
    (make-socket-listener-thunk x 80))
   ((procedure? x)
    x)
   (else
    (error "expected a listener socket, fileno or thunk" x))))

(define (run-net-server listener-or-addr handler . o)
  (let ((listener-thunk (make-listener-thunk listener-or-addr))
        (max-requests
         (or
          (cond ((pair? o) (car o))
                ((get-environment-variable "CHIBI_NET_SERVER_MAX_THREADS")
                 => string->number)
                (else #f))
          default-max-requests)))
    (define (run sock addr count)
      (log-debug "net-server: accepting request:" count)
      (let ((ports
             (protect (exn
                       (else
                        (log-error "net-server: couldn't create port:" sock)
                        (close-file-descriptor sock)))
               (cons (open-input-file-descriptor sock)
                     (open-output-file-descriptor sock)))))
        (protect (exn
                  (else (log-error "net-server: error in request:" count)
                        (print-exception exn)
                        (print-stack-trace exn)
                        (close-input-port (car ports))
                        (close-output-port (cdr ports))
                        (close-file-descriptor sock)))
          (handler (car ports) (cdr ports) sock addr)
          (flush-output (cdr ports))
          (close-input-port (car ports))
          (close-output-port (cdr ports))
          (close-file-descriptor sock)))
      (log-debug "net-server: finished: " count))
    (let ((requests 0))
      (let serve ((count 0))
        (if (>= requests  max-requests)
            (thread-yield!)
            (let ((sock+addr (listener-thunk)))
              (cond
               ((not sock+addr)
                (serve count))
               ((= 1 max-requests)
                (run (car sock+addr) (cadr sock+addr) count)
                (serve (+ 1 count)))
               (else
                (thread-start!
                 (make-thread
                  (lambda ()
                    (set! requests (+ requests 1))
                    (run (car sock+addr) (cadr sock+addr) count)
                    (set! requests (- requests 1)))
                  (string-append "net-client-" (number->string count))))
                (serve (+ 1 count))))))))))
;; http-server.scm -- combinator-based http server
;; Copyright (c) 2013-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Runs an http server listening at the given address, with the given
;;> servlet.
;;>
;;> An servlet is a procedure which takes three arguments: an
;;> \scheme{Http-Request} record, which contains the I/O ports and
;;> parsed request and headers; a \scheme{next} procedure to call the
;;> next available servlet if any, and a \scheme{restart} procedure to
;;> restart the servlets with a new request.

(define (run-http-server listener-or-addr servlet . o)
  (let ((cfg (if (pair? o) (car o) (make-conf '() #f #f #f))))
    (run-net-server
     listener-or-addr
     (command-handler
      (lambda (command ls in out sock addr)
        (cond
         ((= 2 (length ls))
          (let ((request
                 (make-request command (car ls) (cadr ls) in out sock addr)))
            (log-info `(request: ,command ,(car ls) ,(cadr ls)
                                 ,(request-headers request)))
            (protect (exn
                      (else
                       (log-error "internal error: " exn)
                       (servlet-respond request 500 "Internal server error")))
              (let restart ((request request))
                (servlet cfg request servlet-bad-request restart)))))
         (else
          (let ((request (make-request command #f #f in out sock addr)))
            (servlet-respond request 400 "bad request")))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Servlets.

(define (http-chain-servlets f . o)
  (let lp ((f f) (ls o))
    (if (pair? ls)
        (let ((g (lp (car ls) (cdr ls))))
          (lambda (cfg request next restart)
            (let ((next2 (lambda (cfg request) (g cfg request next restart))))
              (f cfg request next2 restart))))
        f)))

(define (http-wrap-default servlet)
  (http-chain-servlets servlet http-default-servlet))

(define (http-guard-servlet cfg request next restart)
  (let ((orig-out (request-out request))
        (tmp-out (open-output-string))
        (request2 (copy-request request)))
    (request-out-set! request2 tmp-out)
    (protect (exn (else (servlet-respond request 500 "Interal server error")))
      (next cfg request2)
      (display (get-output-string tmp-out) orig-out))))

(define (http-parse-body-servlet cfg request next restart)
  (let ((request2 (copy-request request)))
    (servlet-parse-body! request2)
    (next cfg request2)))

(define (http-get*-servlet proc)
  (lambda (cfg request next restart)
    (if (memq (request-method request) '(GET POST))
        (proc cfg request next restart)
        (next cfg request))))

;; Generate a simple page listing the linked files in a directory.
(define (send-directory path out)
  (display "<html><body bgcolor=white><pre>\n" out)
  (for-each
   (lambda (file)
     (display "<a href=\"/" out)
     (display (path-normalize (make-path path file)) out)
     (display "\">" out)
     (display file out)
     (display "</a>\n" out))
   (sort (directory-files path)))
  (display "</pre></body></html>\n" out))

;; TODO: If the index-rx is a short list of fixed strings, check
;; individually to avoid the full directory lookup.
(define (find-index-file dir index-rx)
  (and index-rx
       (any (lambda (f) (and (regexp-matches? index-rx f) (make-path dir f)))
            (directory-files dir))))

(define (http-send-directory request path index-rx restart)
  (cond
   ((find-index-file path index-rx)
    => (lambda (index-file)
         ;; Generate and restart a new request with explicit index file.
         (let* ((uri (request-uri request))
                (path2 (make-path (uri-path uri)
                                  (path-strip-directory index-file))))
           (restart
            (request-with-uri request (uri-with-path uri path2))))))
   (else
    (send-directory path (request-out request)))))

(define (http-send-file request path)
  (cond
   ((file-exists? path)
    (servlet-respond request 200 "OK")
    (send-file path (request-out request)))
   (else
    (servlet-respond request 404 "Not Found"))))

(define (http-file-servlet . o)
  (let ((dir (if (pair? o) (car o) "."))
        (index-rx (and (pair? o) (pair? (cdr o)) (cadr o))))
    (http-get*-servlet
     (lambda (cfg request next restart)
       (let ((path (make-path dir (request-path request))))
         (if (file-directory? path)
             (http-send-directory request path index-rx restart)
             (http-send-file request path)))))))

(define (http-procedure-servlet path proc)
  (http-get*-servlet
   (lambda (cfg request next restart)
     (cond
      ((equal? path (path-normalize (request-path request)))
       (servlet-respond request 200 "OK")
       (proc request))
      (else
       (next cfg request))))))

(define (http-regexp-servlet rules get-field)
  (lambda (cfg request next restart)
    (let ((str (get-field request)))
      (let lp ((request request) (ls rules))
        (cond
         ((null? ls)
          (next cfg request))
         ((not (valid-sre? (caar ls)))
          (log-warn "invalid sre: " (caar ls))
          (lp request (cdr ls)))
         ((regexp-matches? (caar ls) str)
          => (lambda (m)
               (let ((next (lambda (cfg request) (lp request (cdr ls)))))
                 ((cdar ls) cfg request next restart))))
         (else
          (lp request (cdr ls))))))))

(define (http-uri-regexp-servlet rules)
  (http-regexp-servlet rules request-uri-string))

(define (http-path-regexp-servlet rules)
  (http-regexp-servlet
   rules
   (lambda (request) (uri-path (request-uri request)))))

(define (http-host-regexp-servlet rules)
  (http-regexp-servlet rules request-host))

(define (http-regexp-replace-servlet rules helper)
  (lambda (cfg request next restart)
    (let ((uri (uri->string (request-uri request))))
      (let lp ((ls rules))
        (if (null? ls)
            (next cfg request)
            (let ((uri2 (regexp-replace (caar ls) uri (cdar ls))))
              (cond
               ((equal? uri uri2)
                (lp (cdr ls)))
               ((string->path-uri 'http uri2)
                => (lambda (uri)
                     (helper cfg (request-with-uri request uri) next restart)))
               (else
                (log-warn "invalid rewritten uri: " uri2)
                (lp (cdr ls))))))))))

(define (http-redirect-servlet rules)
  (http-regexp-replace-servlet
   rules
   (lambda (cfg request next restart)
     (let ((headers `(Location . ,(uri->string (request-uri request)))))
       (servlet-respond request 302 "Found" headers)))))

(define (http-rewrite-servlet rules)
  (http-regexp-replace-servlet
   rules
   (lambda (cfg request next restart) (restart request))))

(define (index-path-map-servlet from to index-rx servlet)
  (http-get*-servlet
   (lambda (cfg request next restart)
     (let* ((path (path-normalize (uri-path (request-uri request))))
            (rel-path (path-relative-to path from)))
       (cond
        (rel-path
         (let* ((local-path (make-path to rel-path))
                (local-path
                 (if (and index-rx (file-directory? local-path))
                     (find-index-file local-path index-rx)
                     local-path)))
           (if (file-exists? local-path)
               (servlet cfg request local-path next restart)
               (servlet-respond request 404 "Not found"))))
        (else
         (next cfg request)))))))

(define (path-map-servlet from to servlet)
  (index-path-map-servlet from to #f servlet))

(define (http-cgi-bin-servlet request local-path next restart)
  (call-with-temp-file "cgi.out"
    (lambda (temp-file out)
      (let ((pid (fork)))
        (cond
         ((zero? pid)
          (duplicate-file-descriptor-to
           (port-fileno (request-in request)) 0)
          (duplicate-file-descriptor-to (port-fileno out) 1)
          (safe-setenv "HTTP_HOST" (request-host request))
          (safe-setenv "REQUEST_URI" (uri->string (request-uri request)))
          (safe-setenv "REQUEST_METHOD"
                       (symbol->string (request-method request)))
          (safe-setenv "QUERY_STRING"
                       (or (uri-query (request-uri request)) ""))
          (let ((res (execute local-path (list local-path))))
            (display "failed to execute program: " (current-error-port))
            (write local-path (current-error-port))
            (display " => " (current-error-port))
            (write res (current-error-port))
            (newline (current-error-port))
            (exit 1)))
         (else
          (let ((status (waitpid pid 0)))
            (cond
             ((negative? (car status))
              (servlet-respond request 500 "Internal server error"))
             (else
              (display "HTTP/1.0 200 OK\r\n" (request-out request))
              (flush-output (request-out request))
              (send-file temp-file (request-out request))
              (close-output-port out))))))))))

(define (http-cgi-bin-dir-servlet local-dir . o)
  (let ((virtual-dir (if (pair? o) (car o) "/cgi-bin")))
    (path-map-servlet
     virtual-dir local-dir
     (lambda (cfg request prog-path next restart)
       (http-cgi-bin-servlet request prog-path next restart)))))

(define (with-add-to-load-path dir thunk)
  (if dir
      (let* ((orig-path (current-module-path))
             (new-path (cons dir (current-module-path))))
        (dynamic-wind (lambda () (current-module-path new-path))
                      thunk
                      (lambda () (current-module-path orig-path))))
      (thunk)))

(define (make-import-environment)
  (let ((env (make-environment)))
    (%import env (current-environment) '(import) #t)
    env))

(define (load-scheme-script path . o)
  (if (and (file-exists? path) (not (file-directory? path)))
      (let ((env (make-import-environment)) 
            (handle #f))
        (protect (exn (else
                       (log-error "failed to load servlet " exn)))
          (let ((e1 (call-with-input-file path read)))
            (cond
             ((not (and (pair? e1) (eq? 'import (car e1))))
              (log-error "not a scheme program (no import): " path))
             (else
              (parameterize ((servlet-handler (lambda (h) (set! handle h))))
                (with-add-to-load-path (and (pair? o) (car o))
                                       (lambda () (load path env))))))))
        (cond ((not (procedure? handle))
               (log-error "no servlet defined in " path)
               (lambda (cfg request next restart)
                 (servlet-respond request 500 "Internal server error")))
              (else handle)))
      (lambda (cfg request next restart)
        (servlet-respond request 404 "Not found"))))

(define load-scheme-script/memoized
  (memoize-file-loader load-scheme-script))

(define (http-scheme-script-dir-servlet local-dir . o)
  (let ((virtual-dir (or (and (pair? o) (car o)) "/"))
        (index-rx (and (pair? o) (pair? (cdr o)) (cadr o))))
    (index-path-map-servlet
     virtual-dir local-dir index-rx
     (lambda (cfg request script-path next restart)
       (let ((servlet (load-scheme-script/memoized script-path local-dir)))
         (servlet cfg request next restart))))))

(define (http-scheme-script-ext-servlet cfg request local-path next restart)
  ((load-scheme-script/memoized local-path) cfg request next restart))

(define (get-ext-servlet x file)
  (if (procedure? x)
      x
      (case x
        ((scheme) http-scheme-script-ext-servlet)
        ((cgi) http-cgi-bin-servlet)
        (else (error "unknown ext servlet" x)))))

(define (http-ext-servlet rules local-dir . o)
  (let ((virtual-dir (if (pair? o) (car o) "/")))
    (path-map-servlet
     virtual-dir local-dir
     (lambda (cfg request local-path next restart)
       (cond
        ((assoc (path-extension local-path) rules)
         => (lambda (cell)
              (let ((name (if (pair? (cdr cell)) (cadr cell) (cdr cell))))
                ((get-ext-servlet name local-path) cfg request local-path next restart))))
        (else
         (next cfg request)))))))

(define (http-default-servlet cfg request next restart)
  (case (request-method request)
    ((HEAD)
     (call-with-temp-file "get.out"
       (lambda (temp-file out)
         (let ((request2 (copy-request request)))
           (request-method-set! request2 'GET)
           (request-out-set! request2 out)
           (restart request2)
           (close-output-port out)
           (call-with-input-file temp-file
             (lambda (in)
               (let* ((status (read-line in))
                      (headers (mime-headers->list in))
                      (out (request-out request)))
                 (display status out)
                 (display "\r\n" out)
                 (mime-write-headers headers out)
                 (display "\r\n" out))))))))
    ((BREW)
     (servlet-respond request 418 "I'm a teapot"))
    (else
     (servlet-bad-request cfg request next restart))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Config-based servlets.

;; Utility to wrap SRE rules.
(define (http-wrap-sre-config cfg clear ls)
  (map
   (lambda (x)
     (cond
      ((valid-sre? (car x))
       `(,(regexp (car x))
         . ,(http-config-servlet
             (make-conf (cdr x) (make-conf `((,clear)) cfg #f #f) #f #f))))
      (else
       (log-error "invalid sre in config: " (car x))
       `(,(regexp '(+ (~ any)))
         . ,(lambda (request) (error "unreachable servlet"))))))
   ls))

;; Utility to wrap servlets which take a local path as the first arg.
(define (http-wrap-doc-root f)
  (lambda (args cfg)
    (let* ((root (conf-get cfg 'doc-root "."))
           (local-dir (if (pair? args) (car args) "/"))
           (virtual-dir (if (and (pair? args) (pair? (cdr args)))
                            (cadr args)
                            (make-path "/" local-dir)))
           (args (append (list (make-path root local-dir) virtual-dir)
                         (if (and (pair? args) (pair? (cdr args)))
                             (cddr args)
                             '()))))
      (f args cfg))))

(define (http-config-file-servlet cfg . o)
  (let* ((root (conf-get cfg 'doc-root "."))
         (dir (make-path root (if (pair? o) (car o) ".")))
         (index-rx (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (conf-get cfg 'index-regexp "index.html"))))
    (http-file-servlet dir index-rx)))

;; Ordered list of servlets to try for a given config.  Generally
;; gives the intuitive order, but manual ordering can be imposed with
;; regexp rules.
(define ordered-config-servlets
  `((redirect . ,(lambda (rules cfg) (http-redirect-servlet rules)))
    (rewrite . ,(lambda (rules cfg) (http-rewrite-servlet rules)))
    (host . ,(lambda (hosts cfg)
               (http-host-regexp-servlet
                (http-wrap-sre-config cfg 'host hosts))))
    (uri . ,(lambda (rules cfg)
              (http-uri-regexp-servlet
               (http-wrap-sre-config cfg 'uri rules))))
    (path . ,(lambda (rules cfg)
               (http-path-regexp-servlet
                (http-wrap-sre-config cfg 'path rules))))
    (file . ,(lambda (x cfg)
               (apply http-config-file-servlet cfg x)))
    (cgi . ,(http-wrap-doc-root
             (lambda (dirs cfg) (apply http-cgi-bin-dir-servlet dirs))))
    (scheme . ,(http-wrap-doc-root
                (lambda (dirs cfg)
                  (let ((local-dir (car dirs))
                        (virtual-dir (cadr dirs))
                        (index-rx (conf-get cfg 'index-regexp "index.scm")))
                    (http-scheme-script-dir-servlet
                     local-dir virtual-dir index-rx)))))
    (ext . ,(lambda (rules cfg)
              (http-ext-servlet rules (conf-get cfg 'doc-root "."))))
    ))

;; Config servlet for an already constructed config.
(define (http-config-conf-servlet cfg . o)
  (http-chain-servlets
   (lambda (orig-cfg request next restart)
     (next cfg request))
   (let lp ((ls ordered-config-servlets))
     (cond
      ((null? ls)
       (if (pair? o)
           (http-chain-servlets (car o) http-default-servlet)
           http-default-servlet))
      ((conf-get-cdr cfg (caar ls))
       => (lambda (x)
            (let ((rest (lp (cdr ls))))
              (if (or (pair? x) (null? x))
                  (http-chain-servlets ((cdar ls) x cfg) rest) 
                  rest))))
      (else
       (lp (cdr ls)))))))

;; Config servlet to load a config from a file.
(define (http-config-servlet-load file . o)
  (let* ((cfg (conf-load file))
         (cfg (if (and (pair? o) (conf? (car o)))
                  (if (and (pair? (cdr o)) (conf? (cadr o)))
                      (conf-append (car o) (conf-append cfg (cadr o)))
                      (conf-append (car o) cfg))
                  cfg)))
    (http-config-conf-servlet cfg (http-config-file-servlet cfg))))

;; Primary config servlet which dispatches on argument type.
(define (http-config-servlet x)
  (cond
   ((procedure? x)
    x)
   ((list? x)
    (http-config-conf-servlet (make-conf x #f #f (current-second))))
   ((string? x)
    (if (file-directory? x)
        (http-file-servlet x)
        (http-config-servlet (make-conf #f #f x -1))))
   ((not (conf? x))
    (error "unknown type for http-config-servlet" x))
   ((and (string? (conf-source x))
         (file-exists? (conf-source x)))
    (let* ((f (conf-source x))
           (mtime (file-modification-time f)))
      ((memoize-file-loader
        (lambda (f) (http-config-servlet-load f #f (conf-parent x)))
        'reloader?: #true
        'cache: `(((,mtime . ,f) . ,x)))
       f)))
   ((and (conf-parent x)
         (string? (conf-source (conf-parent x)))
         (file-exists? (conf-source (conf-parent x))))
    (let* ((f (conf-source (conf-parent x)))
           (mtime (file-modification-time f)))
      ((memoize-file-loader
        (lambda (f) (http-config-servlet-load f (conf-head x) (conf-parent x)))
        'reloader?: #true
        'cache: `(((,mtime . ,f) . ,x)))
       f)))
   (else
    (http-config-conf-servlet x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sample main.  In chibi-scheme you can run:
;;
;; chibi-scheme -Rchibi.net.http-config-server -- [<cfg-file-or-directory>]
;;
;; which defaults to serving the current directory on port 8000.

(define (run-app cfg spec . args)
  (define (run cfg servlet)
    (run-http-server (conf-get cfg 'port 8000) servlet cfg))
  (cond
   ((> (length args) 1)
    (error "usage: httpd [<cfg-file-or-directory>]"))
   ((or (null? args) (file-directory? (car args)))
    (let ((dir (if (null? args) "." (car args))))
      (run cfg (http-wrap-default (http-config-file-servlet cfg dir)))))
   (else
    (let* ((cfg-file (car args))
           (last-cfg
            (make-conf `((doc-root . ,(path-directory cfg-file))) #f #f #f))
           (cfg (conf-append cfg (conf-append (conf-load cfg-file) last-cfg))))
      (run cfg (http-config-servlet cfg))))))

(define app-spec
  `(http-config-server
    "Config-based HTTP server"
    (@
     ((port integer)
      (doc-root string)
      (verbose? boolean (#\v "verbose"))))
    ,run-app))

(define (main args) (run-application app-spec args))

(define-library (chibi net server-util)
  (import (chibi) (chibi io) (chibi net) (chibi string) (chibi uri)
          (chibi process) (chibi time) (chibi pathname) (chibi filesystem)
          (srfi 33) (srfi 69))
  (export line-handler command-handler parse-command
          get-host file-mime-type call-with-temp-file)
  (include "server-util.scm"))

(define-library (chibi net http)
  (export http-get http-get/headers http-get-to-file
          http-head http-post http-put http-delete
          call-with-input-url call-with-input-url/headers
          with-input-from-url
          http-parse-request http-parse-form)
  (import (scheme base) (scheme write) (scheme char) (scheme file)
          (srfi 27) (srfi 39)
          (chibi net) (chibi io) (chibi uri) (chibi mime))
  (include "http.scm"))
;; servlet.scm -- basic web servlets and utilities
;; Copyright (c) 2013-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for http and cgi servlets.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Uploads.

(define-record-type Upload
  (make-upload name filename sxml)
  upload?
  (name upload-name upload-name-set!)
  (filename upload-filename upload-filename-set!)
  (sxml upload-sxml upload-sxml-set!))

;; Currently uploads are only represented as inlined strings, but may
;; be saved to temp files in later versions so we provide only this
;; abstract API.

(define (upload-headers upload)
  (cadr (upload-sxml upload)))

(define (upload-content upload)
  (car (cddr (upload-sxml upload))))

(define (upload->string upload)
  (let ((x (upload-content upload)))
    (if (bytevector? x) (utf8->string x) x)))

(define (upload->bytevector upload)
  (let ((x (upload-content upload)))
    (if (string? x) (string->utf8 x) x)))

(define (upload->sexp upload)
  (let* ((in (upload-input-port upload))
         (res (read in)))
    (close-input-port in)
    res))

(define (upload-input-port upload)
  (open-input-string (upload->string upload)))

(define (upload-binary-input-port upload)
  (open-input-bytevector (upload->bytevector upload)))

(define (upload-save upload path)
  (let ((content (upload-content upload)))
    (call-with-output-file path
      (lambda (out)
        (if (string? content)
            (display content out)
            (write-bytevector content out))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Requests.

(define-record-type Request
  (%make-request
   method host uri version headers body params uploads in out sock addr status)
  request?
  (method request-method request-method-set!)
  (host request-host request-host-set!)
  (uri request-uri request-uri-set!)
  (version request-version request-version-set!)
  (headers request-headers request-headers-set!)
  (body request-body request-body-set!)
  (params request-params request-params-set!)
  (uploads request-uploads request-uploads-set!)
  (in request-in request-in-set!)
  (out request-out request-out-set!)
  (sock request-sock request-sock-set!)
  (addr request-addr request-addr-set!)
  (status request-status request-status-set!))

(define (request-uri-string request)
  (uri->string (request-uri request)))

(define (request-path request)
  (uri-path (request-uri request)))

(define (copy-request r)
  (%make-request
   (request-method r) (request-host r) (request-uri r) (request-version r)
   (request-headers r) (request-body r) (request-params r) (request-uploads r)
   (request-in r) (request-out r) (request-sock r) (request-addr r)
   (request-status r)))

(define (request-with-uri request uri)
  (let ((request2 (copy-request request))
        (uri (string->path-uri 'http uri)))
    (request-uri-set! request2 uri)
    ;; NOTE: this looses form parameters
    (request-params-set! request2 (uri-query->alist (or (uri-query uri) "")))
    request2))

(define (request-param request name . o)
  (cond ((assoc name (request-params request)) => cdr)
        (else (and (pair? o) (car o)))))

(define (assoc-multi ls key)
  (let lp ((ls ls) (res '()))
    (cond ((not (pair? ls)) (reverse res))
          ((equal? key (caar ls)) (lp (cdr ls) (cons (cdar ls) res)))
          (else (lp (cdr ls)res)))))

(define (request-param-list request name)
  (assoc-multi (request-params request) name))

(define (request-upload request name . o)
  (cond ((assoc name (request-uploads request)) => cdr)
        (else (and (pair? o) (car o)))))

(define (request-upload-list request name)
  (assoc-multi (request-uploads request) name))

(define (make-request method path version in out sock addr)
  (let* ((uri (string->path-uri 'http path))
         (headers (mime-headers->list in))
         (host (get-host uri headers))
         (params (uri-query->alist (or (uri-query uri) ""))))
    (%make-request method host uri version headers #f params '()
                   in out sock addr #f)))

(define (make-cgi-request)
  (let* ((method (or (get-environment-variable "REQUEST_METHOD") "GET"))
         (uri (string->path-uri
               'http (or (get-environment-variable "REQUEST_URI") "")))
         (params (uri-query->alist (or (uri-query uri) "")))
         (headers `((host . ,(or (get-environment-variable "HTTP_HOST")
                                 ""))))
         (host (get-host uri headers))
         (version (or (get-environment-variable "SERVER_PROTOCOL")
                      "HTTP/1.0")))
    (%make-request method host uri version headers #f params '()
                   (current-input-port) (current-output-port) #f #f #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher-level utilities.

(define (servlet-write-status out status msg)
  (display "HTTP/1.1 " out)
  (display status out)
  (display " " out)
  (display msg out)
  (display "\r\n" out))

;;> Respond with a numeric status, string message and optional headers.

(define (servlet-respond request status msg . o)
  (cond
   ((not (and (integer? status) (<= 0 status 999)))
    (error "http status must be a 3-digit integer" status))
   ((request-status request)
    (error "can't set servlet status multiple times: "
           (request-status request) status))
   (else
    (request-status-set! request status)
    (let* ((out (request-out request))
           (headers (if (pair? o) (car o) '()))
           (headers
            (cond
             ;; Socket bound, not CGI, send normal status.
             ((request-sock request)
              (servlet-write-status out status msg)
              headers)
             ;; No socket bound, we're in CGI, send status as a header.
             (else
              (let ((str (string-append (number->string status) " " msg)))
                `((Status . ,str)
                  ,@headers))))))
      (mime-write-headers headers out)
      (display "\r\n" out)
      (flush-output-port out)))))

;;> Write the contents of a string to the request.  If no status has
;;> been sent, assume a default of 200.

(define (servlet-write request str . o)
  (if (not (request-status request))
      (apply servlet-respond request 200 "OK" o))
  (display str (request-out request)))

(define (extract-form-data sxml)
  (define (form-data x)
    (and (pair? x) (eq? 'mime (car x))
         (pair? (cdr x)) (pair? (cadr x)) (eq? '@ (car (cadr x)))
         (or (string? (car (cddr x)))
             (bytevector? (car (cddr x))))
         (assq 'content-disposition (cdr (cadr x)))))
  (let lp ((ls sxml) (res '()) (files '()))
    (cond
     ((null? ls)
      (cons (reverse res) (reverse files)))
     ((form-data (car ls))
      => (lambda (x)
           (let ((disp (mime-parse-content-type (cdr x))))
             (cond
              ((and (pair? disp) (assq 'name (cdr disp)))
               => (lambda (y)
                    (let ((name (cdr y))
                          (val (cadr (cdar ls))))
                      (cond
                       ((assq 'filename (cdr disp))
                        => (lambda (z)
                             ;; If it has a filename it's an upload,
                             ;; we take the param value to be the
                             ;; filename, and accumulate the file.
                             (let ((upload (make-upload name (cdr z) (car ls))))
                               (lp (cdr ls)
                                   (cons (cons name (cdr z)) res)
                                   (cons (cons name upload) files)))))
                       (else
                        (lp (cdr ls) (cons (cons name val) res) files))))))
              (else
               (log-warn "ignoring form-data with no name: " x)
               (lp (cdr ls) res files))))))
     (else
      (lp (cdr ls) res files)))))

(define (servlet-parse-body! request)
  (let* ((headers (request-headers request))
         (ctype
          (mime-parse-content-type
           (cond ((assq 'content-type headers) => cdr)
                 (else ""))))
         (in (request-in request)))
    (cond
     ((and (pair? ctype) (eq? 'multipart/form-data (car ctype)))
      (let* ((sxml (mime-message->sxml in headers))
             (vars+files (extract-form-data sxml))
             (vars (append (request-params request) (car vars+files))))
        (request-body-set! request sxml)
        (request-params-set! request vars)
        (request-uploads-set! request (cdr vars+files))))
     ((and (pair? ctype) (eq? 'application/x-www-form-urlencoded (car ctype)))
      (let ((line (read-line in)))
        (request-body-set! request line)
        (if (not (eof-object? line))
            (request-params-set! request
                                 (append (request-params request)
                                         (uri-query->alist line)))))))))

(define (make-status-servlet status msg . o)
  (lambda (cfg request next restart)
    (apply servlet-respond request status msg o)))

(define servlet-bad-request
  (make-status-servlet 400 "Bad request"))

;; Generic interface.

(define servlet-handler (make-parameter #f))

(define (servlet-run servlet)
  (let ((handler (servlet-handler)))
    (cond
     ((procedure? handler)
      ;; A servlet handler has been set, so we're in a persistent server.
      (handler servlet))
     (else
      ;; Otherwise this is basic CGI.
      (let ((cfg (make-conf '() #f #f #f)))
        (let restart ((request (make-cgi-request)))
          (servlet cfg request servlet-bad-request restart)))))))

(define-library (chibi net server)
  (import (chibi) (chibi net) (chibi filesystem) (chibi log)
          (srfi 18) (srfi 98))
  (export run-net-server make-listener-thunk)
  (include "server.scm"))

(define-library (chibi net http-server)
  (export
   ;; main interface
   run-http-server
   ;; basic servlets
   http-chain-servlets http-default-servlet http-wrap-default
   http-file-servlet http-procedure-servlet http-ext-servlet
   http-regexp-servlet http-path-regexp-servlet http-uri-regexp-servlet
   http-host-regexp-servlet http-redirect-servlet http-rewrite-servlet
   http-cgi-bin-dir-servlet http-scheme-script-dir-servlet)
  (import (scheme time) (srfi 39) (srfi 95)
          (chibi) (chibi mime) (chibi regexp) (chibi pathname) (chibi uri)
          (chibi filesystem) (chibi io) (chibi string) (chibi process)
          (chibi net server) (chibi net server-util) (chibi net servlet)
          (chibi app) (chibi ast) (chibi config) (chibi log) (chibi memoize))
  (include "http-server.scm"))

(define-library (chibi net servlet)
  (export
   ;; uploads
   upload? upload-name upload-filename
   upload-headers upload->string upload-input-port upload-save
   upload->bytevector upload->sexp upload-binary-input-port
   ;; requests
   request? request-method request-host request-uploads
   request-uri request-version request-headers request-body request-params
   request-in request-out request-sock request-addr request-param
   request-method-set! request-host-set! request-uri-set!
   request-version-set! request-headers-set! request-body-set!
   request-params-set! request-in-set! request-out-set!
   request-sock-set! request-addr-set!
   request-param request-param-list request-upload request-upload-list
   request-uri-string request-with-uri request-path
   copy-request make-request make-cgi-request
   ;; servlets
   servlet-write servlet-respond servlet-parse-body!
   make-status-servlet servlet-handler servlet-run
   servlet-bad-request)
  (import
   (scheme base) (scheme read) (scheme write) (scheme file)
   (srfi 9) (srfi 39) (srfi 69) (srfi 98)
   (chibi ast) (chibi io) (chibi uri) (chibi mime) (chibi log) (chibi config)
   (chibi filesystem) (chibi net) (chibi net server-util))
  (include "servlet.scm"))

(define-library (chibi log)
  (export
   ;; Logger record
   Logger logger?
   logger-levels logger-levels-set!
   logger-level-abbrevs logger-level-abbrevs-set!
   logger-current-level logger-current-level-set!
   logger-prefix logger-prefix-set!
   logger-counts logger-counts-set!
   logger-file logger-file-set!
   logger-port logger-port-set!
   logger-locked? logger-locked?-set!
   logger-zipped? logger-zipped?-set!
   ;; syntax
   define-logger with-logged-errors with-logged-and-reraised-errors
   ;; procedural interface
   log-open log-close log-show log-show-every-n log-compile-prefix
   ;; levels introspection
   log-level-index log-level-name log-level-abbrev
   ;; the default logger
   default-logger log-emergency log-alert log-critical log-error
   log-warn log-notice log-info log-debug)
  (import (chibi) (srfi 9) (chibi time) (chibi process) (chibi system)
          (chibi filesystem) (chibi string) (chibi show base))
  (include "log.scm"))
;; log.scm -- customizable logging with levels
;; Copyright (c) 2005-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Logger
  (make-logger levels level-abbrevs current-level prefix prefix-spec
               counts file port locked? zipped?)
  logger?
  (levels logger-levels logger-levels-set!)
  (level-abbrevs logger-level-abbrevs logger-level-abbrevs-set!)
  (current-level logger-current-level %logger-current-level-set!)
  (prefix logger-prefix %logger-prefix-set!)
  (prefix-spec logger-prefix-spec logger-prefix-spec-set!)
  (counts logger-counts logger-counts-set!)
  (file logger-file logger-file-set!)
  (port logger-port logger-port-set!)
  (locked? logger-locked? logger-locked?-set!)
  (zipped? logger-zipped? logger-zipped?-set!))

(define (logger-prefix-set! logger prefix)
  (%logger-prefix-set! logger (log-compile-prefix prefix))
  (logger-prefix-set! logger prefix))

(define (logger-current-level-set! logger level)
  (%logger-current-level-set! logger (log-level-index logger level)))

(define-syntax define-logger
  (syntax-rules ()
    ((define-logger logger (levels ...))
     (def-logger logger (levels ...) log-default-prefix 0 () ()))))

(define-syntax def-logger
  (syntax-rules ()
    ((def-logger logger ((#f name) . rest) prefix n (names ...) defs)
     (def-logger logger rest prefix (+ n 1) (names ... name) defs))
    ((def-logger logger ((level name) . rest) prefix n (names ...) (defs ...))
     (def-logger logger rest prefix (+ n 1)
       (names ... name)
       (defs ...
         (define-syntax level
           (syntax-rules ()
             ((level . args)
              (if (<= n (logger-current-level logger))
                  (log-show logger n . args))))))))
    ((def-logger logger ((level name . x) . rest) . y)
     (syntax-error "bad logger level: " (level name . x)))
    ((def-logger logger (level . rest) prefix n names defs)
     (def-logger logger ((level (log-normalize-name 'level)) . rest)
       prefix n names defs))
    ((def-logger logger () prefix n (names ...) (defs ...))
     (begin
       defs ...
       (define logger
         (let ((names-vec (vector names ...)))
           (make-logger
            names-vec
            (log-generate-abbrevs names-vec)
            n
            (log-compile-prefix prefix)
            prefix
            '() #f (current-error-port) #f #f)))))))

(define (log-normalize-name name)
  (let ((str (symbol->string name)))
    (if (string-prefix? "log-" str)
        (string->symbol (substring str 4))
        name)))

(define (log-level-index logger level)
  (if (integer? level)
      level
      (let ((len (vector-length (logger-levels logger))))
        (let lp ((i 0))
          (cond
           ((= i len)
            (error "unknown log level" (logger-levels logger) level))
           ((eq? level (vector-ref (logger-levels logger) i)) i)
           (else (lp (+ i 1))))))))

(define (log-level-name logger level)
  (cond
   ((symbol? level)
    level)
   ((< level (vector-length (logger-levels logger)))
    (vector-ref (logger-levels logger) level))
   (else
    (let ((len (vector-length (logger-levels logger))))
      (string->symbol
      (string-append
       (symbol->string (vector-ref (logger-levels logger) (- len 1)))
       "-" (number->string (- level len))))))))

(define (log-level-abbrev logger level)
  (cond
   ((symbol? level)
    (log-level-abbrev logger (log-level-index logger level)))
   ((< level (vector-length (logger-level-abbrevs logger)))
    (vector-ref (logger-level-abbrevs logger) level))
   (else
    (number->string level))))

(define (log-generate-abbrevs abbrevs)
  (let* ((len (vector-length abbrevs))
         (res (make-vector len)))
    (do ((i 0 (+ i 1)))
        ((= i len) res)
      (let ((name (symbol->string (vector-ref abbrevs i))))
        (vector-set! res i (string (char-upcase (string-ref name 0))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; procedural interface

(define (log-generate-output logger level args)
  (let ((prefix ((logger-prefix logger) logger level))
        (message (show #f (each-in-list args))))
    (string-append
     prefix
     (string-concatenate (string-split message #\newline)
                         (string-append "\n" prefix))
     "\n")))

(define (log-compile-prefix spec)
  (define (pad2 n)
    (if (< n 10)
        (string-append "0" (number->string n))
        (number->string n)))
  (define (log-compile-one-prefix x)
    (if (string? x)
        (lambda (lg time level) x)
        (case x
          ((year)
           (lambda (lg time level) (number->string (+ 1900 (time-year time)))))
          ((month) (lambda (lg time level) (pad2 (+ 1 (time-month time)))))
          ((day) (lambda (lg time level) (pad2 (time-day time))))
          ((hour) (lambda (lg time level) (pad2 (time-hour time))))
          ((minute) (lambda (lg time level) (pad2 (time-minute time))))
          ((second) (lambda (lg time level) (pad2 (time-second time))))
          ((level)
           (lambda (lg time level) (symbol->string (log-level-name lg level))))
          ((level-abbrev)
           (lambda (lg time level) (log-level-abbrev lg level)))
          ((pid) (lambda (lg time level) (number->string (current-process-id))))
          ((uid) (lambda (lg time level) (number->string (current-group-id))))
          ((gid) (lambda (lg time level) (number->string (current-user-id))))
          (else (error "unknown logging spec" x)))))
  (let ((procs (map log-compile-one-prefix spec)))
    (lambda (logger level)
      (let ((time (seconds->time (current-seconds))))
        (let lp ((ls procs) (res '()))
          (if (null? ls)
              (string-concatenate (reverse res))
              (lp (cdr ls) (cons ((car ls) logger time level) res))))))))

(define log-default-prefix
  '(year "-" month "-" day " " hour ":" minute ":" second " " level-abbrev " "))

(define (log-open logger . o)
  (if (pair? o)
      (logger-file-set! logger (car o)))
  (if (string? (logger-file logger))
      (let ((fd (open (logger-file logger)
                      (+ open/create open/write open/append open/non-block))))
        (logger-port-set! logger (open-output-file-descriptor fd)))
      (logger-port-set! logger (current-error-port))))

(define (log-close logger)
  (if (output-port? (logger-port logger))
      (close-output-port (logger-port logger))))

;; Use file-locking to let multiple processes write to the same log
;; file.  On error try to re-open the log file.  We keep the port open
;; so that even if you mv the file (e.g. when rotating logs) we keep
;; writing to it in the new location.  To force writing to a new file
;; in the original location, use cp+rm instead of mv, so that the
;; logging will error and try to re-open.
(define (log-show logger level . args)
  (cond
   ((<= level (logger-current-level logger))
    (let ((str (log-generate-output logger level args)))
      (let lp ((first? #t))
        (let ((out (logger-port logger)))
          (protect (exn
                    (else
                     (cond
                      (first?  ; try to re-open log-file once
                       (log-close logger)
                       (log-open logger)
                       (lp #f))
                      (else    ; fall back to stderr
                       (display str (current-error-port))))))
            (let ((locked? (and (logger-locked? logger)
                                (output-port? out)
                                (file-lock out lock/exclusive))))
              ;; this is redundant with POSIX O_APPEND
              ;; (set-file-position! out 0 seek/end)
              (display str out)
              (flush-output out)
              (if locked? (file-lock out lock/unlock))))))))))

(define (log-show-every-n logger level id n . args)
  (cond
   ((assq id (logger-counts logger))
    => (lambda (cell)
         (if (zero? (modulo (cdr cell) n))
             (apply log-show logger level args))))
   (else
    (logger-counts-set! logger (cons (cons id 0) (logger-counts logger)))
    (apply log-show logger level args))))

;; http://httpd.apache.org/docs/2.2/mod/core.html#loglevel

(define-logger default-logger
  (log-emergency ; the server is on fire!!!           
   log-alert     ; couldn't write to user mailbox     
   log-critical  ; couldn't run 'dig' executable      
   log-error     ; error loading user filter          
   log-warn      ; invalid smtp command; relay failed 
   log-notice    ; saved to file/relayed to address   
   log-info      ; loaded alias file                  
   log-debug))   ; spam-probability: 0.5

(define-syntax with-logged-errors
  (syntax-rules ()
    ((with-logged-errors . body)
     (protect (exn (else (log-error exn)))
       . body))))

(define-syntax with-logged-and-reraised-errors
  (syntax-rules ()
    ((with-logged-errors . body)
     (protect (exn (else (log-error exn) (raise exn)))
       . body))))

;;> Define a new generic function named \var{name}.

(define-syntax define-generic
  (syntax-rules ()
    ((define-generic name)
     (define name (make-generic 'name)))))

;; call-next-method needs to be unhygienic
'(define-syntax define-method
  (syntax-rules ()
    ((define-method (name (param type) ...) . body)
     (generic-add! name
                   (list type ...)
                   (lambda (next param ...)
                     (let-syntax ((call))
                       . body))))))

;;> \macro{(define-method (name params ...) body ...)}

;;> Each parameter should be either a single identifier or a list of the form
;;> \scheme{(param type)} where \var{param} is the parameter name and
;;> \var{type} is a predicate which returns true if it's argument is of the
;;> correct type.
;;> Parameters without a predicate will always match.

;;> If multiple methods satisfy the arguments, the most recent method
;;> will be used.  The special form \scheme{(call-next-method)} can be
;;> invoked to call the next most recent method with the same arguments.

(define-syntax define-method
  (er-macro-transformer
   (lambda (e r c)
     (let ((name (car (cadr e)))
           (params (map (lambda (param)
                          (if (identifier? param)
                              `(,param (lambda _ #t))
                              param))
                        (cdr (cadr e))))
           (body (cddr e)))
       `(,(r 'generic-add!) ,name
         (,(r 'list) ,@(map cadr params))
         (,(r 'lambda) (,(r 'next) ,@(map car params))
          (,(r 'let-syntax) ((call-next-method
                              (,(r 'syntax-rules) ()
                               ((_) (,(r 'next))))))
           ,@body)))))))

(define (no-applicable-method-error name args)
  (error "no applicable method" name args))

(define (satisfied? preds args)
  (cond ((null? preds) (null? args))
        ((null? args) #f)
        (((car preds) (car args)) (satisfied? (cdr preds) (cdr args)))
        (else #f)))

(define add-method-tag (list 'add-method-tag))

;;> Create a new first-class generic function named \var{name}.

(define (make-generic name)
  (let ((name name)
        (methods (make-vector 6 '())))
    (vector-set! methods
                 3
                 (list (cons (list (lambda (x) (eq? x add-method-tag))
                                   (lambda (x) (list? x))
                                   procedure?)
                             (lambda (next t p f)
                               (set! methods (insert-method! methods p f))))))
    (lambda args
      (let ((len (length args)))
        (cond
         ((>= len (vector-length methods))
          (no-applicable-method-error name args))
         (else
          (let lp ((ls (vector-ref methods len)))
            (cond
             ((null? ls)
              (no-applicable-method-error name args))
             ((satisfied? (car (car ls)) args)
              (apply (cdr (car ls)) (lambda () (lp (cdr ls))) args))
             (else
              (lp (cdr ls)))))))))))

(define (insert-method! vec preds f)
  (let ((vlen (vector-length vec))
        (plen (length preds)))
    (let ((res (if (>= plen vlen)
                   (let ((r (make-vector (+ vlen 1) '())))
                     (do ((i 0 (+ i 1)))
                         ((>= i vlen) r)
                       (vector-set! r i (vector-ref vec i))))
                   vec)))
      (vector-set! res plen (cons (cons preds f) (vector-ref res plen)))
      res)))

;;> Extend the generic \var{g} with a new method \var{f}
;;> that applies when all parameters match the given list
;;> of predicates \var{preds}.

(define (generic-add! g preds f)
  (g add-method-tag preds f))

;;> Interface to the filesystem and file descriptor objects.
;;> Note that file descriptors are currently represented as
;;> integers, but may be replaced with opaque (and gc-managed)
;;> objects in a future release.

(define-library (chibi filesystem)
  (export duplicate-file-descriptor duplicate-file-descriptor-to
          close-file-descriptor renumber-file-descriptor
          open-input-file-descriptor open-output-file-descriptor
          delete-file link-file symbolic-link-file rename-file
          directory-files directory-fold directory-fold-tree
          delete-file-hierarchy delete-directory
          create-directory create-directory*
          current-directory change-directory with-directory
          open open-pipe make-fifo
          read-link
          file-status               file-link-status
          file-device               file-inode
          file-mode                 file-num-links
          file-owner                file-group
          file-represented-device   file-size
          file-block-size           file-num-blocks
          file-access-time file-modification-time file-change-time
          file-regular?    file-directory?        file-character?
          file-block?      file-fifo?             file-link?
          file-socket?     file-exists?
          get-file-descriptor-flags   set-file-descriptor-flags!
          get-file-descriptor-status  set-file-descriptor-status!
          open/read        open/write             open/read-write
          open/create      open/exclusive         open/truncate
          open/append      open/non-block
          file-lock        file-truncate
          file-is-readable? file-is-writable? file-is-executable?
          lock/shared lock/exclusive lock/non-blocking lock/unlock
          is-a-tty?)
  (import (chibi) (chibi string))
  (include-shared "filesystem")
  (include "filesystem.scm"))


(define-library (chibi repl)
  (export repl)
  (import (chibi) (only (meta) load-module)
          (chibi ast) (chibi modules) (chibi doc)
          (chibi string) (chibi io) (chibi optional)
          (chibi process) (chibi term edit-line)
          (srfi 1) (srfi 9) (srfi 18) (srfi 38) (srfi 95) (srfi 98))
  (include "repl.scm"))

;;> \subsubsubsection{\scheme{(disasm f [out])}}

;;> Write a human-readable disassembly for the procedure \var{f} to
;;> the port \var{out}, defaulting to \scheme{(current-output-port)}.

(define-library (chibi disasm)
  (export disasm)
  (import (chibi))
  (include-shared "disasm"))

(define-library (chibi regexp)
  (export regexp regexp? valid-sre? rx regexp->sre char-set->sre
          regexp-matches regexp-matches? regexp-search
          regexp-replace regexp-replace-all
          regexp-fold regexp-extract regexp-split
          regexp-match? regexp-match-count
          regexp-match-submatch regexp-match-submatch/list
          regexp-match-submatch-start regexp-match-submatch-end
          regexp-match->list regexp-match->sexp)
  (import (srfi 33) (srfi 69))
  ;; Chibi's char-set library is more factored than SRFI-14.
  (cond-expand
   (chibi
    (import (rename (chibi)
                    (protect guard)
                    (char-downcase %char-downcase)
                    (char-upcase %char-upcase))
            (only (scheme char) char-downcase char-upcase)
            (srfi 9)
            (chibi char-set)
            (chibi char-set full)
            (prefix (chibi char-set ascii) %))
    (begin
      (define char-set:title-case
        (char-set-union
         (ucs-range->char-set #x1F88 #x1F90)
         (ucs-range->char-set #x1F98 #x1FA0)
         (ucs-range->char-set #x1FA8 #x1FB0)
         (char-set #\x01C5 #\x01C8 #\x01CB #\x01F2 #\x1FBC #\x1FCC #\x1FFC)))))
   (else
    (import (scheme base) (scheme char) (srfi 14))
    (begin
      (define %char-set:letter
        (char-set-intersection char-set:ascii char-set:letter))
      (define %char-set:lower-case
        (char-set-intersection char-set:ascii char-set:lower-case))
      (define %char-set:upper-case
        (char-set-intersection char-set:ascii char-set:upper-case))
      (define %char-set:digit
        (char-set-intersection char-set:ascii char-set:digit))
      (define %char-set:letter+digit
        (char-set-intersection char-set:ascii char-set:letter+digit))
      (define %char-set:punctuation
        (char-set-intersection char-set:ascii char-set:punctuation))
      (define %char-set:graphic
        (char-set-intersection char-set:ascii char-set:graphic))
      (define %char-set:whitespace
        (char-set-intersection char-set:ascii char-set:whitespace))
      (define %char-set:printing
        (char-set-intersection char-set:ascii char-set:printing))
      (define %char-set:iso-control
        (char-set-intersection char-set:ascii char-set:iso-control)))))
  (import (chibi char-set boundary))
  ;; Use string-cursors where available.
  (begin
    (define string-cursor? integer?))
  (cond-expand
   (chibi
    (begin
      (define (string-start-arg s o)
        (if (pair? o) (string-index->offset s (car o)) (string-cursor-start s)))
      (define (string-end-arg s o)
        (if (pair? o) (string-index->offset s (car o)) (string-cursor-end s)))
      (define (string-concatenate-reverse ls)
        (string-concatenate (reverse ls)))))
   (else
    (begin
      (define (string-start-arg s o)
        (if (pair? o) (string-index->offset s (car o)) 0))
      (define (string-end-arg s o)
        (if (pair? o) (string-index->offset (car o)) (string-length s)))
      (define string-cursor=? =)
      (define string-cursor<? <)
      (define string-cursor<=? <=)
      (define string-cursor>? >)
      (define string-cursor>=? >=)
      (define string-cursor-ref string-ref)
      (define (string-cursor-next s i) (+ i 1))
      (define (string-cursor-prev s i) (- i 1))
      (define substring-cursor substring)
      (define (string-offset->index str off) off)
      (define (string-index->offset str i) i)
      (define (string-concatenate ls) (apply string-append ls))
      (define (string-concatenate-reverse ls)
        (string-concatenate (reverse ls))))))
  (include "regexp.scm"))

(define (register-lambda-optimization! proc . o)
  (define (optimize ast)
    (match ast
      (($ Set ref value)
       (make-set ref (optimize value)))
      (($ Cnd test pass fail)
       (make-cnd (optimize test) (optimize pass) (optimize fail)))
      (($ Seq ls)
       (make-seq (map optimize ls)))
      (($ Lam name params body)
       (lambda-body-set! ast (optimize body))
       (proc ast))
      ((app ...)
       (map optimize app))
      (else
       ast)))
  (register-optimization! optimize (if (pair? o) (car o) 600)))

(define (replace-references ast name lam new)
  (let replace ((x ast))
    (match x
      (($ Ref _ (n . (? lambda? f)))
       (if (and (eq? n name) (eq? f lam))
           new
           x))
      (($ Set ref value)
       (make-set (replace ref) (replace value)))
      (($ Cnd test pass fail)
       (make-cnd (replace test) (replace pass) (replace fail)))
      (($ Seq ls)
       (make-seq (map replace ls)))
      (($ Lam name params body)
       (lambda-body-set! x (replace body))
       x)
      ((app ...)
       (map replace app))
      (else
       x))))

(define (join-seq a b)
  (make-seq (append (if (seq? a) (seq-ls a) (list a))
                    (if (seq? b) (seq-ls b) (list b)))))

(define (dotted-tail ls)
  (if (pair? ls) (dotted-tail (cdr ls)) ls))

(define (fold-every kons knil ls)
  (if (null? ls)
      knil
      (let ((knil (kons (car ls) knil)))
        (and knil (fold-every kons knil (cdr ls))))))

(define-library (chibi parse)
  (export grammar grammar/unmemoized define-grammar define-grammar/unmemoized
          call-with-parse parse parse-fully parse-fold
          parse->list parse-fully->list
          file->parse-stream string->parse-stream parse-stream-substring
          parse-stream-start? parse-stream-end? parse-stream-ref
          parse-anything parse-nothing parse-epsilon
          parse-seq parse-and parse-or parse-not
          parse-repeat parse-repeat+ parse-optional
          parse-map parse-map-substring parse-ignore parse-assert
          parse-atomic parse-commit parse-memoize
          parse-char parse-not-char parse-char-pred
          parse-string parse-token parse-sre
          parse-beginning parse-end
          parse-beginning-of-line parse-end-of-line
          parse-beginning-of-line parse-end-of-line
          parse-beginning-of-word parse-end-of-word
          parse-word parse-word+
          parse-with-failure-reason
          make-parse-stream)
  (import (chibi) (chibi char-set) (srfi 9))
  (include "parse/parse.scm")
  (cond-expand
   (chibi
    (begin
      (define-syntax grammar-bind
        (er-macro-transformer
         (lambda (expr rename compare)
           (let ((name (cadr expr))
                 (k (car (cddr expr)))
                 (f (cadr (cddr expr)))
                 (bindings (car (cddr (cddr expr)))))
             (if (and (identifier? name)
                      (not (assq name bindings)))
                 (let ((new-tmp (rename 'new-tmp))
                       (save-tmp (rename 'save-tmp))
                       (lambda_ (rename 'lambda))
                       (set!_ (rename 'set!))
                       (s (rename 's))
                       (i (rename 'i))
                       (sk (rename 'sk))
                       (fk (rename 'fk))
                       (r (rename 'r)))
                   (append
                    k
                    (list
                     `(,lambda_
                       (,s ,i ,sk ,fk)
                       ((,lambda_ (,save-tmp)
                                  (,f ,s ,i
                                      (,lambda_ (,r ,s ,i ,fk)
                                                (,set!_ ,new-tmp ,r)
                                                (,sk ,r ,s ,i ,fk))
                                      (,lambda_ (,s ,i ,r)
                                                (,set!_ ,new-tmp ,save-tmp)
                                                (,fk ,s ,i ,r))))
                        ,new-tmp))
                     (cons (list name new-tmp) bindings))))
                 (append k (list f bindings)))))))))
   (else
    (begin
      (define-syntax grammar-bind
        (syntax-rules ()
          ((grammar-bind name (k ...) f ((var tmp) ...))
           (let-syntax ((new-symbol?
                         (syntax-rules (var ...)
                           ((new-symbol? name sk fk) sk)
                           ((new-symbol? _ sk fk) fk))))
             ;; Bind the name only to the first instance in the pattern.
             (new-symbol?
              random-symbol-to-match
              (k ...
                 (lambda (s i sk fk)
                   (let ((save-tmp new-tmp))
                     (f s i
                        (lambda (r s i fk) (set! new-tmp r) (sk r s i fk))
                        (lambda (s i r) (set! new-tmp save-tmp) (fk s i r)))))
                 ((var tmp) ... (name new-tmp)))
              (k ... f ((var tmp) ...)))))))))))

(define (read-u16/be in)
  (let* ((i (read-u8 in))
         (j (read-u8 in)))
    (if (eof-object? j)
        (error "end of input")
        (+ (arithmetic-shift i 8) j))))

(define (read-u16/le in)
  (let* ((i (read-u8 in))
         (j (read-u8 in)))
    (if (eof-object? j)
        (error "end of input")
        (+ (arithmetic-shift j 8) i))))

;; Record types with user-specified binary formats.
;; A work in progress, but sufficient for tar files.

(define (assert-read-u8 in i)
  (let ((i2 (read-u8 in)))
    (if (not (eqv? i i2))
        (error "unexpected value: " i i2)
        i2)))

(define (assert-read-char in ch)
  (let ((ch2 (read-char in)))
    (if (not (eqv? ch ch2))
        (error "unexpected value: " ch ch2)
        ch2)))

(define (assert-read-string in s)
  (let ((s2 (read-string (string-length s) in)))
    (if (not (equal? s s2))
        (error "unexpected value: " s s2)
        s2)))

(define (assert-read-bytevector in bv)
  (let ((bv2 (read-bytevector (bytevector-length bv) in)))
    (if (not (equal? bv bv2))
        (error "unexpected value: " bv bv2)
        bv2)))

(define (assert-read-integer in len radix)
  (let* ((s (string-trim (read-string len in)
                         (lambda (ch) (or (eqv? ch #\space) (eqv? ch #\null)))))
         (n (if (equal? s "") 0 (string->number s radix))))
    (or n (error "invalid number syntax: " s))))

(define (read-padded-string in len pad)
  (string-trim-right (read-string len in) pad))

(define (expand-read rename in spec)
  (case (car spec)
    ((literal)
     (let ((val (cadr spec)))
       (cond ((integer? val) `(,(rename 'assert-read-u8) ,in ,val))
             ((char? val) `(,(rename 'assert-read-char) ,in ,val))
             ((string? val) `(,(rename 'assert-read-string) ,in ,val))
             ((bytevector? val) `(,(rename 'assert-read-bytevector) ,in ,val))
             (else (error "unknown binary literal: " val)))))
    ((u8)
     `(,(rename 'read-u8) ,in))
    ((u16/be)
     `(,(rename 'read-u16/be) ,in))
    ((u16/le)
     `(,(rename 'read-u16/le) ,in))
    ((octal)
     `(,(rename 'assert-read-integer) ,in ,(cadr spec) 8))
    ((decimal)
     `(,(rename 'assert-read-integer) ,in ,(cadr spec) 10))
    ((hexadecimal)
     `(,(rename 'assert-read-integer) ,in ,(cadr spec) 16))
    ((fixed-string)
     (let ((len (cadr spec)))
       `(,(rename 'read-string) ,len ,in)))
    ((padded-string)
     (let ((len (cadr spec))
           (pad (if (pair? (cddr spec)) (car (cddr spec)) #\null)))
       `(,(rename 'read-padded-string) ,in ,len ,pad)))
    (else
     (error "unknown binary format: " spec))))

(define (string-pad-left str len . o)
  (let ((diff (- len (string-length str)))
        (pad-ch (if (pair? o) (car o) #\space)))
    (if (positive? diff)
        (string-append (make-string diff pad-ch) str)
        str)))

(define (string-pad-right str len . o)
  (let ((diff (- len (string-length str)))
        (pad-ch (if (pair? o) (car o) #\space)))
    (if (positive? diff)
        (string-append str (make-string diff pad-ch))
        str)))

(define (write-padded-integer out n radix len left-pad-ch right-pad-ch)
  (let ((s (string-pad-left (number->string n radix) (- len 1) left-pad-ch)))
    (cond
     ((>= (string-length s) len)
      (error "number too large for width" n radix len))
     (else
      (write-string s out)
      (write-char right-pad-ch out)))))

(define (write-u16/be n out)
  (write-u8 (arithmetic-shift n -8) out)
  (write-u8 (bitwise-and n #xFF) out))

(define (write-u16/le n out)
  (write-u8 (bitwise-and n #xFF) out)
  (write-u8 (arithmetic-shift n -8) out))

(define (expand-write rename out val spec)
  (let ((_if (rename 'if))
        (_not (rename 'not))
        (_let (rename 'let))
        (_string-length (rename 'string-length))
        (_write-string (rename 'write-string))
        (_write-bytevector (rename 'write-bytevector))
        (_error (rename 'error))
        (_> (rename '>))
        (_= (rename '=)))
    (case (car spec)
      ((literal)
       (let ((val (cadr spec)))
         (cond ((integer? val) `(,(rename 'write-u8) ,val ,out))
               ((char? val) `(,(rename 'write-char) ,val ,out))
               ((string? val) `(,_write-string ,val ,out))
               ((bytevector? val) `(,_write-bytevector ,val ,out))
               (else (error "unknown binary literal: " val)))))
      ((u8)
       `(,(rename 'write-u8) ,val ,out))
      ((u16/be)
       `(,(rename 'write-u16/be) ,val ,out))
      ((u16/le)
       `(,(rename 'write-u16/le) ,val ,out))
      ((octal)
       `(,(rename 'write-padded-integer) ,out ,val 8 ,(cadr spec) #\0 #\null))
      ((decimal)
       `(,(rename 'write-padded-integer) ,out ,val 10 ,(cadr spec) #\0 #\null))
      ((hexadecimal)
       `(,(rename 'write-padded-integer) ,out ,val 16 ,(cadr spec) #\0 #\null))
      ((fixed-string)
       (let ((len (cadr spec)))
         `(,_if (,_not (,_= ,len (,_string-length ,val)))
              (,_error "wrong field length: " ,val ,len)
              (,_write-string ,val ,out))))
      ((padded-string)
       (let ((len (cadr spec))
             (pad (if (pair? (cddr spec)) (car (cddr spec)) #\null)))
         `(,_let ((l (,_string-length ,val)))
            (,_if (,_> l ,len)
                (,_error "field too large: " ,val ,len)
                (,_write-string (,(rename 'string-pad-right) ,val ,len ,pad)
                                ,out)))))
      (else
       (error "unknown binary format: " spec)))))

(define (expand-assert rename spec x v)
  (let ((_if (rename 'if))
        (_not (rename 'not))
        (_error (rename 'error))
        (_integer? (rename 'integer?))
        (_string? (rename 'string?))
        (_string-length (rename 'string-length))
        (_> (rename '>)))
    (case (car spec)
      ((literal) #t)
      ((u8 u16/be u16/le octal decimal hexadecimal)
       `(,_if (,_not (,_integer? ,v))
            (,_error "expected an integer" ,v)))
      ((fixed-string padded-string)
       (let ((len (cadr spec)))
         `(,_if (,_not (,_string? ,v))
              (,_error "expected a string" ,v)
              (,_if (,_> (,_string-length ,v) ,len)
                  (,_error "string too long" ,v ,len)))))
      (else (error "unknown binary format: " spec)))))

(define (expand-default rename spec)
  (case (car spec)
    ((literal) (cadr spec))
    ((u8 u16/be u16/le octal decimal hexadecimal) 0)
    ((fixed-string) (make-string (cadr spec) #\space))
    ((padded-string) "")
    (else (error "unknown binary format: " spec))))

(define (param-ref ls key . o)
  (cond ((assq key ls) => cadr) ((pair? o) (car o)) (else #f)))

(define (symbol-append a b)
  (string->symbol (string-append (symbol->string a) (symbol->string b))))

(define-record-type Field
  (make-field name get set raw-set spec)
  field?
  (name field-name)
  (get field-get)
  (set field-set)
  (raw-set field-raw-set)
  (spec field-spec))

(define (extract-fields type ls)
  (let lp ((ls ls) (res '()))
    (cond
     ((null? ls)
      (reverse res))
     ((not (pair? (car ls)))
      (lp (cdr ls) (cons (make-field '_ #f #f #f `(literal ,(car ls))) res)))
     (else
      (let* ((name (caar ls))
             (get (or (param-ref (car ls) 'getter)
                      (and (not (eq? name '_))
                           (symbol-append type (symbol-append '- name)))))
             (set (or (param-ref (car ls) 'setter)
                      (and (not (eq? name '_))
                           (symbol-append (symbol-append type '-)
                                          (symbol-append name '-set!)))))
             (raw-set (and set (symbol-append '% set)))
             (spec0 (cadr (car ls)))
             (spec (if (pair? spec0) spec0 (list spec0))))
        (lp (cdr ls) (cons (make-field name get set raw-set spec) res)))))))

(define-syntax define-binary-record-type
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((name (cadr expr))
           (ls (cddr expr)))
       (if (not (and (identifier? name) (every list? ls)))
           (error "invalid syntax: " expr))
       (let* ((type (or (param-ref ls 'type) (symbol-append 'type- name)))
              (pred (or (param-ref ls 'predicate) (symbol-append name '?)))
              (make (or (param-ref ls 'make) (symbol-append 'make- name)))
              (make-spec (if (pair? make) make (list make)))
              (%make (rename (symbol-append '% (car make-spec))))
              (%%make (rename (symbol-append '%% (car make-spec))))
              (reader (or (param-ref ls 'read) (symbol-append 'read- name)))
              (writer (or (param-ref ls 'write) (symbol-append 'write- name)))
              (block (assq 'block ls))
              (_begin (rename 'begin))
              (_define (rename 'define))
              (_define-record-type (rename 'define-record-type))
              (_let (rename 'let)))
         (if (not block)
             (error "missing binary record block: " expr))
         (let* ((fields (extract-fields name (cdr block)))
                (named-fields (filter (lambda (f) (not (eq? '_ (field-name f))))
                                      fields)))
           `(,_begin
             (,_define ,name ',ls)
             (,_define-record-type
              ,type (,%%make) ,pred
              ,@(map
                 (lambda (f)
                   `(,(field-name f) ,(field-get f) ,(field-raw-set f)))
                 named-fields))
             ,@(map
                (lambda (f)
                  `(,_define (,(field-set f) x v)
                     ,(expand-assert rename (field-spec f) 'x 'v)
                     (,(field-raw-set f) x v)))
                named-fields)
             (,_define (,%make)
               (let ((res (,%%make)))
                 ,@(map
                    (lambda (f)
                      `(,(field-raw-set f)
                        res
                        ,(expand-default rename (field-spec f))))
                    named-fields)
                 res))
             (,_define ,make-spec
               (,_let ((res (,%make)))
                 ,@(map
                    (lambda (x)
                      (let ((field (find (lambda (f) (eq? x (field-name f)))
                                         fields)))
                        `(,(field-set field) res ,x)))
                    (cdr make-spec))
                 res))
             (,_define (,reader in)
               (,_let ((res (,%make)))
                 ,@(map
                    (lambda (f)
                      (if (eq? '_ (field-name f))
                          (expand-read rename 'in (field-spec f))
                          `(,(field-set f)
                            res
                            ,(expand-read rename 'in (field-spec f)))))
                    fields)
                 res))
             (,_define (,writer x out)
               ,@(map
                  (lambda (f)
                    (expand-write rename
                                  'out
                                  `(,(field-get f) x)
                                  (field-spec f)))
                  fields)))))))))

;;> Cycle-aware equality.  Returns \scheme{#t} iff \scheme{a} and
;;> \scheme{b} are \scheme{equal?}, including cycles.  Another way
;;> to think of it is they are \scheme{equiv} if they print the
;;> same, assuming all elements can be printed.

(define (equiv? a b)
  (let ((equivs (make-hash-table eq?)))
    (define (get-equivs x)
      (or (hash-table-ref/default equivs x #f)
          (let ((tmp (make-hash-table eq?)))
            (hash-table-set! equivs x tmp)
            tmp)))
    (define (merge! tab x)
      (hash-table-set! tab x tab)
      (cond ((hash-table-ref/default equivs x #f)
             => (lambda (tab2)
                  (hash-table-walk tab2 (lambda (key value)
                                          (hash-table-set! tab key tab)))))))
    (define (equiv? a b)
      (cond
       ((eq? a b))
       ((pair? a)
        (and (pair? b)
             (let ((a-tab (get-equivs a)))
               (hash-table-ref
                a-tab
                b
                (lambda ()
                  (merge! a-tab b)
                  (and (equiv? (car a) (car b))
                       (equiv? (cdr a) (cdr b))))))))
       ((vector? a)
        (and (vector? b)
             (= (vector-length a) (vector-length b))
             (let ((a-tab (get-equivs a)))
               (hash-table-ref
                a-tab
                b
                (lambda ()
                  (merge! a-tab b)
                  (let lp ((i (- (vector-length a) 1)))
                    (or (< i 0)
                        (and (equiv? (vector-ref a i) (vector-ref b i))
                             (lp (- i 1))))))))))
       (else
        (equal? a b))))
    (let ((res (equal?/bounded a b 100000 100000)))
      (and res (or (> res 0) (equiv? a b)) #t))))

(define-library (chibi char-set)
  (import (chibi) (chibi char-set base) (chibi char-set extras))
  (export
   Char-Set char-set? char-set-contains?
   char-set ucs-range->char-set char-set-copy char-set-size
   char-set-fold char-set-for-each
   list->char-set char-set->list string->char-set char-set->string
   char-set-adjoin! char-set-adjoin char-set-union char-set-union!
   char-set-intersection char-set-intersection!
   char-set-difference char-set-difference!
   immutable-char-set char-set-complement
   char-set:empty char-set:ascii char-set:full))
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> General type-inference library.

(define (typed? x)
  (and (lambda? x)
       (lambda-return-type x)))

(define (union-type? a)
  (and (pair? a) (equal? (car a) 'or)))

(define (intersection-type? a)
  (and (pair? a) (equal? (car a) 'and)))

(define (unfinalized-type? a)
  (and (pair? a)
       (or (memq (car a) '(return-type param-type))
           (and (memq (car a) '(and or))
                (any unfinalized-type? (cdr a))))))

(define (finalized-type? a)
  (not (unfinalized-type? a)))

(define (numeric-type? a)
  (or (eq? a Number) (eq? a Flonum) (eq? a Integer)))

(define (procedure-type? a)
  (or (eq? a Opcode)
      (eq? a Procedure)
      (and (pair? a) (eq? (car a) 'lambda))))

(define (type=? a b)
  (cond
   ((and (pair? a) (eq? (car a) 'param-type))
    (and (pair? b) (eq? (car b) 'param-type)
         (eq? (cadr a) (cadr b))
         (eq? (car (cddr a)) (car (cddr b)))))
   ((and (pair? a) (eq? (car a) 'return-type))
    (and (pair? b) (eq? (car b) 'return-type)
         (eq? (cadr a) (cadr b))))
   (else
    (equal? a b))))

(define (type-subset? a b)
  (or (type=? a b)
      (eq? a Object)
      (eq? b Object)
      (and (numeric-type? a) (numeric-type? b))
      (and (procedure-type? a) (procedure-type? b))
      (if (union-type? a)
          (if (union-type? b)
              (lset<= type=? (cdr a) (cdr b))
              (member b (cdr a) type=?))
          (and (union-type? b) (member a (cdr b) type=?)))))

(define (type-not a)
  (match a
    (('not b) b)
    (else (list 'not a))))

;; XXXX check for type hierarchies
(define (type-union a b)
  (cond
   ((type=? a b) a)
   ((or (eq? a Object) (eq? b Object)) Object)
   ((union-type? a)
    (if (union-type? b)
        (cons (car a) (lset-union type=? (cdr a) (cdr b)))
        (cons (car a) (lset-adjoin type=? (cdr a) b))))
   (else (list 'or a b))))

;; XXXX check for conflicts
(define (type-intersection a b)
  (cond
   ((type=? a b) a)
   ((or (eq? a Object) (unfinalized-type? a)) b)
   ((or (eq? b Object) (unfinalized-type? b)) a)
   ((intersection-type? a)
    (if (intersection-type? b)
        (lset-intersection type=? (cdr a) (cdr b))
        (cons (car a) (lset-adjoin type=? (cdr a) b))))
   (else (list 'and a b))))

(define (lambda-param-types-initialize! f)
  (lambda-param-types-set! f (map (lambda (p) (list 'param-type f p))
                                  (lambda-params f))))

(define (lambda-param-type-memq f x)
  (let lp ((p (lambda-params f))
           (t (lambda-param-types f)))
    (and (pair? p)
         (pair? t)
         (if (eq? x (car p))
             t
             (lp (cdr p) (cdr t))))))

(define (lambda-param-type-ref f x)
  (cond ((lambda-param-type-memq f x) => car)
        (else #f)))

(define (lambda-param-type-set! f x y)
  (if (not (pair? (lambda-param-types f)))
      (lambda-param-types-initialize! f))
  (cond ((lambda-param-type-memq f x)
         => (lambda (cell) (set-car! cell y)))))

(define (type-assert x true?)
  (match x
    (((? opcode? f) ($ Ref name (_ . (? lambda? g))))
     (cond
      ((eq? (opcode-class f) (opcode-class pair?))
       (let ((t (type-intersection
                 (lambda-param-type-ref g name)
                 (if true? (opcode-data f) (type-not (opcode-data f))))))
         (lambda-param-type-set! g name t)))))
    ((($ Ref _ ('not . (? procedure? f))) expr)
     (if (eq? f not)
         (type-assert expr (not true?))))
    (else #f)))

(define (type-analyze-expr x)
  (match x
    (($ Lam name params body defs)
     (cond
      ((not (lambda-return-type x))
       (lambda-return-type-set! x (list 'return-type x))
       (lambda-param-types-initialize! x)
       (let ((ret-type (type-analyze-expr body)))
         (lambda-return-type-set! x ret-type)
         (cons 'lambda (cons ret-type (lambda-param-types x)))))))
    (($ Set ref value)
     (type-analyze-expr value)
     (if #f #f))
    (($ Ref name (value . loc))
     (cond
      ((lambda? loc) (lambda-param-type-ref loc name))
      ((procedure? loc)
       (let ((sig (procedure-signature loc)))
         (if (and (pair? sig) (car sig))
             (cons 'lambda sig)
             (list 'return-type (procedure-analysis loc)))))
      (else Object)))
    (($ Cnd test pass fail)
     (let ((test-type (type-analyze-expr test))
           (pass-type (type-analyze-expr pass))
           (fail-type (type-analyze-expr fail)))
       (cond
        ((equal? '(error) pass-type)
         (type-assert test #f)
         fail-type)
        ((equal? '(error) fail-type)
         (type-assert test #t)
         pass-type)
        (else
         (type-union pass-type fail-type)))))
    (($ Seq ls)
     (let lp ((ls ls))
       (cond ((null? (cdr ls))
              (type-analyze-expr (car ls)))
             (else
              (type-analyze-expr (car ls))
              (lp (cdr ls))))))
    (((? opcode? f) args ...)
     (let lp ((p (opcode-param-types f))
              (a args))
       (cond
        ((pair? a)
         (cond
          ((or (pair? p) (opcode-variadic? f))
           (let ((p-type
                  (if (pair? p)
                      (car p)
                      (opcode-param-type f (opcode-num-params f)))))
             (match (car a)
               (($ Ref name (_ . (and g ($ Lam))))
                (let ((t (type-intersection (lambda-param-type-ref g name)
                                            p-type)))
                  (lambda-param-type-set! g name t)))
               (else
                (let ((t (type-analyze-expr (car a))))
                  (cond
                   ((and t p-type
                         (finalized-type? t)
                         (finalized-type? p-type)
                         (not (type-subset? t p-type)))
                    (display "WARNING: incompatible type: "
                             (current-error-port))
                    (write/ss (list x t p-type) (current-error-port))
                    (newline (current-error-port))))
                  t))))
           (lp (and (pair? p) (cdr p)) (cdr a)))
          (else
           (for-each type-analyze-expr a))))))
     (opcode-return-type f))
    ((f args ...)
     (let ((f-type (type-analyze-expr f)))
       ;; XXXX apply f-type to params
       (for-each type-analyze-expr args)
       (cond
        ((and (pair? f-type) (eq? (car f-type) 'lambda))
         (cadr f-type))
        ((and (pair? f-type) (memq (car f-type) '(return-type param-type)))
         f-type)
        (else
         Object))))
    (($ Lit value)
     (type-of value))
    (else
     (type-of x))))

(define (resolve-delayed-type x)
  (let lp ((x x) (seen '()) (default Object))
    (match x
      (('return-type (? lambda? f))
       (if (memq f seen)
           default
           (lp (lambda-return-type f) (cons f seen) default)))
      (('param-type f p)
       (if (member x seen)
           default
           (lp (lambda-param-type-ref f p) (cons x seen) default)))
      (('or y ...)
       (let ((z (find finalized-type? y)))
         (if z
             (let ((default (if (eq? default Object)
                                (lp z seen default)
                                (type-union (lp z seen default) default))))
               (fold type-union
                     default
                     (map (lambda (y1) (lp y1 seen default)) (delete z y))))
             (fold type-union default (map (lambda (y1) (lp y1 seen default)) y)))))
      (('and y ...)
       (fold type-intersection default (map (lambda (y1) (lp y1 seen default)) y)))
      (('not y)
       (list 'not (lp y seen default)))
      (else
       x))))

(define (type-resolve-circularities x)
  (match x
    (($ Lam name params body defs)
     (if (unfinalized-type? (lambda-return-type x))
         (lambda-return-type-set! x (resolve-delayed-type
                                     (lambda-return-type x))))
     (for-each
      (lambda (p t)
        (if (unfinalized-type? t)
            (lambda-param-type-set! x p (resolve-delayed-type t))))
      params
      (lambda-param-types x))
     (type-resolve-circularities (lambda-body x)))
    (($ Set ref value)
     (type-resolve-circularities value))
    (($ Cnd test pass fail)
     (type-resolve-circularities test)
     (type-resolve-circularities pass)
     (type-resolve-circularities fail))
    (($ Seq ls)
     (for-each type-resolve-circularities ls))
    ((app ...)
     (for-each type-resolve-circularities app))
    (else #f)))

(define (type-analyze-module-body name ls)
  (for-each type-analyze-expr ls)
  (for-each type-resolve-circularities ls))

;;> Analyze the types of all bindings in the module \var{name}.

(define (type-analyze-module name)
  (let* ((mod (analyze-module name))
         (ls (and (vector? mod) (module-ast mod))))
    (and ls
         (let ((x (let lp ((ls ls)) ;; first lambda
                    (and (pair? ls)
                         (if (and (set? (car ls))
                                  (lambda? (set-value (car ls))))
                             (set-value (car ls))
                             (lp (cdr ls)))))))
           (if (and x (not (typed? x)))
               (type-analyze-module-body name ls))
           ls))))

;;> Return the type signature for a given source
;;> code expression.

(define (type-analyze sexp . o)
  (type-analyze-expr (apply analyze sexp o)))

(define (opcode-param-types x)
  (let lp ((n (- (opcode-num-params x) 1)) (res '()))
    (if (< n 0)
        res
        (lp (- n 1) (cons (opcode-param-type x n) res)))))

(define (opcode-type x)
  (cons 'lambda (cons (opcode-return-type x) (opcode-param-types x))))

(define (lambda-type x)
  (cons 'lambda (cons (lambda-return-type x) (lambda-param-types x))))

;;> Return the type signature for the procedure \var{x} as
;;> a list whose first element is the return type and whose
;;> remaining arguments are the parameter types.

(define (procedure-signature x . o)
  (define (ast-sig x)
    (cond
     ((lambda? x)
      (cons (lambda-return-type x)
            (if (pair? (lambda-param-types x))
                (lambda-param-types x)
                (lambda-params x))))
     ((seq? x) (ast-sig (last (seq-ls x))))
     ((and (pair? x) (lambda? (car x))) (ast-sig (lambda-body (car x))))
     ;; TODO: improve the type inference so this isn't needed
     ((and (pair? x) (ref? (car x))
           (pair? o) (apply procedure-analysis (ref-name (car x)) o))
      => (lambda (lam)
           (and (lambda? lam)
                (or (lambda-return-type lam)
                    (ast-sig (lambda-body lam))))))
     (else #f)))
  (cond
   ((opcode? x)
    (cdr (opcode-type x)))
   ((macro? x)
    (procedure-signature (macro-procedure x)))
   (else
    (let lp ((count 0))
      (let ((lam (apply procedure-analysis x o)))
        (cond
         ((and lam (not (typed? lam)) (zero? count)
               (containing-module x))
          => (lambda (mod)
               (and (type-analyze-module (car mod))
                    (lp (+ count 1)))))
         (else
          (ast-sig lam))))))))
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A high-level interface to stty and ioctl.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; symbolic representation of attributes

(define stty-lookup (make-hash-table eq?))

(for-each
 (lambda (c)
   (let ((type (cadr c))
         (value (car (cddr c))))
     (hash-table-set! stty-lookup (car c) (cdr c))))

 ;; ripped from the stty man page, then trimmed down to what seemed
 ;; available on most systems

 `(;; characters
   ;;(dsusp    char     ,VDSUSP)   ; CHAR will send a terminal stop signal
   (eof      char     ,VEOF)     ; CHAR will send an EOF (terminate input)
   (eol      char     ,VEOL)     ; CHAR will end the line
   (eol2     char     ,VEOL2)    ; alternate CHAR for ending the line
   (erase    char     ,VERASE)   ; CHAR will erase the last character typed
   (intr     char     ,VINTR)    ; CHAR will send an interrupt signal
   (kill     char     ,VKILL)    ; CHAR will erase the current line
   (lnext    char     ,VLNEXT)   ; CHAR will enter the next character quoted
   (quit     char     ,VQUIT)    ; CHAR will send a quit signal
   (rprnt    char     ,VREPRINT) ; CHAR will redraw the current line
   (start    char     ,VSTART)   ; CHAR will restart output after stopping it
   (stop     char     ,VSTOP)    ; CHAR will stop the output
   (susp     char     ,VSUSP)    ; CHAR will send a terminal stop signal
   (werase   char     ,VWERASE)  ; CHAR will erase the last word typed

   ;; special settings
   (cols     special  #f) ; tell the kernel that the terminal has N columns
   (columns  special  #f) ; same as cols N
   (ispeed   special  #f) ; set the input speed to N
   (line     special  #f) ; use line discipline N
   (min      special  #f) ; with -icanon, set N characters minimum for a completed read
   (ospeed   special  #f) ; set the output speed to N
   (rows     special  #f) ; tell the kernel that the terminal has N rows
   (size     special  #f) ; print the number of rows and columns according to the kernel
   (speed    special  #f) ; print the terminal speed
   (time     special  #f) ; with -icanon, set read timeout of N tenths of a second

   ;; control settings
   (clocal   control  ,CLOCAL)  ; disable modem control signals
   (cread    control  ,CREAD)   ; allow input to be received
   (crtscts  control  ,CRTSCTS) ; enable RTS/CTS handshaking
   (cs5      control  ,CS5)     ; set character size to 5 bits
   (cs6      control  ,CS6)     ; set character size to 6 bits
   (cs7      control  ,CS7)     ; set character size to 7 bits
   (cs8      control  ,CS8)     ; set character size to 8 bits
   (cstopb   control  ,CSTOPB)  ; use two stop bits per character (one with `-')
   (hup      control  ,HUPCL)   ; send a hangup signal when the last process closes the tty
   (hupcl    control  ,HUPCL)   ; same as [-]hup
   (parenb   control  ,PARENB)  ; generate parity bit in output and expect parity bit in input
   (parodd   control  ,PARODD)  ; set odd parity (even with `-')

   ;; input settings
   (brkint   input    ,BRKINT)  ; breaks cause an interrupt signal
   (icrnl    input    ,ICRNL)   ; translate carriage return to newline
   (ignbrk   input    ,IGNBRK)  ; ignore break characters
   (igncr    input    ,IGNCR)   ; ignore carriage return
   (ignpar   input    ,IGNPAR)  ; ignore characters with parity errors
   (imaxbel  input    ,IMAXBEL) ; * beep and do not flush a full input buffer on a character
   (inlcr    input    ,INLCR)   ; translate newline to carriage return
   (inpck    input    ,INPCK)   ; enable input parity checking
   (istrip   input    ,ISTRIP)  ; clear high (8th) bit of input characters
   ;;(iuclc    input    ,IUCLC)   ; * translate uppercase characters to lowercase
   (ixany    input    ,IXANY)   ; * let any character restart output, not only start character
   (ixoff    input    ,IXOFF)   ; enable sending of start/stop characters
   (ixon     input    ,IXON)    ; enable XON/XOFF flow control
   (parmrk   input    ,PARMRK)  ; mark parity errors (with a 255-0-character sequence)
   (tandem   input    ,IXOFF)   ; same as [-]ixoff

   ;; output settings
   ;;(bs0      output   ,BS0) ; backspace delay style, N in [0..1]
   ;;(bs1      output   ,BS1) ; backspace delay style, N in [0..1]
   ;;(cr0      output   ,CR0) ; carriage return delay style, N in [0..3]
   ;;(cr1      output   ,CR1) ; carriage return delay style, N in [0..3]
   ;;(cr2      output   ,CR2) ; carriage return delay style, N in [0..3]
   ;;(cr3      output   ,CR3) ; carriage return delay style, N in [0..3]
   ;;(ff0      output   ,FF0) ; form feed delay style, N in [0..1]
   ;;(ff1      output   ,FF1) ; form feed delay style, N in [0..1]
   ;;(nl0      output   ,NL0) ; newline delay style, N in [0..1]
   ;;(nl1      output   ,NL1) ; newline delay style, N in [0..1]
   (ocrnl    output   ,OCRNL) ; translate carriage return to newline
   ;;(ofdel    output   ,OFDEL) ; use delete characters for fill instead of null characters
   ;;(ofill    output   ,OFILL) ; use fill (padding) characters instead of timing for delays
   ;;(olcuc    output   ,OLCUC) ; translate lowercase characters to uppercase
   (onlcr    output   ,ONLCR) ; translate newline to carriage return-newline
   (onlret   output   ,ONLRET) ; newline performs a carriage return
   (onocr    output   ,ONOCR) ; do not print carriage returns in the first column
   (opost    output   ,OPOST) ; postprocess output
   (tab0     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab1     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab2     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab3     output   #f) ; horizontal tab delay style, N in [0..3]
   (tabs     output   #f) ; same as tab0
   ;;(-tabs    output   #f) ; same as tab3
   ;;(vt0      output   ,VT0) ; vertical tab delay style, N in [0..1]
   ;;(vt1      output   ,VT1) ; vertical tab delay style, N in [0..1]

   ;; local settings
   (crterase local    ,ECHOE)   ; echo erase characters as backspace-space-backspace
   (crtkill  local    ,ECHOKE)  ; kill all line by obeying the echoprt and echoe settings
   ;;(-crtkill local    #f) ; kill all line by obeying the echoctl and echok settings
   (ctlecho  local    ,ECHOCTL) ; echo control characters in hat notation (`^c')
   (echo     local    ,ECHO)    ; echo input characters
   (echoctl  local    ,ECHOCTL) ; same as [-]ctlecho
   (echoe    local    ,ECHOE)   ; same as [-]crterase
   ;;(echok    local    ,ECHOK)   ; echo a newline after a kill character
   (echoke   local    ,ECHOKE)  ; same as [-]crtkill
   (echonl   local    ,ECHONL)  ; echo newline even if not echoing other characters
   ;;(echoprt  local    ,ECHOPRT) ; echo erased characters backward, between `\' and '/'
   (icanon   local    ,ICANON)  ; enable erase, kill, werase, and rprnt special characters
   ;;(iexten   local    ,IEXTEN)  ; enable non-POSIX special characters
   (isig     local    ,ISIG)    ; enable interrupt, quit, and suspend special characters
   (noflsh   local    ,NOFLSH)  ; disable flushing after interrupt and quit special characters
   ;;(prterase local    ,ECHOPRT) ; same as [-]echoprt
   (tostop   local    ,TOSTOP)  ; stop background jobs that try to write to the terminal
   ;;(xcase    local    ,XCASE)   ; with icanon, escape with `\' for uppercase characters

   ;; combination settings
   (LCASE    combine  (lcase))
   (cbreak   combine  (not icanon))
   (cooked   combine  (brkint ignpar istrip icrnl ixon opost isig icanon))
                                        ; also eof and eol characters
                                        ; to their default values
   (crt      combine  (echoe echoctl echoke))
   (dec      combine  (echoe echoctl echoke (not ixany)))
                                        ; also intr ^c erase 0177 kill ^u
   (decctlq  combine  (ixany))
   (ek       combine  ()) ; erase and kill characters to their default values
   (evenp    combine  (parenb (not parodd) cs7))
   ;;(-evenp combine  #f) ; same as -parenb cs8
   (lcase    combine  (xcase iuclc olcuc))
   (litout   combine  (cs8 (not parenb istrip opost)))
   ;;(-litout  combine  #f) ; same as parenb istrip opost cs7
   (nl       combine  (not icrnl onlcr))
   ;;(-nl      combine  #f) ; same as icrnl -inlcr -igncr onlcr -ocrnl -onlret
   (oddp     combine  (parenb parodd cs7))
   (parity   combine  (evenp)) ; same as [-]evenp
   (pass8    combine  (cs8 (not parenb istrip)))
   ;;(-pass8   combine  #f) ; same as parenb istrip cs7
   (raw      combine  (not ignbrk brkint ignpar parmrk
                           inpck istrip inlcr igncr icrnl))
   (ixon     combine  (ixoff ixany imaxbel opost isig icanon)) ;; xcase iuclc
   ;;(time     combine  #f) ; 0
   ;;(-raw     combine  #f) ; same as cooked
   (sane     combine  (cread brkint icrnl imaxbel opost onlcr
                       isig icanon ;; nl0 cr0 bs0 vt0 ff0 ; tab0
                       echo echoe echoctl echoke ;; iexten echok
                       (not ignbrk igncr ixoff ixany inlcr ;; iuclc
                            ocrnl onocr onlret ;; olcuc ofill ofdel
                            echonl noflsh tostop echoprt))) ;; xcase
                                        ; plus all special characters to
                                        ; their default values
   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; high-level interface

;;> \subsubsubsection{\scheme{(stty [port] args ...)}}

;;> Set the terminal attributes for \var{port} (default
;;> \scheme{(current-output-port)}) to \var{attrs}.
;;> Attributes are specified symbolically using the
;;> names from the \rawcode{stty(1)} command.  In addition,
;;> (not args ...) may be used to negate the listed symbols.

(define (stty . args)
  (let* ((port (if (and (pair? args) (port? (car args)))
                   (car args)
                   (current-output-port)))
         (attr (get-terminal-attributes port)))
    ;; parse change requests
    (let lp ((lst (if (and (pair? args) (port? (car args))) (cdr args) args))
             (iflag (term-attrs-iflag attr))
             (oflag (term-attrs-oflag attr))
             (cflag (term-attrs-cflag attr))
             (lflag (term-attrs-lflag attr))
             (invert? #f)
             (return (lambda (iflag oflag cflag lflag)
                       (term-attrs-iflag-set! attr iflag)
                       (term-attrs-oflag-set! attr oflag)
                       (term-attrs-cflag-set! attr cflag)
                       (term-attrs-lflag-set! attr lflag)
                       (set-terminal-attributes! port TCSANOW attr))))
      (define (join old new)
        (if invert? (bitwise-and old (bitwise-not new)) (bitwise-ior old new)))
      (cond
       ((pair? lst)
        (let ((command (car lst)))
          (cond
           ((pair? command) ;; recurse on sub-expr
            (lp command iflag oflag cflag lflag invert?
                (lambda (i o c l) (lp (cdr lst) i o c l invert? return))))
           ((eq? command 'not) ;; toggle current setting
            (lp (cdr lst) iflag oflag cflag lflag (not invert?) return))
           (else
            (let ((x (hash-table-ref/default stty-lookup command #f)))
              (case (and x (car x))
                ((input)
                 (lp (cdr lst) (join iflag (cadr x)) oflag cflag lflag invert? return))
                ((output)
                 (lp (cdr lst) iflag (join oflag (cadr x)) cflag lflag invert? return))
                ((control)
                 (lp (cdr lst) iflag oflag (join cflag (cadr x)) lflag invert? return))
                ((local)
                 (lp (cdr lst) iflag oflag cflag (join lflag (cadr x)) invert? return))
                ((char)
                 ;;(term-attrs-cc-set! attr (cadr x) (or (cadr lst) 0))
                 (lp (cddr lst) iflag oflag cflag lflag invert? return))
                ((combine)
                 (lp (cadr x) iflag oflag cflag lflag invert?
                     (lambda (i o c l) (lp (cdr lst) i o c l invert? return))))
                ((special)
                 (error "special settings not yet supported" command))
                (else
                 (error "unknown stty command" command))))))))
       (else
        (return iflag oflag cflag lflag))))))

;;> Run \var{thunk} with the \scheme{stty} \var{setting}s in effect
;;> during its dynamic extent, resetting the original settings
;;> when it returns.

(define (with-stty setting thunk . o)
  (let* ((port (if (pair? o) (car o) (current-input-port)))
         (orig-attrs (get-terminal-attributes port)))
    (cond
     (orig-attrs
      (dynamic-wind
        (lambda () (stty port setting))
        thunk
        (lambda () (set-terminal-attributes! port TCSANOW orig-attrs))))
     (else
      ;; No terminal attributes means this isn't a tty.
      (thunk)))))

;;> Run \var{thunk} with the "raw" (no canonical or echo) options
;;> needed for a terminal application.

(define (with-raw-io port thunk)
  (with-stty '(not icanon isig echo) thunk port))

;;> Returns the current terminal width in characters of \var{x},
;;> which must be a port or a file descriptor.

(define (get-terminal-width x)
  (let ((ws (ioctl x TIOCGWINSZ)))
    (and ws (winsize-col ws))))

;;> Returns the current terminal dimensions, as a list of character width
;;> and height, of \var{x}, which must be a port or a file descriptor.

(define (get-terminal-dimensions x)
  (let ((ws (ioctl x TIOCGWINSZ)))
    (and ws (list (winsize-col ws) (winsize-row ws)))))

(define-library (chibi equiv)
  (export equiv?)
  (import (chibi))
  (import (srfi 69))
  (include "equiv.scm"))

(define-library (chibi channel)
  (import (chibi) (srfi 9) (srfi 18))
  (export Channel make-channel channel? channel-empty?
          channel-send! channel-receive!)
  (include "channel.scm"))
(define (wait-on-event!) (%call/cc abort))


(define-library (chibi highlight)
  (export highlight highlight-detect-language highlighter-for highlight-style
          highlight-scheme highlight-c highlight-assembly)
  (import (chibi) (srfi 1) (chibi io))
  (include "highlight.scm"))

;;> Syntax to support optional and named keyword arguments.
;;> \scheme{let-optionals[*]} is originally from SCSH, and
;;> \scheme{let-keywords[*]} derived from Gauche.

;; Wrap bindings in temp variables to convert a let* definition to a
;; let definition.

(define-syntax let*-to-let
  (syntax-rules ()
    ((let*-to-let letstar ls (vars ...) ((v . d) . rest) . body)
     (let*-to-let letstar ls (vars ... (v tmp . d)) rest . body))
    ((let*-to-let letstar ls ((var tmp . d) ...) rest . body)
     (letstar ls ((tmp . d) ... . rest)
       (let ((var tmp) ...) . body)))))

;;> \macro{(let-optionals ls ((var default) ... [rest]) body ...)}
;;>
;;> Binding construct similar to \scheme{let}.  The \var{var}s are
;;> bound to fresh locations holding values taken in order from the
;;> list \var{ls}, \var{body} is evaluated in the resulting
;;> environment, and the value(s) of the last expression of \var{body}
;;> returned.  If the length of \var{ls} is shorter than the number of
;;> \var{var}s, then the remaining \var{var}s taken their values from
;;> their corresponding \var{default}s, evaluated in an unspecified
;;> order.  Unused \var{default}s are not evaluated.  If a final
;;> \var{rest} var is specified, then it is bound to any remaining
;;> elements of \var{ls} beyond the length of \var{ls}, otherwise any
;;> extra values are unused.
;;>
;;> Typically used on the dotted rest list at the start of a lambda,
;;> \scheme{let-optionals} is more concise and more efficient than
;;> \scheme{case-lambda} for simple optional argument uses.
;;>
;;> \emph{Example:}
;;> \schemeblock{
;;> (define (copy-port . o)
;;>   (let-optionals o ((in (current-input-port))
;;>                     (out (current-output-port))
;;>                     (n-bytes #f))
;;>     (do ((i 0 (+ i 1))
;;>          (n (read-u8 in) (read-u8 in)))
;;>         ((or (and n-bytes (>= i n-bytes))
;;>              (eof-object? b)))
;;>       (write-u8 b out)))}
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-optionals '(0) ((a 10) (b 11) (c 12))
;;>   (list a b c))}

(define-syntax let-optionals
  (syntax-rules ()
    ((let-optionals ls ((var default) ...) body ...)
     (let*-to-let let-optionals* ls () ((var default) ...) body ...))))

;;> \macro{(let-optionals* ls ((var default) ... [rest]) body ...)}
;;>
;;> \scheme{let*} equivalent to \scheme{let-optionals}.  Any required
;;> \var{default} values are evaluated in left-to-right order, with
;;> all preceding \var{var}s in scope.

;;> \macro{(opt-lambda ((var default) ... [rest]) body ...)}
;;>
;;> Shorthand for
;;> \schemeblock{
;;> (lambda o
;;>   (let-optionals o ((var default) ... [rest])
;;>      body ...))}

(define-syntax opt-lambda
  (syntax-rules ()
    ((opt-lambda vars . body)
     (lambda args (let-optionals args vars . body)))))

;;> \procedure{(keyword-ref ls key [default])}
;;>
;;> Search for the identifier \var{key} in the list \var{ls}, treating
;;> it as a property list of the form \scheme{(key1 val1 key2 val2
;;> ...)}, and return the associated \var{val}.  If not found, return
;;> \var{default}, or \scheme{#f}.

(define (keyword-ref ls key . o)
  (let lp ((ls ls))
    (if (and (pair? ls) (pair? (cdr ls)))
        (if (eq? key (car ls))
            (cadr ls)
            (lp (cddr ls)))
        (and (pair? o) (car o)))))

;;> \macro{(keyword-ref* ls key default)}
;;>
;;> Macro equivalent of \scheme{keyword-ref}, where \var{default} is
;;> only evaluated if \var{key} is not found.

(define-syntax keyword-ref*
  (syntax-rules ()
    ((keyword-ref* ls key default)
     (cond ((memq key ls) => cadr) (else default)))))

(define (symbol->keyword sym)
  (string->symbol (string-append (symbol->string sym) ":")))

(define-syntax let-key*-to-let
  (syntax-rules ()
    ((let-key*-to-let ls (vars ...) ((v d) . rest) . body)
     (let-key*-to-let ls (vars ... (v tmp ,(symbol->keyword 'v) d)) rest
                      . body))
    ((let-key*-to-let ls (vars ...) ((v k d) . rest) . body)
     (let-key*-to-let ls (vars ... (v tmp k d)) rest . body))
    ((let-key*-to-let ls ((var tmp k d) ...) rest . body)
     (let-keywords* ls ((tmp k d) ... . rest)
       (let ((var tmp) ...) . body)))))

;;> \macro{(let-keywords ls ((var [keyword] default) ... [rest]) body ...)}
;;>
;;> Analogous to \scheme{let-optionals}, except instead of binding the
;;> \var{var}s by position they are bound by name, by searching in
;;> \var{ls} with \scheme{keyword-ref*}.  If an optional \var{keyword}
;;> argument is provided it must be an identifier to use as the name,
;;> otherwise \var{var} is used, appending a ":" (colon).  If the name
;;> is not found, \var{var} is bound to \var{default}, even if unused
;;> names remain in \var{ls}.
;;>
;;> If an optional trailing identifier \var{rest} is provided, it is
;;> bound to the list of unused arguments not bound to any \var{var}.
;;>
;;> Note R7RS does not have a disjoint keyword type or auto-quoting
;;> syntax for keywords - they are simply identifiers.  Thus when
;;> passing keyword arguments they must be quoted (or otherwise
;;> dynamically evaluated).
;;>
;;> \emph{Example:}
;;> \example{
;;> (define (make-person . o)
;;>   (let-keywords o ((name "John Doe")
;;>                    (age 0)
;;>                    (occupation job: 'unemployed))
;;>     (vector name age occupation)))
;;>
;;> (list (make-person)
;;>       (make-person 'name: "Methuselah" 'age: 969)
;;>       (make-person 'name: "Dr. Who" 'job: 'time-lord 'age: 1500))
;;> }
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-keywords '(b: 2 a: 1 other: 9)
;;>     ((a 0) (b 0) (c 0) rest)
;;>   (list a b c rest))
;;> }

(define-syntax let-keywords
  (syntax-rules ()
    ((let-keywords ls vars . body)
     (let-key*-to-let ls () vars . body))))

(define (remove-keywords ls keywords)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pair? (cdr ls)))
        (if (memq (car ls) keywords)
            (lp (cddr ls) res)
            (lp (cddr ls) (cons (cadr ls) (cons (car ls) res))))
        (reverse res))))

(define-syntax remove-keywords*
  (syntax-rules ()
    ((remove-keywords* opt-ls (keys ...) ((var key default) . rest))
     (remove-keywords* opt-ls (keys ... key) rest))
    ((remove-keywords* opt-ls (keys ...) ((var default) . rest))
     (remove-keywords* opt-ls (keys ... ,(symbol->keyword* 'var)) rest))
    ((remove-keywords* opt-ls (keys ...) ())
     (remove-keywords opt-ls `(keys ...)))))

;;> \macro{(let-keywords* ls ((var [keyword] default) ... [rest]) body ...)}
;;>
;;> \scheme{let*} equivalent to \scheme{let-keywords*}.  Any required
;;> \var{default} values are evaluated in left-to-right order, with
;;> all preceding \var{var}s in scope.
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-keywords* '(b: 5)
;;>     ((a 1) (b (* a 2)) (c (* b 3)))
;;>   (list a b c))
;;> }

(define-syntax let-keywords*
  (syntax-rules ()
    ((let-keywords* opt-ls () . body)
     (begin . body))
    ((let-keywords* (op . args) vars . body)
     (let ((tmp (op . args)))
       (let-keywords* tmp vars . body)))
    ((let-keywords* opt-ls ((var) (vars . x) ...) . body)
     (let-keywords* opt-ls ((var #f) (vars . x) ...) . body))
    ((let-keywords* opt-ls ((var default) (vars . x) ...) . body)
     (let ((var (keyword-ref* opt-ls (symbol->keyword* 'var) default)))
       (let-keywords* opt-ls ((vars . x) ...) . body)))
    ((let-keywords* opt-ls ((var key default) (vars . x) ...) . body)
     (let ((var (keyword-ref* opt-ls `key default)))
       (let-keywords* opt-ls ((vars . x) ...) . body)))
    ((let-keywords* opt-ls ((vars . x) ... tail) . body)
     (let ((tail (remove-keywords* opt-ls () ((vars . x) ...))))
       (let-keywords* opt-ls ((vars . x) ...) . body)))))

(define-library (chibi app)
  (export parse-option parse-options parse-app run-application
          app-help app-help-command)
  (import (scheme base)
          (scheme write)
          (scheme process-context)
          (srfi 1)
          (chibi config)
          (chibi string))
  (include "app.scm"))

(define-library (chibi crypto rsa)
  (import (scheme base) (srfi 27) (srfi 33)
          (chibi bytevector) (chibi math prime))
  (export make-rsa-key rsa-key-gen rsa-key-gen-from-primes rsa-pub-key
          rsa-encrypt rsa-decrypt rsa-sign rsa-verify rsa-verify?
          rsa-key? rsa-key-bits rsa-key-n rsa-key-e rsa-key-d
          pkcs1-pad pkcs1-unpad)
  (include "rsa.scm"))
;; sha2.scm -- SHA2 digest algorithms
;; Copyright (c) 2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; http://csrc.nist.gov/groups/STM/cavp/documents/shs/sha256-384-512.pdf
;; http://tools.ietf.org/html/rfc6234

;; Note 1: All variables are 32 bit unsigned integers and addition is
;;   calculated modulo 32
;; Note 2: For each round, there is one round constant k[i] and one entry
;;   in the message schedule array w[i], 0  i  63
;; Note 3: The compression function uses 8 working variables, a through h
;; Note 4: Big-endian convention is used when expressing the constants in
;;   this pseudocode, and when parsing message block data from bytes to
;;   words, for example, the first word of the input message "abc" after
;;   padding is #x61626380

;; On a 32-bit machine, these will involve bignum computations
;; resulting in poor performance.  Breaking this down into separate
;; 16-bit computations may help.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities.

;; We fake 32-bit arithmetic by ANDing out the low 32 bits.
(define (u32 n)
  (bitwise-and n #xFFFFFFFF))

;; 32-bit addition.
(define (u32+ a b)
  (u32 (+ a b)))

;; Extract bytes 0..3 of a big-endian 32-bit value.
(define (extract-byte n i)
  (bitwise-and #xFF (arithmetic-shift n (* i -8))))

;; Rotate right in 32 bits.
(define (bitwise-rot-u32 n k)
  (bitwise-ior
   (u32 (arithmetic-shift n (- 32 k)))
   (arithmetic-shift n (- k))))

(define hex integer->hex-string)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The first 32 bits of the fractional parts of the square roots of
;; the first 8 primes 2..19:

(define sha-224-inits
  '#(#xc1059ed8 #x367cd507 #x3070dd17 #xf70e5939
     #xffc00b31 #x68581511 #x64f98fa7 #xbefa4fa4))

;; The second 32 bits of the fractional parts of the square roots of
;; the 9th through 16th primes 23..53.

(define sha-256-inits
  '#(#x6a09e667 #xbb67ae85 #x3c6ef372 #xa54ff53a
     #x510e527f #x9b05688c #x1f83d9ab #x5be0cd19))

;; First 32 bits of the fractional parts of the cube roots of the
;; first 64 primes 2..311:

(define k
  '#(#x428a2f98 #x71374491 #xb5c0fbcf #xe9b5dba5
     #x3956c25b #x59f111f1 #x923f82a4 #xab1c5ed5
     #xd807aa98 #x12835b01 #x243185be #x550c7dc3
     #x72be5d74 #x80deb1fe #x9bdc06a7 #xc19bf174
     #xe49b69c1 #xefbe4786 #x0fc19dc6 #x240ca1cc
     #x2de92c6f #x4a7484aa #x5cb0a9dc #x76f988da
     #x983e5152 #xa831c66d #xb00327c8 #xbf597fc7
     #xc6e00bf3 #xd5a79147 #x06ca6351 #x14292967
     #x27b70a85 #x2e1b2138 #x4d2c6dfc #x53380d13
     #x650a7354 #x766a0abb #x81c2c92e #x92722c85
     #xa2bfe8a1 #xa81a664b #xc24b8b70 #xc76c51a3
     #xd192e819 #xd6990624 #xf40e3585 #x106aa070
     #x19a4c116 #x1e376c08 #x2748774c #x34b0bcb5
     #x391c0cb3 #x4ed8aa4a #x5b9cca4f #x682e6ff3
     #x748f82ee #x78a5636f #x84c87814 #x8cc70208
     #x90befffa #xa4506ceb #xbef9a3f7  #xc67178f2))

(define (sha-224-256 src inits full?)
  (let ((in (cond ((string? src) (open-input-bytevector (string->utf8 src)))
                  ((bytevector? src) (open-input-bytevector src))
                  ((input-port? src) src)
                  (else (error "unknown digest source: " src))))
        (buf (make-bytevector 64 0))
        (w (make-vector 64 0)))
    (let chunk ((i 0)
                (pad #x80)
                (h0 (vector-ref inits 0))
                (h1 (vector-ref inits 1))
                (h2 (vector-ref inits 2))
                (h3 (vector-ref inits 3))
                (h4 (vector-ref inits 4))
                (h5 (vector-ref inits 5))
                (h6 (vector-ref inits 6))
                (h7 (vector-ref inits 7)))
      (let* ((n (read-bytevector! buf in))
             (n (if (eof-object? n) 0 n)))
        ;; Maybe pad.
        (cond
         ((< n 64)
          (let ((len (* 8 (+ i n))))
            (bytevector-u8-set! buf n pad)
            (do ((j (+ n 1) (+ j 1))) ((>= j 64))
              (bytevector-u8-set! buf j 0))
            (cond
             ((< n 56)
              (bytevector-u8-set! buf 63 (extract-byte len 0))
              (bytevector-u8-set! buf 62 (extract-byte len 1))
              (bytevector-u8-set! buf 61 (extract-byte len 2))
              (bytevector-u8-set! buf 60 (extract-byte len 3))
              (bytevector-u8-set! buf 59 (extract-byte len 4))
              (bytevector-u8-set! buf 58 (extract-byte len 5))
              (bytevector-u8-set! buf 57 (extract-byte len 6))
              (bytevector-u8-set! buf 56 (extract-byte len 7)))))))
        ;; Copy block i into the buffer.
        (do ((j 0 (+ j 1)))
            ((= j 16))
          (vector-set! w j (bytevector-u32-ref-be buf (* j 4))))
        ;; Extend the first 16 words into the remaining 48 words
        ;; w[16..63] of the message schedule array:
        (do ((j 16 (+ j 1)))
            ((= j 64))
          (let* ((w15 (vector-ref w (- j 15)))
                 (w2 (vector-ref w (- j 2)))
                 (s0 (bitwise-xor (bitwise-rot-u32 w15 7)
                                  (bitwise-rot-u32 w15 18)
                                  (arithmetic-shift w15 -3)))
                 (s1 (bitwise-xor (bitwise-rot-u32 w2 17)
                                  (bitwise-rot-u32 w2 19)
                                  (arithmetic-shift w2 -10))))
            (vector-set! w j (u32 (+ (vector-ref w (- j 16))
                                     s0
                                     (vector-ref w (- j 7))
                                     s1)))))
        ;; Compression function main loop:
        (let lp ((j 0)
                 (a h0) (b h1)
                 (c h2) (d h3)
                 (e h4) (f h5)
                 (g h6) (h h7))
          (cond
           ((= j 64)
            (let ((a (u32+ h0 a)) (b (u32+ h1 b))
                  (c (u32+ h2 c)) (d (u32+ h3 d))
                  (e (u32+ h4 e)) (f (u32+ h5 f))
                  (g (u32+ h6 g)) (h (u32+ h7 h)))
              (cond
               ((< n 64)
                (if (>= n 56)
                    (chunk (+ i n) 0 a b c d e f g h)
                    (string-append
                     (hex a) (hex b) (hex c) (hex d)
                     (hex e) (hex f) (hex g) (if full? (hex h) ""))))
               (else
                (chunk (+ i 64) pad a b c d e f g h)))))
           (else
            ;; Step - compute the two sigmas and recurse on the new a-h.
            (let* ((s1 (bitwise-xor (bitwise-rot-u32 e 6)
                                    (bitwise-rot-u32 e 11)
                                    (bitwise-rot-u32 e 25)))
                   (ch (bitwise-xor (bitwise-and e f)
                                    (bitwise-and (bitwise-not e) g)))
                   (temp1 (u32 (+ h s1 ch (vector-ref k j) (vector-ref w j))))
                   (s0 (bitwise-xor (bitwise-rot-u32 a 2)
                                    (bitwise-rot-u32 a 13)
                                    (bitwise-rot-u32 a 22)))
                   (maj (bitwise-xor (bitwise-and a b)
                                     (bitwise-and a c)
                                     (bitwise-and b c)))
                   (temp2 (u32+ s0 maj)))
              (lp (+ j 1)
                  (u32+ temp1 temp2) a b c
                  (u32+ d temp1) e f g)))))))))

(define (sha-224 src)
  (sha-224-256 src sha-224-inits #f))

(define (sha-256 src)
  (sha-224-256 src sha-256-inits #t))
;; rsa.scm -- RSA public key cryptography library
;; Copyright (c) 2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; The RSA key type.  The public fields are always present, but the
;; private key d may be #f.
(define-record-type Rsa-Key
  (make-rsa-key bits n e d)
  rsa-key?
  (bits rsa-key-bits)
  (n rsa-key-n)         ; public modulus, the product of two primes
  (e rsa-key-e)         ; public exponent, coptime to (totient n)
  (d rsa-key-d))        ; private exponent, the inverse of e mod (totient n)

(define (rsa-key-gen-from-primes bit-length p q . o)
  (define (choose-exponent phi e)
    (cond ((>= e phi) (error "couldn't find an exponent for " p q))
          ((= 1 (gcd e phi)) e)
          (else (choose-exponent phi (+ e 2)))))
  (let* ((n (* p q))
         (phi (* (- p 1) (- q 1)))
         ;; Default to Fermat's number F4, or if too large the number
         ;; 3, as suggested by RFC 1423.  Ensure it's coprime to phi.
         (e (choose-exponent phi (cond ((pair? o) (car o))
                                       ((< 65537 phi) 65537)
                                       (else 3))))
         (d (modular-inverse e phi)))
    (make-rsa-key bit-length n e d)))

(define (rsa-key-gen . o)
  (let* ((bit-length (if (pair? o) (car o) 128))
         (lo (max 3 (expt 2 (- bit-length 1))))
         (hi (expt 2 bit-length))
         (p (random-prime lo hi))
         (q (random-prime-distinct-from lo hi p)))
    (rsa-key-gen-from-primes bit-length p q)))

;;> Returns a copy of the given key with the private key, if any,
;;> removed.
(define (rsa-pub-key priv-key)
  (make-rsa-key (rsa-key-bits priv-key) (rsa-key-n priv-key)
                (rsa-key-e priv-key) #f))

;; From RFC-1423
(define (pkcs1-pad bv)
  (let ((pad (- 8 (modulo (bytevector-length bv) 8))))
    (bytevector-append bv (make-bytevector pad pad))))

(define (pkcs1-unpad bv)
  (let* ((len (bytevector-length bv))
         (pad (bytevector-u8-ref bv (- len 1))))
    (if (not (<= 1 pad 8))
        (error "not pkcs1 padded" bv)
        (bytevector-copy bv 0 (- len pad)))))

;; Actual encryption and decryption are trivially defined as modular
;; exponentiation.

(define (rsa-encrypt-integer pub-key msg)
  (if (>= msg (rsa-key-n pub-key))
      (error "message larger than modulus" msg (rsa-key-n pub-key)))
  (modular-expt msg (rsa-key-e pub-key) (rsa-key-n pub-key)))

(define (rsa-decrypt-integer priv-key cipher)
  (if (>= cipher (rsa-key-n priv-key))
      (error "cipher larger than modulus"))
  (modular-expt cipher (rsa-key-d priv-key) (rsa-key-n priv-key)))

;; Arbitrary messages are encrypted by converting encoded bytevectors
;; to and from integers.
;; TODO: user emsa-pss encoding

(define (convert-plain f key msg)
  (cond
   ((bytevector? msg)
    (integer->bytevector (f key (bytevector->integer (pkcs1-pad msg)))))
   ((string? msg)
    (convert-plain f key (string->utf8 msg)))
   (else
    (f key msg))))

(define (convert-cipher f key cipher)
  (cond
   ((bytevector? cipher)
    (pkcs1-unpad (integer->bytevector (f key (bytevector->integer cipher)))))
   ((string? cipher)
    (convert-cipher f key (string->utf8 cipher)))
   (else
    (f key cipher))))

;; General API can handle integers, bytevectors, or strings which are
;; converted to utf8 bytevectors.

;;> Encrypts \var{msg} for the given public key \var{pub-key}.
;;> \var{msg} may be an integer or bytevector, in which case the
;;> result is of the same type, or a string, in which case the string
;;> is first coerced to a utf8 encoded bytevector.
(define (rsa-encrypt pub-key msg)
  (if (not (rsa-key-e pub-key))
      (error "can't encrypt without a public key" pub-key)
      (convert-plain rsa-encrypt-integer pub-key msg)))

;;> Decrypts \var{cipher} using the given private key \var{priv-key}.
;;> \var{cipher} may be an integer or bytevector, in which case the
;;> result is of the same type, or a string, in which case the string
;;> is first coerced to a utf8 encoded bytevector.
(define (rsa-decrypt priv-key cipher)
  (if (not (rsa-key-d priv-key))
      (error "can't decrypt without a private key" priv-key)
      (convert-cipher rsa-decrypt-integer priv-key cipher)))

;;> Signs \var{msg} using the given private key \var{priv-key}.
(define (rsa-sign priv-key msg)
  (if (not (rsa-key-d priv-key))
      (error "can't sign without a private key" priv-key)
      (convert-plain rsa-decrypt-integer priv-key msg)))

;;> Returns the verified (decrypted) message for the signature \var{sig}.
(define (rsa-verify pub-key sig)
  (if (not (rsa-key-e pub-key))
      (error "can't verify without a public key" pub-key)
      (convert-cipher rsa-encrypt-integer pub-key sig)))

;;> Returns true iff \var{sig} is a valid signature of \var{msg} for
;;> the given public key \var{pub-key}.
(define (rsa-verify? pub-key msg sig)
  (equal? (if (string? msg) (string->utf8 msg) msg)
          (rsa-verify pub-key sig)))
;; md5.scm -- pure R7RS md5 implementation (originally from hato)
;; Copyright (c) 2009-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; Break computations down into 16-bit words to keep everything in
;; fixnum even on 32-bit machines.

;; All values are in little-endian.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities.

(define (extract-byte n i)
  (bitwise-and #xFF (arithmetic-shift n (* i -8))))

;; integer->hex-string is big-endian, so we adjust here
(define (hex-byte n)
  (if (< n 16)
      (string-append "0" (number->string n 16))
      (number->string n 16)))

(define (hex n)
  (string-append (hex-byte (remainder n 256))
                 (hex-byte (quotient n 256))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 3. MD5 Algorithm Description

;; We begin by supposing that we have a b-bit message as input, and that
;; we wish to find its message digest. Here b is an arbitrary
;; nonnegative integer; b may be zero, it need not be a multiple of
;; eight, and it may be arbitrarily large. We imagine the bits of the
;; message written down as follows:

;;           m_0 m_1 ... m_{b-1}

;; The following five steps are performed to compute the message digest
;; of the message.

;; 3.1 Step 1. Append Padding Bits

;; The message is "padded" (extended) so that its length (in bits) is
;; congruent to 448, modulo 512. That is, the message is extended so
;; that it is just 64 bits shy of being a multiple of 512 bits long.
;; Padding is always performed, even if the length of the message is
;; already congruent to 448, modulo 512.

;; Padding is performed as follows: a single "1" bit is appended to the
;; message, and then "0" bits are appended so that the length in bits of
;; the padded message becomes congruent to 448, modulo 512. In all, at
;; least one bit and at most 512 bits are appended.

;; 3.2 Step 2. Append Length

;; A 64-bit representation of b (the length of the message before the
;; padding bits were added) is appended to the result of the previous
;; step. In the unlikely event that b is greater than 2^64, then only
;; the low-order 64 bits of b are used. (These bits are appended as two
;; 32-bit words and appended low-order word first in accordance with the
;; previous conventions.)

;; At this point the resulting message (after padding with bits and with
;; b) has a length that is an exact multiple of 512 bits. Equivalently,
;; this message has a length that is an exact multiple of 16 (32-bit)
;; words. Let M[0 ... N-1] denote the words of the resulting message,
;; where N is a multiple of 16.

;; 3.3 Step 3. Initialize MD Buffer

;; A four-word buffer (A,B,C,D) is used to compute the message digest.
;; Here each of A, B, C, D is a 32-bit register. These registers are
;; initialized to the following values in hexadecimal, low-order bytes
;; first):

;;           word A: 01 23 45 67
;;           word B: 89 ab cd ef
;;           word C: fe dc ba 98
;;           word D: 76 54 32 10

;; 3.4 Step 4. Process Message in 16-Word Blocks

;; We first define four auxiliary functions that each take as input
;; three 32-bit words and produce as output one 32-bit word.

;;           F(X,Y,Z) = XY v not(X) Z
;;           G(X,Y,Z) = XZ v Y not(Z)
;;           H(X,Y,Z) = X xor Y xor Z
;;           I(X,Y,Z) = Y xor (X v not(Z))

;; In each bit position F acts as a conditional: if X then Y else Z.
;; The function F could have been defined using + instead of v since XY
;; and not(X)Z will never have 1's in the same bit position.) It is
;; interesting to note that if the bits of X, Y, and Z are independent
;; and unbiased, the each bit of F(X,Y,Z) will be independent and
;; unbiased.

;; The functions G, H, and I are similar to the function F, in that they
;; act in "bitwise parallel" to produce their output from the bits of X,
;; Y, and Z, in such a manner that if the corresponding bits of X, Y,
;; and Z are independent and unbiased, then each bit of G(X,Y,Z),
;; H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that
;; the function H is the bit-wise "xor" or "parity" function of its
;; inputs.

;; This step uses a 64-element table T[1 ... 64] constructed from the
;; sine function. Let T[i] denote the i-th element of the table, which
;; is equal to the integer part of 4294967296 times abs(sin(i)), where i
;; is in radians. The elements of the table are given in the appendix.

;; (define T
;;   (do ((i 64 (- i 1))
;;        (ls '()
;;            (cons (u32 (exact (truncate (* 4294967296 (abs (sin i))))))
;;                  ls)))
;;       ((< i 0) (list->vector ls))))

(define T
  '#(0     0       #xd76a #xa478 #xe8c7 #xb756 #x2420 #x70db #xc1bd #xceee
     #xf57c #x0faf #x4787 #xc62a #xa830 #x4613 #xfd46 #x9501 #x6980 #x98d8
     #x8b44 #xf7af #xffff #x5bb1 #x895c #xd7be #x6b90 #x1122 #xfd98 #x7193
     #xa679 #x438e #x49b4 #x0821 #xf61e #x2562 #xc040 #xb340 #x265e #x5a51
     #xe9b6 #xc7aa #xd62f #x105d #x0244 #x1453 #xd8a1 #xe681 #xe7d3 #xfbc8
     #x21e1 #xcde6 #xc337 #x07d6 #xf4d5 #x0d87 #x455a #x14ed #xa9e3 #xe905
     #xfcef #xa3f8 #x676f #x02d9 #x8d2a #x4c8a #xfffa #x3942 #x8771 #xf681
     #x6d9d #x6122 #xfde5 #x380c #xa4be #xea44 #x4bde #xcfa9 #xf6bb #x4b60
     #xbebf #xbc70 #x289b #x7ec6 #xeaa1 #x27fa #xd4ef #x3085 #x0488 #x1d05
     #xd9d4 #xd039 #xe6db #x99e5 #x1fa2 #x7cf8 #xc4ac #x5665 #xf429 #x2244
     #x432a #xff97 #xab94 #x23a7 #xfc93 #xa039 #x655b #x59c3 #x8f0c #xcc92
     #xffef #xf47d #x8584 #x5dd1 #x6fa8 #x7e4f #xfe2c #xe6e0 #xa301 #x4314
     #x4e08 #x11a1 #xf753 #x7e82 #xbd3a #xf235 #x2ad7 #xd2bb #xeb86 #xd391))

(define (md5 src)
  (let ((in (cond ((string? src) (open-input-bytevector (string->utf8 src)))
                  ((bytevector? src) (open-input-bytevector src))
                  ((input-port? src) src)
                  (else (error "unknown digest source: " src))))
        ;; 3.3 Step 3. Initialize MD Buffer
        (buf (make-bytevector 64 0))
        (vec (make-vector 32))
        (A1 #x6745) (A0 #x2301)
        (B1 #xefcd) (B0 #xab89)
        (C1 #x98ba) (C0 #xdcfe)
        (D1 #x1032) (D0 #x5476))
    ;; Process each 16-word block.
    (let lp ((i 0)
             (pad #x80))
      (let* ((n (read-bytevector! buf in))
             (n (if (eof-object? n) 0 n)))
        (cond
         ((< n 64)
          (let ((len (* 8 (+ i n))))
            ;; 3.1 Step 1. Append Padding Bits
            (bytevector-u8-set! buf n pad)
            (do ((j (+ n 1) (+ j 1))) ((>= j 64))
              (bytevector-u8-set! buf j 0))
            ;; 3.2 Step 2. Append Length
            (cond
             ((< n 56)
              (bytevector-u8-set! buf 56 (extract-byte len 0))
              (bytevector-u8-set! buf 57 (extract-byte len 1))
              (bytevector-u8-set! buf 58 (extract-byte len 2))
              (bytevector-u8-set! buf 59 (extract-byte len 3))
              (bytevector-u8-set! buf 60 (extract-byte len 4))
              (bytevector-u8-set! buf 61 (extract-byte len 5))
              (bytevector-u8-set! buf 62 (extract-byte len 6))
              (bytevector-u8-set! buf 63 (extract-byte len 7)))))))
        ;; 3.4 Step 4. Process Message in 16-Word Blocks
        ;;
        ;; Copy block i into X.
        (do ((j 0 (+ j 1)))
            ((= j 16))
          (vector-set! vec (* j 2) (bytevector-u16-ref-le buf (* j 4)))
          (vector-set! vec
                       (+ (* j 2) 1)
                       (bytevector-u16-ref-le buf (+ (* j 4) 2))))
        ;; Save A as AA, B as BB, C as CC, and D as DD.
        (let ((AA0 A0) (AA1 A1)
              (BB0 B0) (BB1 B1)
              (CC0 C0) (CC1 C1)
              (DD0 D0) (DD1 D1)
              (T1 0)   (T0 0))
          (letrec-syntax
              ((add
                (syntax-rules ()
                  ((add d1 d0 a1 a0 b1 b0)
                   (begin
                     (set! d0 (+ a0 b0))
                     (set! d1 (bitwise-and
                               (+ a1 b1 (arithmetic-shift d0 -16))
                               #xFFFF))
                     (set! d0 (bitwise-and d0 #xFFFF))))))
               (rot
                (syntax-rules ()
                  ((rot d1 d0 a1 a0 s)
                   (let ((tmp a1))
                     (set! d1 (bitwise-and
                               (bitwise-ior (arithmetic-shift a1 s)
                                            (arithmetic-shift a1 (- s 32))
                                            (arithmetic-shift a0 (- s 16)))
                               #xFFFF))
                     (set! d0 (bitwise-and
                               (bitwise-ior (arithmetic-shift a0 s)
                                            (arithmetic-shift a0 (- s 32))
                                            (arithmetic-shift tmp (- s 16)))
                               #xFFFF))))))
               (bit-not
                (syntax-rules ()
                  ((bit-not a) (- (expt 2 16) a 1))))
               (FF
                (syntax-rules ()
                  ((FF d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-ior (bitwise-and x1 y1)
                                           (bitwise-and (bit-not x1) z1)))
                     (set! d0 (bitwise-ior (bitwise-and x0 y0)
                                           (bitwise-and (bit-not x0) z0)))
                     ))))
               (GG
                (syntax-rules ()
                  ((GG d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-ior (bitwise-and x1 z1)
                                           (bitwise-and y1 (bit-not z1))))
                     (set! d0 (bitwise-ior (bitwise-and x0 z0)
                                           (bitwise-and y0 (bit-not z0))))
                     ))))
               (HH
                (syntax-rules ()
                  ((HH d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin (set! d1 (bitwise-xor x1 y1 z1))
                          (set! d0 (bitwise-xor x0 y0 z0))))))
               (II
                (syntax-rules ()
                  ((II d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-xor y1 (bitwise-ior x1 (bit-not z1))))
                     (set! d0 (bitwise-xor y0 (bitwise-ior x0 (bit-not z0))))
                     ))))
               (R
                (syntax-rules ()
                  ((R op T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                   (begin
                     (op T1 T0 b1 b0 c1 c0 d1 d0)
                     (add T1 T0 T1 T0
                          (vector-ref vec (+ (* k 2) 1))
                          (vector-ref vec (* k 2)))
                     (add T1 T0 T1 T0
                          (vector-ref T (* i 2))
                          (vector-ref T (+ (* i 2) 1)))
                     (add a1 a0 a1 a0 T1 T0)
                     (rot a1 a0 a1 a0 s)
                     (add a1 a0 a1 a0 b1 b0)))))
               (R1 (syntax-rules ()
                     ((R1 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R FF T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R2 (syntax-rules ()
                     ((R2 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R GG T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R3 (syntax-rules ()
                     ((R3 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R HH T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R4 (syntax-rules ()
                     ((R4 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R II T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)))))
            ;; Round 1: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 0 7 1)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 1 12 2)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 2 17 3)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 3 22 4)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 4 7 5)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 5 12 6)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 6 17 7)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 7 22 8)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 8 7 9)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 9 12 10)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 10 17 11)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 11 22 12)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 12 7 13)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 13 12 14)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 14 17 15)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 15 22 16)
            ;; Round 2: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 1 5 17)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 6 9 18)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 11 14 19)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 0 20 20)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 5 5 21)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 10 9 22)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 15 14 23)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 4 20 24)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 9 5 25)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 14 9 26)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 3 14 27)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 8 20 28)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 13 5 29)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 2 9 30)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 7 14 31)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 12 20 32)
            ;; Round 3: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 5 4 33)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 8 11 34)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 11 16 35)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 14 23 36)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 1 4 37)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 4 11 38)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 7 16 39)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 10 23 40)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 13 4 41)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 0 11 42)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 3 16 43)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 6 23 44)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 9 4 45)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 12 11 46)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 15 16 47)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 2 23 48)
            ;; Round 4: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 0 6 49)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 7 10 50)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 14 15 51)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 5 21 52)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 12 6 53)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 3 10 54)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 10 15 55)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 1 21 56)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 8 6 57)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 15 10 58)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 6 15 59)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 13 21 60)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 4 6 61)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 11 10 62)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 2 15 63)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 9 21 64)
            ;; Then in increment each of the four registers by the
            ;; value it had before this block was started.
            (add A1 A0 A1 A0 AA1 AA0)
            (add B1 B0 B1 B0 BB1 BB0)
            (add C1 C0 C1 C0 CC1 CC0)
            (add D1 D0 D1 D0 DD1 DD0)
            (cond
             ((< n 64)
              ;; 3.5 Step 5. Output
              ;;
              ;;    The message digest produced as output is A, B, C,
              ;;    D. That is, we begin with the low-order byte of A,
              ;;    and end with the high-order byte of D.
              (if (>= n 56)
                  (lp (+ i n) 0)
                  (string-append
                   (hex A0) (hex A1)
                   (hex B0) (hex B1)
                   (hex C0) (hex C1)
                   (hex D0) (hex D1))))
             (else
              (lp (+ i 64) pad)))))))))

;; This completes the description of MD5. A reference implementation in
;; C is given in the appendix.

(define-library (chibi crypto sha2)
  (import (scheme base) (srfi 33) (chibi bytevector))
  (export sha-224 sha-256)
  (include "sha2.scm"))

(define-library (chibi crypto md5)
  (import (scheme base) (srfi 33) (chibi bytevector))
  (export md5)
  (include "md5.scm"))

;; Temporary hack, need to rewrite in pure Scheme.

;;> Gzip compress a file in place, renaming with a .gz suffix.

(define (gzip-file path)
  (system "gzip" path))

;;> Gunzip decompress a file in place, removing any .gz suffix.

(define (gunzip-file path)
  (system "gzip" "-d" path))

;; Utility to filter a bytevector to a process and return the
;; accumulated output as a new bytevector.
(define (process-pipe-bytevector cmd bvec)
  (call-with-process-io
   cmd
   (lambda (pid proc-in proc-out proc-err)
     ;; This could overflow the pipe.
     (write-bytevector bvec proc-in)
     (close-output-port proc-in)
     (let ((res (port->bytevector proc-out)))
       (waitpid pid 0)
       res))))

;;> Gzip compress a string or bytevector in memory.

(define (gzip x)
  (if (string? x)
      (gzip (string->utf8 x))
      (process-pipe-bytevector '("gzip" "-c") x)))

;;> Gunzip decompress a bytevector in memory.

(define (gunzip bvec)
  (process-pipe-bytevector '("gzip" "-c" "-d") bvec))

;;> Gunzip decompress a bytevector in memory if it has been
;;> compressed, or return as-is otherwise.

(define (maybe-gunzip bvec)
  (if (and (>= (bytevector-length bvec) 10)
           (eqv? #x1f (bytevector-u8-ref bvec 0))
           (eqv? #x8b (bytevector-u8-ref bvec 1)))
      (gunzip bvec)
      bvec))

(define-library (srfi 6)
  (export open-input-string open-output-string get-output-string)
  (import (chibi)))

(define-library (srfi 33)
  (export bitwise-not
          bitwise-and   bitwise-ior 
          bitwise-xor   bitwise-eqv
          bitwise-nand  bitwise-nor 
          bitwise-andc1 bitwise-andc2
          bitwise-orc1  bitwise-orc2 
          arithmetic-shift bit-count integer-length
          bitwise-merge 
          bit-set? any-bits-set? all-bits-set?
          first-set-bit
          extract-bit-field test-bit-field? clear-bit-field 
          replace-bit-field  copy-bit-field)
  (import (chibi))
  (include-shared "33/bit")
  (include "33/bitwise.scm"))

(define-library (srfi 69)
  (export hash-table-cell
   make-hash-table hash-table? alist->hash-table
   hash-table-equivalence-function hash-table-hash-function
   hash-table-ref hash-table-ref/default hash-table-set!
   hash-table-delete! hash-table-exists?
   hash-table-update! hash-table-update!/default
   hash-table-size hash-table-keys hash-table-values
   hash-table-walk hash-table-fold hash-table->alist
   hash-table-copy hash-table-merge!
   hash string-hash string-ci-hash hash-by-identity)
  (import (chibi) (srfi 9))
  (include-shared "69/hash")
  (include "69/type.scm" "69/interface.scm"))
;; param.scm -- SRFI-39 parameters
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (parameter-convert param value)
  (let ((proc (parameter-converter param)))
    (if (procedure? proc)
        (proc value)
        value)))

(define (make-parameter init . o)
  (let ((conv (and (pair? o) (car o))))
    (%make-parameter (if conv (conv init) init) conv)))

(define-syntax parameterize
  (syntax-rules ()
    ((parameterize ("step")
                   ((param value p old new) ...)
                   ()
                   body)
     (let ((p param) ...)
       (let ((old (p)) ...
             (new (parameter-convert p value)) ...)
         (dynamic-wind
          (lambda () (p new) ...)
          (lambda () . body)
          (lambda () (p old) ...)))))
    ((parameterize ("step")
                   args
                   ((param value) . rest)
                   body)
     (parameterize ("step")
                   ((param value p old new) . args)
                   rest
                   body))
    ((parameterize ((param value) ...) . body)
     (parameterize ("step")
                   ()
                   ((param value) ...)
                   body))))
;; param.scm -- SRFI-39 parameters
;; Copyright (c) 2010 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (parameter-convert param value)
  (let ((proc (parameter-converter param)))
    (if (procedure? proc)
        (proc value)
        value)))

(define (make-parameter init . o)
  (let ((conv (and (pair? o) (car o))))
    (%make-parameter (if conv (conv init) init) conv)))

(define-syntax parameterize
  (syntax-rules ()
    ((parameterize ("step") old cons-new ((param value ptmp vtmp) ...) () body)
     (let ((ptmp param) ...)
       (let ((vtmp (parameter-convert ptmp value)) ...)
         (let ((old (thread-parameters)))
           (let ((new cons-new))
             (dynamic-wind
                 (lambda () (thread-parameters-set! new))
                 (lambda () . body)
                 (lambda () (thread-parameters-set! old))))))))
    ((parameterize ("step") old cons-new args ((param value) . rest) body)
     (parameterize ("step") old (cons (cons ptmp vtmp) cons-new) ((param value ptmp vtmp) . args) rest body))
    ((parameterize ((param value) ...) . body)
     (parameterize ("step") old (thread-parameters) () ((param value) ...) body))))

(define-library (srfi 8)
  (export receive)
  (import (chibi))
  (body
   (define-syntax receive
     (syntax-rules ()
       ((receive params expr . body)
        (call-with-values (lambda () expr) (lambda params . body)))))))

(define-library (srfi 55)
  (export require-extension)
  (import (chibi))
  (begin
   (define-syntax require-extension
     (syntax-rules ()
       ((require-extension (prefix mod ...))
        (begin (import (prefix mod) ...)))))))

(define-library (srfi 98)
  (export get-environment-variable get-environment-variables)
  (include-shared "98/env"))

(define (record? x)
  (is-a? x Object))

(define (record-rtd x)
  (type-of x))

(define (rtd-name x) (string->symbol (type-name x)))

(define (rtd-parent x) (type-parent x))

(define (rtd-field-names x)
  (list->vector
   (map (lambda (x) (if (pair? x) (cadr x) x)) (type-slots x))))

(define (rtd-all-field-names x)
  (let lp ((x x) (res '()))
    (let ((res (append (vector->list (rtd-field-names x)) res)))
      (let ((p (type-parent x)))
        (if (type? p)
            (lp p res)
            (list->vector res))))))

(define (rtd-field-mutable? rtd x)
  (let lp ((ls (type-slots rtd)))
    (cond ((null? ls)
           (let ((p (type-parent rtd)))
             (if (type? p)
                 (rtd-field-mutable? p x)
                 (error "unknown field" rtd x))))
          ((eq? x (car ls)))
          ((and (pair? (car ls)) (eq? x (cadr (car ls))))
           (not (eq? 'immutable (caar ls))))
          (else (lp (cdr ls))))))

(define (make-rtd name fields . o)
  (let ((parent (and (pair? o) (car o))))
    (register-simple-type name parent (vector->list fields))))

(define (rtd? x)
  (type? x))

(define (rtd-constructor rtd . o)
  (let ((fields (vector->list (if (pair? o) (car o) (rtd-all-field-names rtd))))
        (make (make-constructor (type-name rtd) rtd)))
    (lambda args
      (let ((res (make)))
        (let lp ((a args) (p fields))
          (cond
           ((null? a) (if (null? p) res (error "not enough args" p)))
           ((null? p) (error "too many args" a))
           (else
            (slot-set! rtd res (rtd-field-offset rtd (car p)) (car a))
            (lp (cdr a) (cdr p)))))))))

(define (rtd-predicate rtd)
  (make-type-predicate (type-name rtd) rtd))

(define (field-index-of ls field)
  (let lp ((i 0) (ls ls))
    (cond ((null? ls ) #f)
          ((if (pair? (car ls))
               (eq? field (car (cdar ls)))
               (eq? field (car ls)))
           i)
          (else (lp (+ i 1) (cdr ls))))))

(define (rtd-field-offset rtd field)
  (let ((p (type-parent rtd)))
    (or (and (type? p)
             (rtd-field-offset p field))
        (let ((i (field-index-of (type-slots rtd) field)))
          (and i
               (if (type? p)
                   (+ i (vector-length (rtd-all-field-names p)))
                   i))))))

(define (rtd-accessor rtd field)
  (make-getter (type-name rtd) rtd (rtd-field-offset rtd field)))

(define (rtd-mutator rtd field)
  (if (rtd-field-mutable? rtd field)
      (make-setter (type-name rtd) rtd (rtd-field-offset rtd field))
      (error "can't make mutator for immutable field" rtd field)))


(define-syntax define-record-type
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((id->string (lambda (x) (symbol->string (identifier->symbol x))))
            (name+parent (cadr expr))
            (name (if (pair? name+parent) (car name+parent) name+parent))
            (parent (and (pair? name+parent) (cadr name+parent)))
            (name-str (id->string name))
            (procs (cddr expr))
            (make (car procs))
            (make-name (if (eq? make #t)
                           (string->symbol (string-append "make-" name-str))
                           (if (pair? make) (car make) make)))
            (pred (cadr procs))
            (pred-name (if (eq? pred #t)
                           (string->symbol (string-append name-str "?"))
                           pred))
            (fields (cddr procs))
            (field-names (map (lambda (x) (if (pair? x) (car x) x)) fields))
            (make-fields (if (pair? make) (cdr make) (and (not parent) field-names)))
            (_make (rename '%make))
            (_define (rename 'define))
            (_lambda (rename 'lambda))
            (_let (rename 'let))
            (_register (rename 'register-simple-type))
            (_slot-set! (rename 'slot-set!))
            (_vector->list (rename 'vector->list))
            (_type_slot_offset (rename 'type-slot-offset))
            (_rtd-all-field-names (rename 'rtd-all-field-names)))
       `(,(rename 'begin)
         ;; type
         (,_define ,name (,_register ,name-str ,parent ',field-names))
         ;; predicate
         ,@(if pred-name
               `((,_define ,pred-name
                   (,(rename 'make-type-predicate)
                    ,(id->string pred-name)
                    ,name)))
               '())
         ;; accessors
         ,@(map (lambda (f)
                  (let ((g (if (and (pair? f) (pair? (cdr f)))
                               (cadr f)
                               (string->symbol
                                 (string-append name-str
                                                "-"
                                                (id->string (if (pair? f) (car f) f)))))))
                    (and g
                         `(,_define ,g
                            (,(rename 'make-getter)
                             ,(id->string g)
                             ,name
                             (,_type_slot_offset ,name ',(if (pair? f) (car f) f)))))))
                fields)
         ,@(map (lambda (f)
                  (let ((s (and (pair? f)
                                (if (and (pair? (cdr f)) (pair? (cddr f)))
                                    (car (cddr f))
                                    (string->symbol
                                      (string-append name-str
                                                     "-"
                                                     (id->string (car f))
                                                     "-set!"))))))
                    (and s
                         `(,_define ,s
                            (,(rename 'make-setter)
                             ,(id->string s)
                             ,name
                             (,_type_slot_offset ,name ',(if (pair? f) (car f) f)))))))
                fields)
         ;; constructor
         ,@(if make-name
              (if make-fields
                (let ((fields (map (lambda (f) (cons (rename f) f)) make-fields)))
                  `((,_define ,make-name
                     ,(let lp ((ls fields) (sets '()))
                        (cond
                         ((null? ls)
                          `(,_let ((,_make (,(rename 'make-constructor)
                                            ,(id->string make-name)
                                            ,name)))
                             (,_lambda ,(map car fields)
                               (,_let ((res (,_make)))
                                 ,@sets
                                 res))))
                         (else
                          (let ((field (assq (cdar ls) fields)))
                            (cond
                             ((and (pair? field) (pair? (cdr field)) (pair? (cddr field)))
                              (lp (cdr ls)
                                  (cons (list (car (cddr field)) 'res (cdar ls)) sets)))
                             (else
                              (lp (cdr ls)
                                  (cons `(,_slot-set! ,name res (,_type_slot_offset ,name ',(cdar ls)) ,(caar ls)) sets)))))))))))
                `((,_define ,make-name
                   (,_let ((,_make (,(rename 'make-constructor)
                                    ,(id->string make-name)
                                    ,name)))
                     (,_lambda args
                       (,_let ((res (,_make)))
                         (let lp ((a args)
                                  (p (,_vector->list (,_rtd-all-field-names ,name))))
                           (cond
                            ((null? a)
                             (if (null? p)
                                 res
                                 (error ,(string-append "not enough arguments to " (id->string make-name) ": missing")
                                        p)))
                            ((null? p)
                             (error ,(string-append "too many arguments to " (id->string make-name))
                                    a))
                            (else
                             (,_slot-set! ,name res (,_type_slot_offset ,name (car p)) (car a))
                             (lp (cdr a) (cdr p)))))))))))
              '()))))))

(define-library (srfi 99 records inspection)
  (export record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?)
  (import (chibi) (chibi ast))
  (include "inspection.scm"))

(define-library (srfi 99 records syntactic)
  (export define-record-type)
  (import (chibi) (srfi 99 records inspection))
  (include "syntactic.scm"))

(define-library (srfi 99 records procedural)
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator)
  (import (chibi) (chibi ast) (srfi 99 records inspection))
  (include "procedural.scm"))

(define-library (srfi 99 records)
  (import (srfi 99 records procedural)
          (srfi 99 records inspection)
          (srfi 99 records syntactic))
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator
          record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?
          define-record-type))

(define-library (srfi 27)
  (export random-integer random-real default-random-source
          make-random-source random-source?
          random-source-state-ref random-source-state-set!
          random-source-randomize! random-source-pseudo-randomize!
          random-source-make-integers random-source-make-reals)
  (import (chibi))
  (include-shared "27/rand")
  (include "27/constructors.scm"))

(define current-time get-time-of-day)
(define (time? x) (timeval? (if (pair? x) (car x) x)))

(define (time->seconds x)
  (timeval-seconds (if (pair? x) (car x) x)))

(define (seconds->time x)
  (make-timeval (if (inexact? x) (inexact->exact (round x)) x) 0))

(define (timeout->seconds x)
  (if (time? x) (- (time->seconds x) (time->seconds (current-time))) x))

(define thread-yield! yield!)

(define (thread-result thread)
  (cond
   ((%thread-exception? thread)
    (raise (%thread-end-result thread)))
   (else
    (%thread-end-result thread))))

(define (thread-join! thread . o)
  (let ((timeout (and (pair? o) (car o))))
    (let lp ()
      (cond
       ((%thread-join! thread (timeout->seconds timeout))
        (thread-result thread))
       (else
        (thread-yield!)
        (cond
         ((and timeout (thread-timeout?))
          (if (and (pair? o) (pair? (cdr o)))
              (cadr o)
              (error "timed out waiting for thread" thread)))
         (else
          (lp))))))))

(define (thread-terminate! thread)
  (if (%thread-terminate! thread) ;; need to yield if terminating ourself
      (thread-yield!)))

(define (thread-sleep! timeout)
  (%thread-sleep! (timeout->seconds timeout))
  (thread-yield!))

(define (mutex-lock! mutex . o)
  (let ((timeout (and (pair? o) (car o)))
        (thread (if (and (pair? o) (pair? (cdr o))) (cadr o) #t)))
    (cond
     ((%mutex-lock! mutex (timeout->seconds timeout) thread))
     (else
      (thread-yield!)
      ;; If we timed out, fail.
      (if (thread-timeout?)
          #f
          ;; Otherwise the lock was released, try again.
          (mutex-lock! mutex timeout thread))))))

(define (mutex-unlock! mutex . o)
  (let ((condvar (and (pair? o) (car o)))
        (timeout (if (and (pair? o) (pair? (cdr o))) (cadr o) #f)))
    (cond
     ((%mutex-unlock! mutex condvar (timeout->seconds timeout)))
     (else
      (thread-yield!)
      (not (thread-timeout?))))))

(define (join-timeout-exception? x)
  (and (exception? x)
       (equal? (exception-message x) "timed out waiting for thread")))

;; XXXX flush out exception types
(define (abandoned-mutex-exception? x) #f)
(define (terminated-thread-exception? x) #f)
(define (uncaught-exception? x) #f)
(define (uncaught-exception-reason x) #f)

;; signal runner

(define (signal-runner)
  (let lp ()
    (let ((n (pop-signal!)))
      (cond
       ((integer? n)
        (let ((handler (get-signal-handler n)))
          (if (procedure? handler)
              (handler n))))
       (else
        (thread-sleep! #t))))
    (lp)))
;; types.scm -- thread types
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Mutex
  (%make-mutex name specific thread lock)
  mutex?
  (name mutex-name)
  (specific mutex-specific mutex-specific-set!)
  (thread %mutex-thread %mutex-thread-set!)
  (lock %mutex-lock %mutex-lock-set!))

(define (make-mutex . o)
  (%make-mutex (and (pair? o) (car o)) #f #f #f))

(define-record-type Condition-Variable
  (%make-condition-variable name specific threads)
  condition-variable?
  (name condition-variable-name)
  (specific condition-variable-specific condition-variable-specific-set!)
  (threads %condition-variable-threads %condition-variable-threads-set!))

(define (make-condition-variable . o)
  (%make-condition-variable (and (pair? o) (car o)) #f #f))

(define-library (srfi 95)
  (export sorted? merge merge! sort sort! object-cmp)
  (import (chibi))
  (include-shared "95/qsort")
  (include "95/sort.scm"))
;; sort.scm -- SRFI-95 sorting utilities
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (copy seq)
  (if (vector? seq)
      (let* ((len (vector-length seq))
             (res (make-vector len)))
        (do ((i (- len 1) (- i 1)))
            ((< i 0) res)
          (vector-set! res i (vector-ref seq i))))
      (map (lambda (x) x) seq)))

(define (sort seq . o)
  (let ((less (and (pair? o) (car o)))
        (key (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (sort! (copy seq) less key)))

(define (sorted? seq less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (cond
     ((vector? seq)
      (let ((len (- (vector-length seq) 1)))
        (let lp ((i 0))
          (cond
           ((>= i len) #t)
           ((less (key (vector-ref seq (+ i 1)))
                  (key (vector-ref seq i)))
            #f)
           (else (lp (+ i 1)))))))
     ((null? seq)
      #t)
     ((pair? seq)
      (let lp ((ls1 seq) (ls2 (cdr seq)))
        (cond ((null? ls2) #t)
              ((less (key (car ls2)) (key (car ls1))) #f)
              (else (lp ls2 (cdr ls2))))))
     (else
      (error "sorted?: not a list or vector" seq)))))

(define (merge! ls1 ls2 less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (define (lp prev ls1 ls2 a b less key)
      (cond
       ((less a b)
        (if (null? (cdr ls1))
            (set-cdr! ls1 ls2)
            (lp ls1 (cdr ls1) ls2 (key (car (cdr ls1))) b less key)))
       (else
        (set-cdr! prev ls2)
        (if (null? (cdr ls2))
            (set-cdr! ls2 ls1)
            (lp ls2 (cdr ls2) ls1 (key (car (cdr ls2))) a less key)))))
    (cond
     ((null? ls1) ls2)
     ((null? ls2) ls1)
     (else
      (let ((a (key (car ls1)))
            (b (key (car ls2))))
        (cond
         ((less a b)
          (if (null? (cdr ls1))
              (set-cdr! ls1 ls2)
              (lp ls1 (cdr ls1) ls2 (key (car (cdr ls1))) b less key))
          ls1)
         (else
          (if (null? (cdr ls2))
              (set-cdr! ls2 ls1)
              (lp ls2 (cdr ls2) ls1 (key (car (cdr ls2))) a less key))
          ls2)))))))

(define (merge ls1 ls2 less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (merge! (copy ls1) (copy ls2) less key)))

(define-library (srfi 9)
  (export define-record-type)
  (import (chibi))
  (include "9.scm"))

(define-library (srfi 38)
  (import (chibi) (srfi 69) (chibi ast))
  (export write-with-shared-structure write/ss
          read-with-shared-structure read/ss)
  (include "38.scm"))

(define-library (srfi 16)
  (export case-lambda)
  (import (chibi))
  (begin
   (define-syntax %case
     (syntax-rules ()
       ((%case args len n p ((params ...) . body) . rest)
        (if (= len (length '(params ...)))
            (apply (lambda (params ...) . body) args)
            (%case args len 0 () . rest)))
       ((%case args len n (p ...) ((x . y) . body) . rest)
        (%case args len (+ n 1) (p ... x) (y . body) . rest))
       ((%case args len n (p ...) (y . body) . rest)
        (if (>= len n)
            (apply (lambda (p ... . y) . body) args)
            (%case args len 0 () . rest)))
       ((%case args len n p)
        (error "case-lambda: no cases matched"))))
   (define-syntax case-lambda
     (syntax-rules ()
       ((case-lambda . clauses)
        (lambda args (let ((len (length* args))) (%case args len 0 () . clauses))))))))

(define-library (srfi 26)
  (export cut cute)
  (import (chibi))
  (begin
   (define-syntax %cut
     (syntax-rules (<> <...>)
       ((%cut e? params args)
        (lambda params args))
       ((%cut e? (params ...) (args ...) <> . rest)
        (%cut e? (params ... tmp) (args ... tmp) . rest))
       ((%cut e? (params ...) (args ...) <...>)
        (%cut e? (params ... . tmp) (apply args ... tmp)))
       ((%cut e? (params ...) (args ...) <...> . rest)
        (error "cut: non-terminal <...>"))
       ((%cut #t (params ...) (args ...) x . rest)
        (let ((tmp x)) (%cut #t (params ...) (args ... tmp) . rest)))
       ((%cut #f (params ...) (args ...) x . rest)
        (%cut #f (params ...) (args ... x) . rest))))
   (define-syntax cut
     (syntax-rules () ((cut args ...) (%cut #f () () args ...))))
   (define-syntax cute
     (syntax-rules () ((cute args ...) (%cut #t () () args ...))))))

(define-syntax define-record-type
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((name+parent (cadr expr))
            (name (if (pair? name+parent) (car name+parent) name+parent))
            (parent (and (pair? name+parent) (cadr name+parent)))
            (name-str (symbol->string (identifier->symbol name)))
            (procs (cddr expr))
            (make (caar procs))
            (make-fields (cdar procs))
            (pred (cadr procs))
            (fields (cddr procs))
            (_define (rename 'define))
            (_lambda (rename 'lambda))
            (_let (rename 'let))
            (_register (rename 'register-simple-type))
            (_slot-set! (rename 'slot-set!))
            (_type_slot_offset (rename 'type-slot-offset)))
       ;; catch a common mistake
       (if (eq? name make)
           (error "same binding for record rtd and constructor" name))
       `(,(rename 'begin)
         ;; type
         (,_define ,name (,_register ,name-str ,parent ',(map car fields)))
         ;; predicate
         (,_define ,pred (,(rename 'make-type-predicate)
                          ,(symbol->string (identifier->symbol pred))
                          ,name))
         ;; fields
         ,@(map (lambda (f)
                  (and (pair? f) (pair? (cdr f))
                       `(,_define ,(cadr f)
                          (,(rename 'make-getter)
                           ,(symbol->string
                             (identifier->symbol (cadr f)))
                           ,name
                           (,_type_slot_offset ,name ',(car f))))))
                fields)
         ,@(map (lambda (f)
                  (and (pair? f) (pair? (cdr f)) (pair? (cddr f))
                       `(,_define ,(car (cddr f))
                          (,(rename 'make-setter)
                           ,(symbol->string
                             (identifier->symbol (car (cddr f))))
                           ,name
                           (,_type_slot_offset ,name ',(car f))))))
                fields)
         ;; constructor
         (,_define ,make
           ,(let lp ((ls make-fields) (sets '()))
              (cond
               ((null? ls)
                `(,_let ((%make (,(rename 'make-constructor)
                                 ,(symbol->string (identifier->symbol make))
                                 ,name)))
                   (,_lambda ,make-fields
                     (,_let ((res (%make)))
                       ,@sets
                       res))))
               (else
                (let ((field (assq (car ls) fields)))
                  (cond
                   ((not field)
                    (error "unknown record field in constructor" (car ls)))
                   ((pair? (cddr field))
                    (lp (cdr ls)
                        (cons `(,(car (cddr field)) res ,(car ls)) sets)))
                   (else
                    (lp (cdr ls)
                        (cons `(,_slot-set! ,name res (,_type_slot_offset ,name ',(car ls)) ,(car ls))
                              sets))))))))))))))

(define-library (srfi 2)
  (export and-let*)
  (import (chibi))
  (begin
   (define-syntax and-let*
     (syntax-rules ()
       ((and-let* () . body)
        (begin #t . body))
       ((and-let* ((var expr)))
        expr)
       ((and-let* ((expr)))
        expr)
       ((and-let* (expr))  ; Extension: in SRFI-2 this can only be a var ref
        expr)
       ((and-let* ((var expr) . rest) . body)
        (let ((var expr))
          (and var (and-let* rest . body))))
       ((and-let* ((expr) . rest) . body)
        (and expr (and-let* rest . body)))
       ((and-let* (expr . rest) . body)   ; Same extension as above
        (let ((tmp expr))
          (and tmp (and-let* rest . body))))))))
;; types.scm -- the hash-table record type
;; Copyright (c) 2009-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Hash-Table
  (%make-hash-table buckets size hash-fn eq-fn)
  hash-table?
  (buckets hash-table-buckets hash-table-buckets-set!)
  (size hash-table-size hash-table-size-set!)
  (hash-fn %hash-table-hash-function)
  (eq-fn %hash-table-equivalence-function))

;; interface.scm -- hash-table interface
;; Copyright (c) 2009-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; the non-exported hash-table-cell is the heart of the implemenation

(define (make-hash-table . o)
  (let* ((eq-fn (if (pair? o) (car o) equal?))
         (hash-fn (if (and (pair? o) (pair? (cdr o)))
                      (car (cdr o))
                      (if (eq? eq? eq-fn) hash-by-identity hash))))
    (cond
     ((not (procedure? eq-fn))
      (error "make-hash-table: bad equivalence function" eq-fn))
     ((not (procedure? hash-fn))
      (error "make-hash-table: bad hash function" hash-fn))
     (else
      (%make-hash-table
       (make-vector 23 '())
       0
       (if (eq? hash-fn hash-by-identity) 1 (if (eq? hash-fn hash) 2 hash-fn))
       (if (eq? eq-fn eq?) 1 (if (eq? eq-fn equal?) 2 eq-fn)))))))

(define (hash-table-hash-function table)
  (let ((f (%hash-table-hash-function table)))
    (case f ((1) hash-by-identity) ((2) hash) (else f))))

(define (hash-table-equivalence-function table)
  (let ((f (%hash-table-equivalence-function table)))
    (case f ((1) eq?) ((2) equal?) (else f))))

(define-syntax assert-hash-table
  (syntax-rules ()
    ((assert-hash-table from obj)
     (if (not (hash-table? obj))
         (error (string-append from ": not a Hash-Table") obj)))))

(define (hash-table-ref table key . o)
  (assert-hash-table "hash-table-ref" table)
  (let ((cell (hash-table-cell table key #f)))
    (cond (cell (cdr cell))
          ((pair? o) ((car o)))
          (else (error "hash-table-ref: key not found" key)))))

(define (hash-table-ref/default table key default)
  (assert-hash-table "hash-table-ref/default" table)
  (let ((cell (hash-table-cell table key #f)))
    (if cell (cdr cell) default)))

(define (hash-table-set! table key value)
  (assert-hash-table "hash-table-set!" table)
  (let ((cell (hash-table-cell table key #t)))
    (set-cdr! cell value)))

(define (hash-table-exists? table key)
  (assert-hash-table "hash-table-exists?" table)
  (and (hash-table-cell table key #f) #t))

(define hash-table-update!
  (let ((not-found (cons 'not-found '())))
    (lambda (table key func . o)
      (assert-hash-table "hash-table-update!" table)
      (let ((cell (hash-table-cell table key not-found)))
        (set-cdr! cell (if (eq? not-found (cdr cell))
                           (if (pair? o)
                               (func ((car o)))
                               (error "hash-table-update!: key not found" key))
                           (func (cdr cell))))))))

(define hash-table-update!/default
  (let ((not-found (cons 'not-found '())))
    (lambda (table key func default)
      (assert-hash-table "hash-table-update!/default" table)
      (let ((cell (hash-table-cell table key not-found)))
        (set-cdr! cell (func (if (eq? not-found (cdr cell)) default (cdr cell))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (hash-table-fold table kons knil)
  (assert-hash-table "hash-table-fold" table)
  (let ((vec (hash-table-buckets table)))
    (let lp1 ((i (- (vector-length vec) 1)) (acc knil))
      (if (< i 0)
          acc
          (let lp2 ((ls (vector-ref vec i)) (acc acc))
            (if (null? ls)
                (lp1 (- i 1) acc)
                (lp2 (cdr ls) (kons (car (car ls)) (cdr (car ls)) acc))))))))

(define (hash-table-walk table proc)
  (hash-table-fold table (lambda (k v a) (proc k v)) #f)
  (if #f #f))

(define (hash-table->alist table)
  (hash-table-fold table (lambda (k v a) (cons (cons k v) a)) '()))

(define (hash-table-keys table)
  (hash-table-fold table (lambda (k v a) (cons k a)) '()))

(define (hash-table-values table)
  (hash-table-fold table (lambda (k v a) (cons v a)) '()))

(define (alist->hash-table ls . o)
  (let ((res (apply make-hash-table o)))
    (for-each (lambda (x) (hash-table-set! res (car x) (cdr x))) ls)
    res))

(define (hash-table-merge! a b)
  (hash-table-walk b (lambda (k v) (hash-table-set! a k v)))
  a)

(define (hash-table-copy table)
  (assert-hash-table "hash-table-copy" table)
  (let ((res (make-hash-table (hash-table-equivalence-function table))))
    (hash-table-merge! res table)
    res))

(define-library (srfi 18)
  (export
   current-thread thread? make-thread thread-name
   thread-specific thread-specific-set! thread-start!
   thread-yield! thread-sleep! thread-terminate!
   thread-join! mutex? make-mutex mutex-name
   mutex-specific mutex-specific-set! mutex-state
   mutex-lock! mutex-unlock! condition-variable?
   make-condition-variable condition-variable-name
   condition-variable-specific condition-variable-specific-set!
   condition-variable-signal! condition-variable-broadcast!
   current-time time? time->seconds seconds->time
   current-exception-handler with-exception-handler raise
   join-timeout-exception? abandoned-mutex-exception?
   terminated-thread-exception? uncaught-exception?
   uncaught-exception-reason)
  (cond-expand
   (threads
    (import (chibi) (srfi 9) (chibi ast)
            (except (chibi time) time->seconds seconds->time))
    (include "18/types.scm")
    (include-shared "18/threads")
    (include "18/interface.scm"))
   (else
    (error "chibi was not compiled with threading support"))))

(define-library (srfi 11)
  (export let-values let*-values)
  (import (chibi))
  (begin
   (define-syntax let*-values
     (syntax-rules ()
       ((let*-values () . body)
        (begin . body))
       ((let*-values (((a) expr) . rest) . body)
        (let ((a expr)) (let*-values rest . body)))
       ((let*-values ((params expr) . rest) . body)
        (call-with-values (lambda () expr)
          (lambda params (let*-values rest . body))))))
   (define-syntax let-values
     (syntax-rules ()
       ((let-values ("step") (binds ...) bind expr maps () () . body)
        (let*-values (binds ... (bind expr)) (let maps . body)))
       ((let-values ("step") (binds ...) bind old-expr maps () ((params expr) . rest) . body)
        (let-values ("step") (binds ... (bind old-expr)) () expr maps params rest . body))
       ((let-values ("step") binds (bind ...) expr (maps ...) (x . y) rest . body)
        (let-values ("step") binds (bind ... tmp) expr (maps ... (x tmp)) y rest . body))
       ((let-values ("step") binds (bind ...) expr (maps ...) x rest . body)
        (let-values ("step") binds (bind ... . tmp) expr (maps ... (x tmp)) () rest . body))
       ((let-values ((params expr) . rest) . body)
        (let-values ("step") () () expr () params rest . body))
       ))))

(define-library (srfi 1)
  (export
   xcons cons* make-list list-tabulate list-copy circular-list iota
   proper-list? circular-list? dotted-list? not-pair? null-list? list=
   first second third fourth fifth sixth seventh eighth ninth tenth
   car+cdr take drop take-right drop-right take! drop-right! split-at split-at!
   last last-pair length+ concatenate append! concatenate! reverse!
   append-reverse append-reverse!
   zip unzip1 unzip2 unzip3 unzip4 unzip5 count
   fold unfold pair-fold reduce fold-right unfold-right
   pair-fold-right reduce-right
   append-map append-map! map! pair-for-each filter-map map-in-order
   filter partition remove filter! partition! remove! find find-tail any every
   list-index take-while drop-while take-while! span break span! break!
   delete delete-duplicates delete! delete-duplicates!
   alist-cons alist-copy alist-delete alist-delete!
   lset<= lset= lset-adjoin lset-union lset-union! lset-intersection
   lset-intersection! lset-difference lset-difference! lset-xor lset-xor!
   lset-diff+intersection lset-diff+intersection!)
  (import (chibi))
  (include "1/predicates.scm"
           "1/selectors.scm"
           "1/search.scm"
           "1/misc.scm"
           "1/constructors.scm"
           "1/fold.scm"
           "1/deletion.scm"
           "1/alists.scm"
           "1/lset.scm"))

;; constructors.scm -- random function constructors
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (random-source-make-integers rs)
  (lambda (n) (%random-integer rs n)))

(define (random-source-make-reals rs . o)
  (lambda () (%random-real rs)))

;; alist.scm -- association list utilities
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (alist-cons key value ls) (cons (cons key value) ls))

(define (alist-copy ls) (map (lambda (x) (cons (car x) (cdr x))) ls))

(define (alist-delete key ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (remove (lambda (x) (eq (car x) key)) ls)))

(define alist-delete! alist-delete)

;; lset.scm -- list set library
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (lset<= eq . sets)
  (if (null? sets)
      #t
      (let lp1 ((set1 (car sets)) (sets (cdr sets)))
        (if (null? sets)
            #t
            (let ((set2 (car sets)))
              (let lp2 ((ls set1))
                (if (pair? ls)
                    (and (member (car ls) set2 eq) (lp2 (cdr ls)))
                    (lp1 set2 (cdr sets)))))))))

(define (lset= eq . sets)
  (and (apply lset<= eq sets) (apply lset<= eq (reverse sets))))

(define (lset-adjoin eq set . elts)
  (lset-union2 eq set elts))

(define (lset-union2 eq a b)
  (if (null? b)
      a
      (lset-union2 eq (if (member (car b) a eq) a (cons (car b) a)) (cdr b))))

(define (lset-union eq . sets)
  (reduce (lambda (a b) (lset-union2 eq b a)) '() sets))

(define (lset-intersection eq . sets)
  (reduce (lambda (a b) (filter (lambda (x) (member x a eq)) b)) '() sets))

(define (lset-diff2 eq a b)
  (remove (lambda (x) (member x a eq)) b))

(define (lset-difference eq . sets)
  (reduce (lambda (a b) (lset-diff2 eq a b)) '() sets))

(define (lset-xor eq . sets)
  (reduce (lambda (a b) (append (lset-diff2 eq a b) (lset-diff2 eq b a)))
          '()
          sets))

(define (lset-diff+intersection eq . sets)
  (values (apply lset-difference eq sets) (apply lset-intersection eq sets)))

(define lset-diff+intersection! lset-diff+intersection)
(define lset-xor! lset-xor)
(define lset-difference! lset-difference)
(define lset-intersection! lset-intersection)
(define lset-union! lset-union)
;; deletion.scm -- list deletion utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (delete x ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (if (eq? eq eq?)
        (let lp ((ls ls) (rev '())) ;; fast path for delq
          (let ((tail (memq x ls)))
            (if tail
                (lp (cdr tail) (take-up-to-reverse ls tail rev))
                (if (pair? rev) (append-reverse! rev ls) ls))))
        (remove (lambda (y) (eq x y)) ls))))

(define delete! delete)

(define (delete-duplicates ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let lp ((ls ls) (res '()))
      (if (pair? ls)
          (lp (cdr ls) (if (member (car ls) res eq) res (cons (car ls) res)))
          (reverse! res)))))

(define delete-duplicates! delete-duplicates)
;; constructors.scm -- list construction utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (xcons a b) (cons b a))

(define (cons* x . args)
  (let lp ((rev '()) (x x) (ls args))
    (if (null? ls)
        (append-reverse rev x)
        (lp (cons x rev) (car ls) (cdr ls)))))

(define (list-tabulate n proc)
  (let lp ((n (- n 1)) (res '()))
    (if (< n 0) res (lp (- n 1) (cons (proc n) res)))))

(define (circular-list x . args)
  (let ((res (cons x args)))
    (set-cdr! (last-pair res) res)
    res))

(define (iota count . o)
  (let ((start (if (pair? o) (car o) 0))
        (step (if (and (pair? o) (pair? (cdr o))) (cadr o) 1)))
    (let lp ((i count) (res '()))
      (if (<= i 0)
          res
          (lp (- i 1) (cons (+ start (* (- i 1) step)) res))))))
;; selectors.scm -- extended list selectors
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define first car)
(define second cadr)
(define (third ls)   (car (cdr (cdr ls))))
(define (fourth ls)  (car (cdr (cdr (cdr ls)))))
(define (fifth ls)   (car (cdr (cdr (cdr (cdr ls))))))
(define (sixth ls)   (car (cdr (cdr (cdr (cdr (cdr ls)))))))
(define (seventh ls) (car (cdr (cdr (cdr (cdr (cdr (cdr ls))))))))
(define (eighth ls)  (car (cdr (cdr (cdr (cdr (cdr (cdr ls))))))))
(define (ninth ls)   (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr ls)))))))))
(define (tenth ls)   (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr ls))))))))))

(define (car+cdr x) (values (car x) (cdr x)))

(define (take ls i)
  (let lp ((i i) (ls ls) (res '()))
    (if (<= i 0)
        (reverse! res)
        (lp (- i 1) (cdr ls) (cons (car ls) res)))))

(define (take! ls i)
  (if (<= i 0)
      '()
      (let ((tail (list-tail ls (- i 1))))
        (set-cdr! tail '())
        ls)))

(define (drop ls i)
  (if (<= i 0) ls (drop (cdr ls) (- i 1))))

(define (take-right ls i)
  (drop ls (- (length+ ls) i)))

(define (drop-right ls i)
  (take ls (- (length+ ls) i)))

(define (drop-right! ls i)
  (take! ls (- (length+ ls) i)))

(define (split-at ls i)
  (let lp ((i i) (ls ls) (res '()))
    (if (<= i 0)
        (values (reverse! res) ls)
        (lp (- i 1) (cdr ls) (cons (car ls) res)))))

(define (split-at! ls i)
  (if (<= i 0)
      (values '() ls)
      (let* ((tail (list-tail ls (- i 1)))
             (right (cdr tail)))
        (set-cdr! tail '())
        (values ls right))))

(define (last ls) (if (null? (cdr ls)) (car ls) (last (cdr ls))))
(define (last-pair ls) (if (null? (cdr ls)) ls (last-pair (cdr ls))))

;; predicates.scm -- list prediates
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (proper-list? x)
  (cond ((null? x) #t)
        ((pair? x) (proper-list? (cdr x)))
        (else #f)))

(define (circular-list? x)
  (and (pair? x) (pair? (cdr x))
       (let race ((hare (cdr x)) (tortoise x))
         (or (eq? hare tortoise)
             (and (pair? hare) (pair? (cdr hare))
                  (race (cddr hare) (cdr tortoise)))))))

(define (dotted-list? x)
  (not (proper-list? x)))

(define (not-pair? x) (not (pair? x)))

(define (null-list? x) (null? x)) ; no error

(define (list= eq . lists)
  (let lp1 ((lists lists))
    (or (null? lists)
        (null? (cdr lists))
        (let lp2 ((ls1 (car lists)) (ls2 (cadr lists)))
          (if (null? ls1)
              (and (null? ls2)
                   (lp1 (cdr lists)))
              (and (eq (car ls1) (car ls2))
                   (lp2 (cdr ls1) (cdr ls2))))))))

(define (length+ x)
  (if (not (pair? x))
      0
      (let lp ((hare (cdr x)) (tortoise x) (res 1))
        (and (not (eq? hare tortoise))
             (if (pair? hare)
                 (if (not (pair? (cdr hare)))
                     (+ res 1)
                     (lp (cddr hare) (cdr tortoise) (+ res 2)))
                 res)))))
;; misc.scm -- miscellaneous list utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (map-onto proc ls init)
  (let lp ((ls (reverse ls)) (res init))
    (if (null? ls) res (lp (cdr ls) (cons (proc (car ls)) res)))))

(define (append! . lists) (concatenate! lists))

(define (concatenate lists)
  (let lp ((ls (reverse lists)) (res '()))
    (if (null? ls) res (lp (cdr ls) (append (car ls) res)))))

(define (concatenate! lists)
  (if (null? lists)
      '()
      (let lp ((ls lists))
        (cond ((not (pair? (cdr ls)))
               (car lists))
              (else
               (set-cdr! (last-pair (car ls)) (cadr ls))
               (lp (cdr ls)))))))

(define (append-reverse rev tail)
  (if (null? rev) tail (append-reverse (cdr rev) (cons (car rev) tail))))

(define (append-reverse! rev tail)
  (if (null? rev)
      tail
      (let ((head (reverse! rev)))
        (set-cdr! rev tail)
        head)))

(define (zip . lists) (apply map list lists))

(define (unzip1 ls) (map first ls))
(define (unzip2 ls) (values (map first ls) (map second ls)))
(define (unzip3 ls) (values (map first ls) (map second ls) (map third ls)))
(define (unzip4 ls)
  (values (map first ls) (map second ls) (map third ls) (map fourth ls)))
(define (unzip5 ls)
  (values (map first ls) (map second ls) (map third ls) (map fourth ls)
          (map fifth ls)))

(define (count pred ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (res 0))
        (if (pair? ls) (lp (cdr ls) (if (pred (car ls)) (+ res 1) res)) res))
      (let lp ((lists (cons ls lists)) (res 0))
        (if (every pair? lists)
            (lp (map cdr lists) (if (apply pred (map car lists)) (+ res 1) res))
            res))))
;; fold.scm -- list fold/reduce utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (fold kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (acc knil))
        (if (pair? ls) (lp (cdr ls) (kons (car ls) acc)) acc))
      (let lp ((lists (cons ls lists)) (acc knil))
        (if (every pair? lists)
            (lp (map cdr lists) (apply kons (map-onto car lists (list acc))))
            acc))))

(define (fold-right kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls))
        (if (pair? ls) (kons (car ls) (lp (cdr ls))) knil))
      (let lp ((lists (cons ls lists)))
        (if (every pair? lists)
            (apply kons (map-onto car lists (list (lp (map cdr lists)))))
            knil))))

(define (pair-fold kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (acc knil))
        (if (pair? ls) (lp (cdr ls) (kons ls acc)) acc))
      (let lp ((lists (cons ls lists)) (acc knil))
        (if (every pair? lists)
            (lp (map cdr lists) (apply kons (append lists (list acc))))
            acc))))

(define (pair-fold-right kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls))
        (if (pair? ls) (kons ls (lp (cdr ls))) knil))
      (let lp ((lists (cons ls lists)))
        (if (every pair? lists)
            (apply kons (append lists (list (lp (map cdr lists)))))
            knil))))

(define (reduce f identity ls)
  (if (null? ls) identity (fold f (car ls) (cdr ls))))

(define (reduce-right f identity ls)
  (if (null? ls) identity (fold-right f (car ls) (cdr ls))))

(define (unfold p f g seed . o)
  (let lp ((seed seed))
    (if (p seed)
        (if (pair? o) ((car o) seed) '())
        (cons (f seed) (lp (g seed))))))

(define (unfold-right p f g seed . o)
  (let lp ((seed seed) (res (if (pair? o) (car o) '())))
    (if (p seed) res (lp (g seed) (cons (f seed) res)))))

(define (append-map-helper append f ls lists)
  (if (null? lists)
      (if (null? ls)
          '()
          (let lp ((ls (reverse ls)) (res '()))
            (if (null? ls) res (lp (cdr ls) (append (f (car ls)) res)))))
      (if (and (pair? ls) (every pair? lists))
          (let lp ((lists (cons ls lists)))
            (let ((vals (apply f (map car lists)))
                  (cdrs (map cdr lists)))
              (if (every pair? cdrs) (append vals (lp cdrs)) vals)))
          '())))

(define (append-map f ls . lists)
  (append-map-helper append f ls lists))

(define (append-map! f ls . lists)
  (append-map-helper append! f ls lists))

(define map! map)
(define map-in-order map)

(define (pair-for-each f ls . lists)
  (apply pair-fold (lambda (x _) (f x)) #f ls lists))

(define (filter-map f ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (res '()))
        (if (pair? ls)
            (let ((x (f (car ls)))) (lp (cdr ls) (if x (cons x res) res)))
            (reverse! res)))
      (filter (lambda (x) x) (apply map f ls lists))))

(define (take-up-to-reverse from to init)
  (if (eq? from to)
      init
      (take-up-to-reverse (cdr from) to (cons (car from) init))))

(define (remove pred ls)
  (let lp ((ls ls) (rev '()))
    (let ((tail (find-tail pred ls)))
      (if tail
          (lp (cdr tail) (take-up-to-reverse ls tail rev))
          (if (pair? rev) (append-reverse! rev ls) ls)))))

(define (filter pred ls) (remove (lambda (x) (not (pred x))) ls))

(define (partition pred ls)
  (let lp ((ls ls) (good '()) (bad '()))
    (cond ((null? ls) (values (reverse! good) (reverse! bad)))
          ((pred (car ls)) (lp (cdr ls) (cons (car ls) good) bad))
          (else (lp (cdr ls) good (cons (car ls) bad))))))

(define filter! filter)
(define remove! remove)
(define partition! partition)

;; search.scm -- list searching and splitting
;; Copyright (c) 2009-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (take-while pred ls)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pred (car ls)))
        (lp (cdr ls) (cons (car ls) res))
        (reverse! res))))

(define take-while! take-while)

(define (drop-while pred ls)
  (or (find-tail (lambda (x) (not (pred x))) ls) '()))

(define (span pred ls)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pred (car ls)))
        (lp (cdr ls) (cons (car ls) res))
        (values (reverse! res) ls))))

(define span! span)

(define (break pred ls) (span (lambda (x) (not (pred x))) ls))

(define break! break)

(define (list-index pred ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (n 0))
        (and (pair? ls) (if (pred (car ls)) n (lp (cdr ls) (+ n 1)))))
      (let lp ((lists (cons ls lists)) (n 0))
        (and (every pair? lists)
             (if (apply pred (map car lists)) n (lp (map cdr lists) (+ n 1)))
             ))))

(define-library (srfi 99)
  (import (srfi 99 records))
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator
          record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?
          define-record-type))

(define-library (srfi 39)
  (export make-parameter parameterize)
  (import (chibi))
  (include-shared "39/param")
  (cond-expand
   (threads
    (include "39/syntax.scm"))
   (else
    (include "39/syntax-no-threads.scm"))))
;; bitwise.scm -- high-level bitwise functions
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (bitwise-not i) (- -1 i))

(define (bitwise-complement f) (lambda args (bitwise-not (apply f args))))

(define (make-nary proc2 default)
  (lambda args
    (if (null? args)
        default
        (let lp ((i (car args)) (ls (cdr args)))
          (if (null? ls)
              i
              (lp (proc2 i (car ls)) (cdr ls)))))))

(define bitwise-and  (make-nary bit-and  -1))
(define bitwise-ior  (make-nary bit-ior   0))
(define bitwise-xor  (make-nary bit-xor   0))

(define bitwise-eqv  (bitwise-complement (make-nary bit-xor -1)))
(define bitwise-nand (bitwise-complement (make-nary bit-and  0)))
(define bitwise-nor  (bitwise-complement (make-nary bit-ior -1)))

(define (bitwise-andc1 i j) (bit-and (bitwise-not i) j))
(define (bitwise-andc2 i j) (bit-and i (bitwise-not j)))
(define (bitwise-orc1 i j)  (bit-ior (bitwise-not i) j))
(define (bitwise-orc2 i j)  (bit-ior i (bitwise-not j)))

(define (any-bits-set? test-bits i)
  (not (zero? (bitwise-and test-bits i))))
(define (all-bits-set? test-bits i)
  (= test-bits (bitwise-and test-bits i)))

(define (first-set-bit i)
  (if (zero? i)
      -1
      (integer-length (- i (bit-and i (- i 1))))))

(define (mask len) (- (arithmetic-shift 1 len) 1))

(define (bitwise-merge mask n m)
  (bit-ior (bit-and mask n) (bit-and (bitwise-not mask) m)))

(define (extract-bit-field size position n)
  (bit-and (arithmetic-shift n (- position)) (mask size)))

(define (test-bit-field? size position n)
  (not (zero? (bit-and (arithmetic-shift n (- position)) (mask size)))))

(define (replace-bit-field size position newfield n)
  (bit-ior (bit-and n (bitwise-not (arithmetic-shift (mask size) position)))
           (arithmetic-shift newfield position)))

(define (clear-bit-field size position n)
  (replace-bit-field size position 0 n))

(define (copy-bit-field size position from to)
  (bitwise-merge (arithmetic-shift (mask size) position) to from))


(define-library (srfi 46)
  (import (chibi))
  (export syntax-rules))
;;;; srfi-38.scm - reading and writing shared structures
;;
;; This code was written by Alex Shinn in 2009 and placed in the
;; Public Domain.  All warranties are disclaimed.

(define (raise-typed-error type)
  (lambda (msg . args) (raise (make-exception type msg args #f #f))))
(define read-error (raise-typed-error 'read))
(define read-incomplete-error (raise-typed-error 'read-incomplete))

(define (extract-shared-objects x cyclic-only?)
  (let ((seen (make-hash-table eq?)))
    ;; find shared references
    (let find ((x x))
      (let ((type (type-of x)))
        (cond ;; only interested in pairs, vectors and records
         ((or (pair? x) (vector? x) (and type (type-printer type)))
          ;; increment the count
          (hash-table-update!/default seen x (lambda (n) (+ n 1)) 0)
          ;; walk if this is the first time
          (cond
           ((> (hash-table-ref seen x) 1))
           ((pair? x)
            (find (car x))
            (find (cdr x)))
           ((vector? x)
            (do ((i 0 (+ i 1)))
                ((= i (vector-length x)))
              (find (vector-ref x i))))
           (else
            (let ((num-slots (type-num-slots type)))
              (let lp ((i 0))
                (cond ((< i num-slots)
                       (find (slot-ref type x i))
                       (lp (+ i 1))))))))
          ;; delete if this shouldn't count as a shared reference
          (if (and cyclic-only?
                   (<= (hash-table-ref/default seen x 0) 1))
              (hash-table-delete! seen x))))))
    ;; extract shared references
    (let ((res (make-hash-table eq?)))
      (hash-table-walk
       seen
       (lambda (k v) (if (> v 1) (hash-table-set! res k #t))))
      res)))

(define (write-with-shared-structure x . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (shared
         (extract-shared-objects x (and (pair? o) (pair? (cdr o)) (cadr o))))
        (count 0))
    (define (check-shared x prefix cont)
      (let ((index (hash-table-ref/default shared x #f)))
        (cond ((integer? index)
               (display prefix out)
               (display "#" out)
               (write index out)
               (display "#" out))
              (else
               (cond (index
                      (display prefix out)
                      (display "#" out)
                      (write count out)
                      (display "=" out)
                      (hash-table-set! shared x count)
                      (set! count (+ count 1))))
               (cont x index)))))
    (let wr ((x x))
      (check-shared
       x
       ""
       (lambda (x shared?)
         (cond
          ((pair? x)
           (display "(" out)
           (wr (car x))
           (let lp ((ls (cdr x)))
             (check-shared
              ls
              " . "
              (lambda (ls shared?)
                (cond ((null? ls))
                      ((pair? ls)
                       (cond
                        (shared?
                         (display "(" out)
                         (wr (car ls))
                         (check-shared
                          (cdr ls)
                          " . "
                          (lambda (ls shared?) (lp ls)))
                         (display ")" out))
                        (else
                         (display " " out)
                         (wr (car ls))
                         (lp (cdr ls)))))
                      (else
                       (display " . " out)
                       (wr ls))))))
           (display ")" out))
          ((vector? x)
           (display "#(" out)
           (let ((len (vector-length x)))
             (cond ((> len 0)
                    (wr (vector-ref x 0))
                    (do ((i 1 (+ i 1)))
                        ((= i len))
                      (display " " out)
                      (wr (vector-ref x i))))))
           (display ")" out))
          ((let ((type (type-of x)))
             (and (type? type) (type-printer type)))
           => (lambda (printer) (printer x wr out)))
          ((null? x) (display "()" out))
          ((char? x) (display "#\\" out) (write-char x out))
          ((symbol? x) (display (symbol->string x) out))
          ((number? x) (display (number->string x) out))
          ((eq? x #t) (display "#t" out))
          ((eq? x #f) (display "#f" out))
          (else
           ;; (display "#<unknown>" out)
           (write x out))))))))

(define write/ss write-with-shared-structure)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (skip-line in)
  (let ((c (read-char in)))
    (if (not (or (eof-object? c) (eqv? c #\newline)))
        (skip-line in))))

(define (skip-whitespace in)
  (case (peek-char in)
    ((#\space #\tab #\newline #\return)
     (read-char in)
     (skip-whitespace in))
    ((#\;)
     (skip-line in)
     (skip-whitespace in))))

(define (skip-comment in depth)
  (case (read-char in)
    ((#\#) (skip-comment in (if (eqv? #\| (peek-char in)) (+ depth 1) depth)))
    ((#\|) (if (eqv? #\# (peek-char in))
               (if (zero? depth) (read-char in) (skip-comment in (- depth 1)))
               (skip-comment in depth)))
    (else (if (eof-object? (peek-char in))
              (read-incomplete-error "unterminated #| comment")
              (skip-comment in depth)))))

;; returns #f if a trailing # was consumed
(define (skip-whitespace-and-sexp-comments in read)
  (skip-whitespace in)
  (cond
   ((eqv? #\# (peek-char in))
    (read-char in)
    (cond ((eqv? #\; (peek-char in))
           (read-char in)
           (read in)
           (skip-whitespace-and-sexp-comments in read))
          (else #f)))
   (else
    #t)))

(define delimiters
  '(#\; #\" #\| #\( #\) #\{ #\} #\space #\tab #\newline #\return))

(define named-chars
  `(("newline" . #\newline)
    ("return" . #\return)
    ("space" . #\space)
    ("tab" . #\tab)
    ("null" . ,(integer->char 0))
    ("alarm" . ,(integer->char 7))
    ("backspace" . ,(integer->char 8))
    ("escape" . ,(integer->char 27))
    ("delete" . ,(integer->char 127))))

(define read-with-shared-structure
  (let ((read read))
    (lambda o
      (let ((in (if (pair? o) (car o) (current-input-port)))
            (shared '()))
        (define (read-label res)
          (let ((c (peek-char in)))
            (cond
             ((and (not (eof-object? c))
                   (or (char-numeric? c)
                       (memv (char-downcase c)
                             '(#\- #\+ #\a #\b #\c #\d #\e #\f #\i))))
              (read-label (cons (read-char in) res)))
             ((and (eqv? c #\/) (not (memv #\/ res)))
              (read-label (cons (read-char in) res)))
             (else
              (list->string (reverse res))))))
        (define (read-number base)
          (let* ((str (read-label '()))
                 (n (string->number str base))
                 (c (peek-char in)))
            (if (or (not n) (not (or (eof-object? c) (memv c delimiters))))
                (read-error "read error: invalid number syntax" str c)
                n)))
        (define (read-float-tail in) ;; called only after a leading period
          (let lp ((res 0.0) (k 0.1))
            (let ((c (peek-char in)))
              (cond
               ((char-numeric? c)
                (lp (+ res (* (- (char->integer (read-char in))
                                 (char->integer #\0))
                              k))
                    (* k 0.1)))
               ((or (eof-object? c) (memv c delimiters)) res)
               (else (read-error "invalid char in float syntax" c))))))
        (define (read-name c in)
          (let lp ((ls (if (char? c) (list c) '())))
            (let ((c (peek-char in)))
              (cond ((or (eof-object? c) (memv c delimiters))
                     (list->string (reverse ls)))
                    (else (lp (cons (read-char in) ls)))))))
        (define (read-named-char c in)
          (let ((name (read-name c in)))
            (cond ((assoc name named-chars string-ci=?) => cdr)
                  ((and (or (eqv? c #\x) (eqv? c #\X))
                        (string->number (substring name 1 (string-length name))
                                        16))
                   => integer->char)
                  (else (read-error "unknown char name" name)))))
        (define (read-type-id in)
          (let ((ch (peek-char in)))
            (cond
             ((eqv? ch #\#)
              (read-char in)
              (let ((id (read in)))
                (cond ((eq? id 't) #t)
                      ((integer? id) id)
                      (else (read-error "invalid type identifier" id)))))
             ((eqv? ch #\")
              (read in))
             (else
              (read-error "invalid type identifier syntax" ch)))))
        (define (read-object)
          (let ((name (read-name #f in)))
            (skip-whitespace in)
            (let* ((id (read-type-id in))
                   (type (lookup-type name id)))
              (let lp ((ls '()))
                (skip-whitespace in)
                (cond
                 ((eof-object? (peek-char in))
                  (read-error "missing closing }"))
                 ((eqv? #\} (peek-char in))
                  (read-char in)
                  (let ((res ((make-constructor #f type))))
                    (let lp ((ls (reverse ls)) ( i 0))
                      (cond
                       ((null? ls)
                        res)
                       (else
                        (slot-set! type res i (car ls))
                        (lp (cdr ls) (+ i 1)))))))
                 (else (lp (cons (read-one) ls))))))))
        (define (read-one)
          (skip-whitespace in)
          (case (peek-char in)
            ((#\#)
             (read-char in)
             (if (eof-object? (peek-char in))
                 (read-error "read error: incomplete # found at end of input"))
             (case (char-downcase (peek-char in))
               ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
                (let* ((str (read-label '()))
                       (n (string->number str)))
                  (if (not n) (read-error "read error: invalid reference" str))
                  (cond
                   ((eqv? #\= (peek-char in))
                    (read-char in)
                    (let* ((cell (list #f))
                           (thunk (lambda () (car cell))))
                      (set! shared (cons (cons n thunk) shared))
                      (let ((x (read-one)))
                        (set-car! cell x)
                        x)))
                   ((eqv? #\# (peek-char in))
                    (read-char in)
                    (cond
                     ((assv n shared) => cdr)
                     (else (read-error "read error: unknown reference" n))))
                   (else
                    (read-error "read error: expected # after #n"
                                (read-char in))))))
               ((#\;)
                (read-char in)
                (read-one) ;; discard
                (read-one))
               ((#\|)
                (skip-comment in 0)
                (read-one))
               ((#\!)
                (read-char in)
                (let ((c (peek-char in)))
                  (cond
                   ((or (char-whitespace? c) (eqv? c #\/))
                    (skip-line in)
                    (read-one))
                   (else
                    (let ((name (read-name #f in)))
                      (cond
                       ((string-ci=? name "fold-case")
                        (set-port-fold-case! in #t))
                       ((string-ci=? name "no-fold-case")
                        (set-port-fold-case! in #f))
                       (else            ;; assume a #!/bin/bash line
                        (read-error "unknown #! symbol" name)))
                      (read-one))))))
               ((#\() (list->vector (read-one)))
               ((#\') (read-char in) (list 'syntax (read-one)))
               ((#\`) (read-char in) (list 'quasisyntax (read-one)))
               ((#\t) (let ((s (read-name #f in)))
                        (or (string-ci=? s "t") (string-ci=? s "true")
                            (read-error "bad # syntax" s))))
               ((#\f) (let ((s (read-name #f in)))
                        (if (or (string-ci=? s "f") (string-ci=? s "false"))
                            #f
                            (read-error "bad # syntax" s))))
               ((#\d) (read-char in) (read in))
               ((#\x) (read-char in) (read-number 16))
               ((#\o) (read-char in) (read-number 8))
               ((#\b) (read-char in) (read-number 2))
               ((#\i) (read-char in) (exact->inexact (read-one)))
               ((#\e) (string->number (read-name #\# in)))
               ((#\u #\v)
                (if (eqv? #\v (peek-char in))
                    (read-char in))
                (read-char in)
                (if (not (eqv? #\8 (peek-char in)))
                    (read-error "invalid syntax #u" (peek-char in)))
                (read-char in)
                (let ((ls (read-one)))
                  (if (not (list? ls))
                      (read-error "invalid bytevector syntax" ls))
                  (let* ((len (length ls))
                         (bv (make-bytevector len)))
                    (do ((i 0 (+ i 1)) (ls ls (cdr ls)))
                        ((null? ls) bv)
                      (bytevector-u8-set! bv i (car ls))))))
               ((#\\)
                (read-char in)
                (let* ((c1 (read-char in))
                       (c2 (peek-char in)))
                  (if (or (eof-object? c2) (memv c2 delimiters))
                      c1
                      (read-named-char c1 in))))
               (else
                (read-error "unknown # syntax: " (peek-char in)))))
            ((#\()
             (read-char in)
             (let lp ((res '()))
               (skip-whitespace in)
               (let ((c (peek-char in)))
                 (case c
                   ((#\))
                    (read-char in)
                    (reverse res))
                   ((#\.)
                    (read-char in)
                    (cond
                     ((memv (peek-char in) delimiters)
                      (let ((tail (read-one)))
                        (cond
                         ((and (skip-whitespace-and-sexp-comments
                                in (lambda (in) (read-one)))
                               (eqv? #\) (peek-char in)))
                          (read-char in)
                          (append (reverse res) tail))
                         ((eof-object? (peek-char in))
                          (read-incomplete-error "unterminated dotted list"))
                         (else
                          (read-error "expected end of list after dot")))))
                     ((char-numeric? (peek-char in))
                      (lp (cons (read-float-tail in) res)))
                     (else
                      (lp (cons (string->symbol (read-name #\. in)) res)))))
                   (else
                    (if (eof-object? c)
                        (read-incomplete-error "unterminated list")
                        (lp (cons (read-one) res))))))))
            ((#\{)
             (read-char in)
             (read-object))
            ((#\') (read-char in) (list 'quote (read-one)))
            ((#\`) (read-char in) (list 'quasiquote (read-one)))
            ((#\,)
             (read-char in)
             (let ((sym (if (eqv? #\@ (peek-char in))
                            (begin (read-char in) 'unquote-splicing)
                            'unquote)))
               (list sym (read-one))))
            (else
             (read in))))
        ;; body
        (let ((res (read-one)))
          (if (pair? shared)
              (patch res))
          res)))))

(define (hole? x) (procedure? x))
(define (fill-hole x) (if (hole? x) (fill-hole (x)) x))

(define (patch x)
  (cond
   ((pair? x)
    (if (hole? (car x)) (set-car! x (fill-hole (car x))) (patch (car x)))
    (if (hole? (cdr x)) (set-cdr! x (fill-hole (cdr x))) (patch (cdr x))))
   ((vector? x)
    (do ((i (- (vector-length x) 1) (- i 1)))
        ((< i 0))
      (let ((elt (vector-ref x i)))
        (if (hole? elt)
            (vector-set! x i (fill-hole elt))
            (patch elt)))))
   (else
    (let* ((type (type-of x))
           (slots (and type (type-slots type))))
      (cond
       (slots
        (let lp ((i 0) (ls slots))
          (cond
           ((pair? ls)
            (let ((elt (slot-ref type x i)))
              (if (hole? elt)
                  (slot-set! type x i (fill-hole elt))
                  (patch elt))
              (lp (+ i 1) (cdr ls))))))))))))

(define read/ss read-with-shared-structure)

(define-library (scheme write)
  (import (rename (chibi) (write write-simple) (display display-simple))
          (rename (srfi 38) (write/ss write-shared)))
  (export display write write-shared write-simple)
  (begin
    (define (display x . o)
      (apply (if (or (string? x) (char? x)) display-simple write) x o))
    (define (write x . o)
      (write-shared x (if (pair? o) (car o) (current-output-port)) #t))))

(define (read-sexps file . o)
  (let ((in (open-input-file file)))
    (if (and (pair? o) (car o))
        (set-port-fold-case! in #t))
    (let lp ((res '()))
      (let ((x (read in)))
        (if (eof-object? x) res (lp (cons x res)))))))

(define-syntax include
  (er-macro-transformer
   (lambda (expr rename compare)
     (let lp ((files (cdr expr)) (res '()))
       (cond
        ((null? files) (cons (rename 'begin) (reverse res)))
        (else (lp (cdr files) (append (read-sexps (car files)) res))))))))

(define-syntax include-ci
  (er-macro-transformer
   (lambda (expr rename compare)
     (let lp ((files (cdr expr)) (res '()))
       (cond
        ((null? files) (cons (rename 'begin) (reverse res)))
        (else (lp (cdr files) (append (read-sexps (car files) #t) res))))))))

(define (read-error? x)
  (and (error-object? x) (eq? 'read (exception-kind x))))

(define (file-error? x)
  (and (error-object? x) (eq? 'file (exception-kind x))))

(define (features) *features*)

(define exact inexact->exact)
(define inexact exact->inexact)

(define (boolean=? x y . o)
  (and (eq? x y) (if (pair? o) (apply boolean=? y o) #t)))
(define (symbol=? x y . o)
  (and (eq? x y) (if (pair? o) (apply symbol=? y o) #t)))

(define call/cc call-with-current-continuation)

(define truncate-quotient quotient)
(define truncate-remainder remainder)
(define (truncate/ n m)
  (values (truncate-quotient n m) (truncate-remainder n m)))

(define (floor-quotient n m)
  (let ((res (floor (/ n m))))
    (if (and (exact? n) (exact? m))
        (inexact->exact res)
        res)))
(define (floor-remainder n m)
  (- n (* m (floor-quotient n m))))
(define (floor/ n m)
  (values (floor-quotient n m) (floor-remainder n m)))

(define (exact-integer-sqrt x)
  (let ((res (exact-sqrt x)))
    (values (car res) (cdr res))))

;; Adapted from Bawden's algorithm.
(define (rationalize x e)
  (define (sr x y return)
    (let ((fx (floor x)) (fy (floor y)))
      (cond
       ((>= fx x)
        (return fx 1))
       ((= fx fy)
        (sr (/ (- y fy)) (/ (- x fx)) (lambda (n d) (return (+ d (* fx n)) n))))
       (else
        (return (+ fx 1) 1)))))
  (let ((return (if (negative? x) (lambda (num den) (/ (- num) den)) /))
        (x (abs x))
        (e (abs e)))
    (sr (- x e) (+ x e) return)))

(define (square x) (* x x))

(define flush-output-port flush-output)

(define input-port-open? port-open?)
(define output-port-open? port-open?)

(define (close-port port)
  ((if (input-port? port) close-input-port close-output-port) port))

(define (u8-ready? port) (char-ready? port))

(define (call-with-port port proc)
  (let ((res (proc port)))
    (close-port port)
    res))

(define (eof-object) (read-char (open-input-string "")))

(define (read-bytevector n . o)
  (if (zero? n)
      #u8()
      (let ((in (if (pair? o) (car o) (current-input-port)))
            (res (make-bytevector n)))
        (let lp ((i 0))
          (if (>= i n)
              res
              (let ((x (read-u8 in)))
                (cond ((eof-object? x)
                       (if (zero? i) x (subbytes res 0 i)))
                      (else
                       (bytevector-u8-set! res i x)
                       (lp (+ i 1))))))))))

(define (read-bytevector! vec . o)
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) o))
         (start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o)))
                  (cadr o)
                  (bytevector-length vec))))
    (if (>= start end)
        0
        (let ((res (read-bytevector (- end start) in)))
          (cond
           ((eof-object? res)
            res)
           (else
            (let ((len (bytevector-length res)))
              (do ((i 0 (+ i 1)))
                  ((>= i len) len)
                (bytevector-u8-set! vec (+ i start) (bytevector-u8-ref res i))
                ))))))))

(define (write-bytevector vec . o)
  (let* ((out (if (pair? o) (car o) (current-output-port)))
         (o (if (pair? o) (cdr o) '()))
         (start (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (end (if (pair? o) (car o) (bytevector-length vec))))
    (do ((i start (+ i 1)))
        ((>= i end))
      (write-u8 (bytevector-u8-ref vec i) out))))

(define (list-set! ls k x)
  (cond ((null? ls) (error "invalid list index"))
        ((zero? k) (set-car! ls x))
        (else (list-set! (cdr ls) (- k 1) x))))

(define (vector-append . vecs)
  (let* ((len (apply + (map vector-length vecs)))
         (res (make-vector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (vector-length (car ls))))
            (vector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))

(define (vector-map proc vec . lov)
  (if (null? lov)
      (let lp ((i (vector-length vec)) (res '()))
        (if (zero? i)
            (list->vector res)
            (lp (- i 1) (cons (proc (vector-ref vec (- i 1))) res))))
      (list->vector (apply map proc (map vector->list (cons vec lov))))))

(define (vector-for-each proc vec . lov)
  (if (null? lov)
      (let ((len (vector-length vec)))
        (let lp ((i 0))
          (cond ((< i len)
                 (proc (vector-ref vec i))
                 (lp (+ i 1))))))
      (apply for-each proc (map vector->list (cons vec lov)))))

(define (vector-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length from)))
         (limit (min end (+ start (- (vector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (vector-set! to i (vector-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (vector-set! to i (vector-ref from j))))))

(define (vector->string vec . o)
  (list->string (apply vector->list vec o)))

(define (string->vector vec . o)
  (list->vector (apply string->list vec o)))

(define (bytevector . args)
  (let* ((len (length args))
         (res (make-bytevector len)))
    (do ((i 0 (+ i 1)) (ls args (cdr ls)))
        ((null? ls) res)
      (bytevector-u8-set! res i (car ls)))))

(define (bytevector-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o)))
                  (cadr o)
                  (bytevector-length from)))
         (limit (min end (+ start (- (bytevector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (bytevector-u8-set! to i (bytevector-u8-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (bytevector-u8-set! to i (bytevector-u8-ref from j))))))

(define (bytevector-copy vec . o)
  (if (null? o)
      (subbytes vec 0)
      (apply subbytes vec o)))

(define (bytevector-append . vecs)
  (let* ((len (apply + (map bytevector-length vecs)))
         (res (make-bytevector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (bytevector-length (car ls))))
            (bytevector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))

;; Never use this!
(define (string-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length from)))
         (limit (min end (+ start (- (string-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (string-set! to i (string-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (string-set! to i (string-ref from j))))))

(define truncate-quotient quotient)
(define truncate-remainder remainder)
(define (truncate/ n m)
  (values (truncate-quotient n m) (truncate-remainder n m)))

(cond-expand
 (ratios
  (define (floor-quotient n m)
    (floor (/ n m))))
 (else
  (define (floor-quotient n m)
    (let ((res (floor (/ n m))))
      (if (and (exact? n) (exact? m))
          (exact res)
          res)))))
(define (floor-remainder n m)
  (- n (* m (floor-quotient n m))))
(define (floor/ n m)
  (values (floor-quotient n m) (floor-remainder n m)))
;; time.sld - (scheme time) library definition
;;
;; Copyright (c) 2012 Alex Shinn. All rights reserved.
;; Copyright (c) 2012 Alan Watson. All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-library (scheme time)
  (export current-second current-jiffy jiffies-per-second)
  (import (chibi))
  (import (scheme process-context))
  (import (scheme time tai))
  (include-shared "time")
  ;; If the environment variable SEXP_CLOCK_TYPE is set, its value
  ;; is used for the system clock type. If the environment variable
  ;; SEXP_CLOCK_TYPE is not set, then the system clock is ntp-like
  ;; if current-ntp-clock-values is a procedure and is posix-like
  ;; otherwise.
  (cond-expand
   (ntp
    (begin
      (define clock-type
        (cond
         ((get-environment-variable "SEXP_CLOCK_TYPE")
          => (lambda (x)
               (let ((type (string->symbol x)))
                 (case type
                   ((posix-like tai-like ntp-like) type)
                   (else
                    (display "invalid value for SEXP_CLOCK_TYPE: " (current-error-port))
                    (write x (current-error-port))
                    (display " - expected \"ntp-like\", \"posix-like\" or \"tai-like\"\n" (current-error-port))
                    'ntp-like)))))
         (else 'ntp-like)))))
   (else
    (begin (define clock-type 'posix-like))))
  (begin
    ;; The value of the environment variable SEXP_CLOCK_EPOCH_OFFSET
    ;; specifies the offset of the system clock relative to the
    ;; standard epoch (1970-01-01 00:00:00 UTC for posix-like and
    ;; ntp-like clocks and 1970-01-01 00:00:00 TAI for tai-like system
    ;; clocks). If it not set, the offset is assumed to be zero. In
    ;; call-with-current-clock-values, the offset is added to the
    ;; current seconds before calling the procedure argument.
    (define epoch-offset
      (exact->inexact
       (string->number
        (or (get-environment-variable "SEXP_CLOCK_EPOCH_OFFSET")
            "0"))))

    ;; Normally, one does not need to specify either the clock type or
    ;; clock epoch explicitly. One case where it might be necessary is
    ;; if the system clock runs on the TAI-10 timescale. In this case,
    ;; one should set SEXP_CLOCK_TYPE to "tai-like" and
    ;; SEXP_CLOCK_EPOCH_OFFSET to -10.
    ;;
    ;; The call-with-current-clock-values obtains the clock values
    ;; from the current-ntp-clock-values procedure, if the system
    ;; clock is ntp-like, and from the current-clock-second procedure
    ;; otherwise.
    (define call-with-current-clock-values
      (cond-expand
       (ntp
        (case clock-type
          ((ntp-like)
           (lambda (p)
             (let ((values-pair (current-ntp-clock-values)))
               (p (+ (car values-pair) epoch-offset) (cdr values-pair)))))
          (else
           (lambda (p) (p (+ (current-clock-second) epoch-offset) #f)))))
       (else
        (lambda (p) (p (+ (current-clock-second) epoch-offset) #f)))))

    ;; Exported interface.
    (define current-second
      (make-tai-clock clock-type call-with-current-clock-values))
    (define (current-jiffy)
      (inexact->exact (round (* (current-second) (jiffies-per-second)))))
    (define (jiffies-per-second) 1000)))

(define-library (scheme case-lambda)
  (import (srfi 16))
  (export case-lambda))

(define-library (scheme read)
  (import (rename (srfi 38) (read/ss read)))
  (export read))

(define-library (scheme r5rs)
  (import
   (rename (scheme base)
           (exact inexact->exact)
           (inexact exact->inexact))
   (scheme cxr)
   (scheme char)
   (scheme inexact)
   (scheme complex)
   (scheme read)
   (scheme write)
   (scheme file)
   (scheme lazy)
   (scheme eval)
   (scheme repl)
   (scheme load)
   (only (chibi) null-environment scheme-report-environment))
  (export
   - * / + < <= = > >= abs acos and angle append apply asin assoc assq
   assv atan begin boolean?
   caaaar caaadr caadar caaddr
   cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr
   cddaar cddadr cdddar cddddr
   caaar caadr cadar caddr
   cdaar cdadr cddar cdddr
   caar cadr cdar cddr
   call-with-current-continuation call-with-input-file call-with-output-file
   call-with-values car case cdr ceiling char->integer char-alphabetic?
   char-ci<? char-ci<=? char-ci=? char-ci>? char-ci>=? char-downcase
   char-lower-case? char-numeric? char-ready? char-upcase
   char-upper-case? char-whitespace? char? char<? char<=? char=? char>?
   char>=? close-input-port close-output-port complex? cond cons cos
   current-input-port current-output-port define define-syntax delay
   denominator display do dynamic-wind eof-object? eq? equal? eqv? eval
   even? exact->inexact exact? exp expt floor for-each force gcd if
   imag-part inexact->exact inexact? input-port? integer->char integer?
   interaction-environment lambda lcm length let let-syntax let* letrec
   letrec-syntax list list->string list->vector list-ref list-tail list?
   load log magnitude make-polar make-rectangular make-string make-vector
   map max member memq memv min modulo negative? newline not
   null-environment null? number->string number? numerator odd?
   open-input-file open-output-file or output-port? pair? peek-char
   positive? procedure? quasiquote quote quotient rational? rationalize
   read read-char real-part real? remainder reverse round
   scheme-report-environment set-car! set-cdr! set! sin sqrt string
   string->list string->number string->symbol string-append string-ci<?
   string-ci<=? string-ci=? string-ci>? string-ci>=? string-copy
   string-fill! string-length string-ref string-set! string? string<?
   string<=? string=? string>? string>=? substring symbol->string symbol?
   tan truncate values vector vector->list vector-fill! vector-length
   vector-ref vector-set! vector? with-input-from-file
   with-output-to-file write write-char zero?
   ))

(define-library (scheme complex)
  (import (chibi))
  (export angle imag-part magnitude make-polar make-rectangular real-part))

(define (nan? x)
  (and (real? x) (not (= x x))))

(define (finite? x)
  (if (real? x)
      (and (not (nan? x)) (not (= x +inf.0)) (not (= x -inf.0)))
      (and (complex? x) (finite? (real-part x)) (finite? (imag-part x)))))

(define (infinite? x)
  (and (number? x) (not (finite? x)) (not (nan? x))))

(define-library (scheme eval)
  (import (chibi) (meta)) ; (chibi compiler analyze)
  (export eval environment))

;; provide c[ad]{3,4}r

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define-library (scheme process-context)
  (import (chibi) (srfi 98) (only (chibi process) exit))
  (export get-environment-variable get-environment-variables
          command-line exit emergency-exit)
  ;; TODO: Make exit unwind and finalize properly.
  (begin (define emergency-exit exit)))

(define-library (scheme inexact)
  (import (chibi))
  (export acos asin atan cos exp finite? infinite? log nan? sin sqrt tan)
  (include "inexact.scm"))
;;;; division.scm -- portable R7RS (scheme division) implementation
;;
;; This code is written by Alex Shinn and placed in the
;; Public Domain.  All warranties are disclaimed.
;;
;; This is basically the simplest possible implementation.  Note the
;; code below assumes that either 1) exact ratios are supported and
;; are handled correctly by floor, ceiling and round, or 2) that
;; you're using a simple implementation with only fixnums and flonums.
;; In the intermediate case where you have bignums but no ratios there
;; will be a loss of precision for large values.
;;
;; We handle both cases by the use of the cond-expand form in
;; division.sld to conditionally define copy-exactness2.  In case 1,
;; no adjustment is needed, whereas in case 2 we want to convert the
;; intermediate result back to exact if both inputs were exact.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The builtin quotient and remainder implement truncation - the
;; fractional part is always discarded.

(define truncate-quotient quotient)
(define truncate-remainder remainder)
(define (truncate/ n m)
  (values (truncate-quotient n m) (truncate-remainder n m)))

;; Floor, ceiling and round just compose their corresponding function
;; with division to determine the quotient, and compute the remainder
;; from that.

(define (floor-quotient n m)
  (copy-exactness2 n m (floor (/ n m))))
(define (floor-remainder n m)
  (- n (* m (floor-quotient n m))))
(define (floor/ n m)
  (values (floor-quotient n m) (floor-remainder n m)))

(define (ceiling-quotient n m)
  (copy-exactness2 n m (ceiling (/ n m))))
(define (ceiling-remainder n m)
  (- n (* m (ceiling-quotient n m))))
(define (ceiling/ n m)
  (values (ceiling-quotient n m) (ceiling-remainder n m)))

(define (round-quotient n m)
  (copy-exactness2 n m (round (/ n m))))
(define (round-remainder n m)
  (- n (* m (round-quotient n m))))
(define (round/ n m)
  (values (round-quotient n m) (round-remainder n m)))

;; Euclidean is defined as floor if the divisor is negative, and
;; ceiling otherwise.

(define (euclidean-quotient n m)
  (if (> m 0) (floor-quotient n m) (ceiling-quotient n m)))
(define (euclidean-remainder n m)
  (- n (* m (euclidean-quotient n m))))
(define (euclidean/ n m)
  (values (euclidean-quotient n m) (euclidean-remainder n m)))

;; Centered places the remainder in the half-open interval
;; [-m/2, m/2).

(define (centered-remainder n m)
  (let ((r (euclidean-remainder n m))
        (m/2 (abs (/ m 2))))
    (cond ((< r (- m/2)) (+ r (abs m)))
          ((>= r m/2) (- r (abs m)))
          (else r))))
(define (centered-quotient n m)
  (quotient (- n (centered-remainder n m)) m))
(define (centered/ n m)
  (values (centered-quotient n m) (centered-remainder n m)))

(define-library (scheme lazy)
  (import (chibi))
  (export delay force delay-force make-promise promise?)
  (begin
    (define (make-promise x)
      (delay x)))
  (cond-expand
   (auto-force
    )
   (else
    (begin
      (define (promise? x)
        (and (pair? x)
             (null? (cdr x))
             (pair? (car x))
             (or (eq? #t (caar x))
                 (and (eq? #f (caar x))
                      (procedure? (cdar x))))))))))

(define-library (scheme char)
  (import (scheme base))
  (cond-expand
   (full-unicode
    (import (scheme write)
            (chibi char-set full)
            (chibi char-set base)
            (chibi iset base))
    (include "char/full.scm")
    (include "char/special-casing.scm")
    (include "char/case-offsets.scm"))
   (else
    (include "char/ascii.scm")
    (import
     (only (chibi)
           string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
           char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
           char-alphabetic?  char-lower-case? char-numeric?
           char-upper-case? char-whitespace? digit-value
           char-upcase char-downcase))))
  (include "digit-value.scm")
  (export
   char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
   char-downcase char-foldcase char-lower-case? char-numeric?
   char-upcase char-upper-case? char-whitespace? digit-value
   string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
   string-downcase string-foldcase string-upcase))

(define-library (scheme base)
  (import (except (chibi) equal?)
          (rename (chibi equiv) (equiv? equal?))
          (only (chibi string) string-map string-for-each)
          (chibi io)
          (rename (only (chibi ast)
                        exception? exception-message exception-irritants)
                  (exception? error-object?)
                  (exception-message error-object-message)
                  (exception-irritants error-object-irritants))
          (srfi 9) (srfi 11) (srfi 39))
  (export
   * + - ... / < <= = => > >= _ abs and append apply assoc assq assv begin
   binary-port?  boolean?  boolean=?  bytevector bytevector-append
   bytevector-copy bytevector-copy! bytevector-length
   bytevector-u8-ref bytevector-u8-set!  bytevector?  caar cadr
   call-with-current-continuation call-with-port call-with-values
   call/cc car case cdr cdar cddr ceiling char->integer
   char-ready? char<=?  char<?  char=?  char>=?  char>?  char?
   close-input-port close-output-port close-port complex?  cond cond-expand
   cons current-error-port current-input-port current-output-port define
   define-record-type define-syntax define-values denominator do
   dynamic-wind else eof-object? eof-object  eq?  equal?  eqv?  error
   error-object-irritants error-object-message error-object?  even?
   exact exact-integer-sqrt exact-integer?  exact?  expt features
   file-error? floor
   flush-output-port for-each gcd get-output-bytevector get-output-string
   guard if include include-ci inexact inexact?  input-port?
   integer->char
   integer?  lambda lcm length let let* let*-values let-syntax let-values
   letrec letrec* letrec-syntax list list->string list->vector list-copy
   list-ref list-set!  list-tail list?  make-bytevector make-list
   make-parameter make-string make-vector map max member memq memv min
   modulo negative?  newline not null?  number->string number?  numerator
   odd?  open-input-bytevector open-input-string open-output-bytevector
   open-output-string or output-port?  pair?  parameterize peek-char
   peek-u8 input-port-open? output-port-open?  port?  positive?
   procedure?  quasiquote quote
   quotient raise raise-continuable rational?  rationalize read-bytevector
   read-bytevector!  read-char read-error? read-line read-string read-u8
   real?  remainder
   reverse round set!  set-car!  set-cdr!  square string string->list
   string->number string->symbol string->utf8 string->vector string-append
   string-copy string-copy! string-fill!  string-for-each string-length
   string-map
   string-ref string-set!  string<=?  string<?  string=?  string>=?
   string>?  string?  substring symbol->string symbol?  symbol=?  syntax-error
   syntax-rules textual-port?  truncate u8-ready?  unless unquote
   unquote-splicing utf8->string values vector vector-append
   vector->list vector->string
   vector-copy vector-copy! vector-fill!  vector-for-each vector-length
   vector-map vector-ref vector-set!  vector?  when with-exception-handler
   write-bytevector write-char write-string write-u8 zero?
   truncate-quotient truncate-remainder truncate/
   floor-quotient floor-remainder floor/)
  (include "define-values.scm"
           "extras.scm"
           "misc-macros.scm"))

(define-library (scheme load)
  (import (chibi))
  (export load))

(define-syntax when
  (syntax-rules ()
    ((when test . body)
     (if test (begin . body)))))

(define-syntax unless
  (syntax-rules ()
    ((unless test . body)
     (when (not test) . body))))

(define-syntax guard
  (syntax-rules ()
    ((guard (var clause ...) e1 e2 ...)
     ((call-with-current-continuation
       (lambda (guard-k)
         (with-exception-handler
          (lambda (condition)
            ((call-with-current-continuation
              (lambda (handler-k)
                (guard-k
                 (lambda ()
                   (let ((var condition))      ; clauses may SET! var
                     (guard-aux (handler-k (lambda ()
                                             (raise-continuable condition)))
                                clause ...))))))))
          (lambda ()
            (let ((res (begin e1 e2 ...)))
              (guard-k (lambda () res)))))))))))

(define-syntax guard-aux
  (syntax-rules (else =>)
    ((guard-aux reraise (else result1 result2 ...))
     (begin result1 result2 ...))
    ((guard-aux reraise (test => result))
     (let ((temp test))
       (if temp (result temp) reraise)))
    ((guard-aux reraise (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp (result temp) (guard-aux reraise clause1 clause2 ...))))
    ((guard-aux reraise (test))
     (or test reraise))
    ((guard-aux reraise (test) clause1 clause2 ...)
     (or test (guard-aux reraise clause1 clause2 ...)))
    ((guard-aux reraise (test result1 result2 ...))
     (if test (begin result1 result2 ...) reraise))
    ((guard-aux reraise (test result1 result2 ...) clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (guard-aux reraise clause1 clause2 ...)))))

(define-library (scheme repl)
  (import (chibi))
  (export interaction-environment))
(define-library (scheme small)
  (import (scheme base) (scheme char) (scheme complex) (scheme cxr)
          (scheme eval) (scheme file) (scheme inexact) (scheme lazy)
          (scheme load) (scheme read) (scheme repl) (scheme time)
          (scheme write))
  (export
   ;; base
   * + - ... / < <= = => > >= _ abs and append apply assoc assq assv begin
   binary-port?  boolean?  boolean=?  bytevector bytevector-append
   bytevector-copy bytevector-copy! bytevector-length
   bytevector-u8-ref bytevector-u8-set!  bytevector?  caar cadr
   call-with-current-continuation call-with-port call-with-values
   call/cc car case cdr cdar cddr ceiling char->integer
   char-ready? char<=?  char<?  char=?  char>=?  char>?  char?
   close-input-port close-output-port close-port complex?  cond cond-expand
   cons current-error-port current-input-port current-output-port define
   define-record-type define-syntax define-values denominator do
   dynamic-wind else eof-object? eof-object  eq?  equal?  eqv?  error
   error-object-irritants error-object-message error-object?  even?
   exact exact-integer-sqrt exact-integer?  exact?  expt features
   file-error? floor
   flush-output-port for-each gcd get-output-bytevector get-output-string
   guard if include include-ci inexact inexact?  input-port?
   integer->char
   integer?  lambda lcm length let let* let*-values let-syntax let-values
   letrec letrec* letrec-syntax list list->string list->vector list-copy
   list-ref list-set!  list-tail list?  make-bytevector make-list
   make-parameter make-string make-vector map max member memq memv min
   modulo negative?  newline not null?  number->string number?  numerator
   odd?  open-input-bytevector open-input-string open-output-bytevector
   open-output-string or output-port?  pair?  parameterize peek-char
   peek-u8 input-port-open? output-port-open?  port?  positive?
   procedure?  quasiquote quote
   quotient raise raise-continuable rational?  rationalize read-bytevector
   read-bytevector!  read-char read-error? read-line read-string read-u8
   real?  remainder
   reverse round set!  set-car!  set-cdr!  square string string->list
   string->number string->symbol string->utf8 string->vector string-append
   string-copy string-copy! string-fill!  string-for-each string-length
   string-map
   string-ref string-set!  string<=?  string<?  string=?  string>=?
   string>?  string?  substring symbol->string symbol?  symbol=?  syntax-error
   syntax-rules textual-port?  truncate u8-ready?  unless unquote
   unquote-splicing utf8->string values vector vector-append
   vector->list vector->string
   vector-copy vector-copy! vector-fill!  vector-for-each vector-length
   vector-map vector-ref vector-set!  vector?  when with-exception-handler
   write-bytevector write-char write-string write-u8 zero?
   truncate-quotient truncate-remainder truncate/
   floor-quotient floor-remainder floor/
   ;; char
   char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
   char-downcase char-foldcase char-lower-case? char-numeric?
   char-upcase char-upper-case? char-whitespace? digit-value
   string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
   string-downcase string-foldcase string-upcase
   ;; complex
   angle imag-part magnitude make-polar make-rectangular real-part
   ;; cxr
   caaar caadr cadar caddr cdaar cdadr cddar cdddr
   caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr
   ;; eval
   eval environment
   ;; file
   call-with-input-file call-with-output-file
   delete-file file-exists?
   open-binary-input-file open-binary-output-file
   open-input-file open-output-file
   with-input-from-file with-output-to-file
   ;; inexact
   acos asin atan cos exp finite? infinite? log nan? sin sqrt tan
   ;; lazy
   delay force delay-force make-promise promise?
   ;; load
   load
   ;; read
   read
   ;; repl
   interaction-environment
   ;; time
   current-second current-jiffy jiffies-per-second
   ;; write
   display write write-shared write-simple
   ))
;; Copyright (c) 2012 Alan Watson. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;; This library implements procedures that give the TAI to UTC offset a
;; specified instant in the UTC or TAI timescales.

(define-library (scheme time tai-to-utc-offset)
  
  (export tai-to-utc-offset-at-utc-day
          tai-to-utc-offset-at-tai-second
          set-open-leap-seconds-list-port!
          set-update-exception-handler!)
  
  (import (scheme base))
  (import (scheme file))
  (import (scheme read))
  (import (scheme process-context))
  
  (cond-expand
   (threads
    (import (srfi 18)))
   (else
    (begin
      (define (make-thread thunk name) #f)
      (define (thread-start! th) #f)
      (define (thread-sleep! secs) #f))))
  
  (cond-expand
   (chibi
    (begin
      (define *file-name-environment-variable* "SEXP_LEAP_SECONDS_LIST_FILE")))
   (else
    (begin
      (error "Need to define *file-name-environment-variable*."))))
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (cond-expand
   
   ;; We ensure thread-safe atomic access to mutated bindings using
   ;; atomic boxes.
   
   (chibi
    (begin
      
      ;; This implementation relies on record accessors and mutators
      ;; being atomic in Chibi Scheme.
      
      (define-record-type atomic-box-record-type
        (make-atomic-box value)
        atomic-box?
        (value atomic-box-value atomic-box-value-set!))))
   
   (else
    (begin
      
      ;; This implementation uses SRFI-18 mutexes.
      
      (define (make-atomic-box value)
        (let ((mutex (make-mutex)))
          (mutex-specific-set! mutex value)
          mutex))
      
      (define atomic-box? mutex?)
      
      (define (atomic-box-value mutex)
        (mutex-lock! mutex)
        (let ((value (mutex-specific mutex)))
          (mutex-unlock! mutex)
          value))
      
      (define (atomic-box-value-set! mutex value)
        (mutex-lock! mutex)
        (mutex-specific-set! mutex value)
        (mutex-unlock! mutex)))))
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (begin
    
    (define seconds-per-day 86400)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; First, a remark on timescales.
    ;;
    ;; The TAI timescale used in this library has an epoch of 1970-01-01
    ;; 00:00:00 TAI. The epoch used by the current-second procedure in
    ;; the draft R7RS (scheme time) library is the "TAI-10" timescale
    ;; with an epoch of 1970-01-01 00:00:10 TAI.
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; The library maintains a cache of values derived from the leap
    ;; seconds list.
    ;;
    ;; The first cached value is the utc-day-alist. This is an alist
    ;; whose cars are the UTC days since 1970-01-01 00:00:00 UTC and
    ;; whose cdrs are the corresponding TAI to UTC offsets.
    ;;
    ;; The second cached value is the tai-second-alist. This is an alist
    ;; whose cars are the TAI seconds since 1970-01-01 00:00:00 TAI and
    ;; whose cdrs are the corresponding TAI to UTC offsets.
    
    (define-record-type cache-record-type
      (make-cache utc-day-alist tai-second-alist)
      cache?
      (utc-day-alist cache-utc-day-alist)
      (tai-second-alist cache-tai-second-alist))
    
    (define (make-cache-from-port port)
      (let ((utc-day-alist (read-leap-seconds-list port)))
        (make-cache utc-day-alist
                    (utc-day-alist->tai-second-alist utc-day-alist))))
    
    ;; The utc-day-alist->tai-second-alist procedure converts an alist
    ;; indexed by the number of UTC day since 1970-01-01 00:00:00 UTC
    ;; into an equivalent alist indexed by the number of TAI seconds
    ;; since 1970-01-01 00:00:00 TAI.
    ;;
    ;; This procedure does not have to worry about the complications of
    ;; transforming UTC dates prior to 1972-01-01 00:00:00 UTC to TAI,
    ;; since there were no leap seconds prior to this date.
    
    (define (utc-day-alist->tai-second-alist utc-day-alist)
      (map
       (lambda (p)
         (let* ((utc-day      (car p))
                (leap-seconds (cdr p))
                (tai-second   (+ (* utc-day seconds-per-day) leap-seconds)))
           (cons tai-second leap-seconds)))
       utc-day-alist))
    
    ;; The library updates the cache: when the library is loaded; when
    ;; the set-open-leap-seconds-list-port! is called; and once per day.
    ;; These automatic periodic updates are useful in long-running
    ;; programs.
    ;;
    ;; The choice of daily updates is motivated by the following
    ;; considerations. ITU-R TF.460-6, which contains the current
    ;; definition of UTC, requires that the IERS should announce leap
    ;; seconds with at least eight weeks in advance. However, NIST,
    ;; which maintains the leap-seconds.list file, only guarantees one
    ;; month. Recently the IERS and NIST have managed six months of
    ;; notice, but we should not rely on this.
    ;;
    ;; During updates, we install the update-exception-handler.
    
    (define *cache-lifetime* (* 1 seconds-per-day))
    
    (define (update-cache! open-port)
      (with-exception-handler
          (update-exception-handler)
        (lambda ()
          (let ((port (open-port)))
            (when port
              (set-cache! (make-cache-from-port port)))))))
    
    (thread-start!
     (make-thread
      (lambda ()
        (let loop ()
          (thread-sleep! *cache-lifetime*)
          (update-cache! (open-leap-seconds-list-port))
          (loop)))
      "leap-second-update-poll"))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; The read-leap-seconds-list procedure reads text from the port
    ;; argument. The text must follow the format of a NIST leap seconds
    ;; file, for example,
    ;;
    ;;   ftp://time.nist.gov/pub/leap-seconds.list
    ;;
    ;; The procedure returns an alist. The cars of the pairs are the
    ;; number of whole UTC days since 1970-01-01 00:00:00 UTC and the
    ;; cdrs of the pairs are the corresponding TAI to UTC offset. The
    ;; alist is ordered by decreasing car. The cars and cdrs are exact
    ;; integers.
    ;;
    ;; TODO: Do not rely on the input file being correctly ordered. Do
    ;; not rely on the input data being exact integers.
    ;;
    ;; TODO: Check known leap seconds.
    
    (define (read-leap-seconds-list port)
      
      (define (ntp-second->utc-day ntp-second)
        ;; The NTP initial epoch is 1900-01-01 00:00:00 UTC. The UTC
        ;; initial epoch is 1970-01-01 00:00:00 UTC. There are 70 years,
        ;; containing 17 leap days, between these epochs.
        (- (quotient ntp-second seconds-per-day) (* 70 365) 17))
      
      (define (leap-seconds-line->pair line)
        (let* ((line-port         (open-input-string line))
               (ntp-second        (read line-port))
               (tai-to-utc-offset (read line-port))
               (utc-day           (ntp-second->utc-day ntp-second))
               (leap-seconds      tai-to-utc-offset))
          (cons utc-day leap-seconds)))
      
      (define (leap-seconds-comment-line? line)
        (char=? #\# (string-ref line 0)))
      
      (define (read-leap-seconds-line port)
        (let ((line (read-line port)))
          (cond
           ((eof-object? line) line)
           ((leap-seconds-comment-line? line) (read-leap-seconds-line port))
           (else line))))
      
      (let loop ((alist '()))
        (let ((line (read-leap-seconds-line port)))
          (if (eof-object? line)
            alist
            (loop (cons (leap-seconds-line->pair line) alist))))))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (set-open-leap-seconds-list-port! p)
    ;;
    ;; The set-open-leap-seconds-list-port! procedure sets the value of
    ;; procedure called to obtain the leap second list is read to its
    ;; argument p and then performs a cache update. The procedure should
    ;; return either #f, signifying that no leap second list is
    ;; available, or an input port, from which a leap-second list,
    ;; following the format of the NIST leap-second list, will be read.
    ;; The NIST leap-second file can be found here:
    ;;
    ;;   ftp://time.nist.gov/pub/leap-seconds.list
    ;;
    ;; The default procedure attempts to open the file named by the
    ;; environment variable SEXP_LEAP_SECOND_LIST_FILE and returns the
    ;; port. If the environment variable is not set or if the file does
    ;; not exist, it return #f.
    
    (define *open-leap-seconds-list-port*
      (make-atomic-box
       (lambda ()
         (when *file-name-environment-variable*
           (let ((file-name
                  (get-environment-variable *file-name-environment-variable*)))
             (if file-name
               (open-input-file file-name)
               #f))))))
    
    (define (open-leap-seconds-list-port)
      (atomic-box-value *open-leap-seconds-list-port*))
    
    (define (set-open-leap-seconds-list-port! p)
      (atomic-box-value-set! *open-leap-seconds-list-port* p)
      (update-cache! (open-leap-seconds-list-port)))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (set-update-exception-handler! p)
    ;;
    ;; The set-update-exception-handler! procedure sets the value of the
    ;; error handler installed during cache updates. The default error
    ;; handler simply raises the exception again.
    
    (define *update-exception-handler*
      (make-atomic-box raise))
    
    (define (update-exception-handler)
      (atomic-box-value *update-exception-handler*))
    
    (define (set-update-exception-handler! p)
      (atomic-box-value-set! *update-exception-handler* p))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    (define *cache*
      (make-atomic-box #f))
    
    (define (cache)
      (atomic-box-value *cache*))
    
    (define (set-cache! value)
      (atomic-box-value-set! *cache* value))
    
    (update-cache!
     (lambda ()
       (open-input-string
        (string-append
         
         ;; These strings are lines extracted from:
         ;;
         ;;   ftp://time.nist.gov/pub/leap-seconds.3535228800
         ;;
         ;; The original file contains extensive comments on the format
         ;; and provenance of the data, which have been removed from
         ;; this version.
         
         "2272060800 10  # 1 Jan 1972\n"
         "2287785600 11  # 1 Jul 1972\n"
         "2303683200 12  # 1 Jan 1973\n"
         "2335219200 13  # 1 Jan 1974\n"
         "2366755200 14  # 1 Jan 1975\n"
         "2398291200 15  # 1 Jan 1976\n"
         "2429913600 16  # 1 Jan 1977\n"
         "2461449600 17  # 1 Jan 1978\n"
         "2492985600 18  # 1 Jan 1979\n"
         "2524521600 19  # 1 Jan 1980\n"
         "2571782400 20  # 1 Jul 1981\n"
         "2603318400 21  # 1 Jul 1982\n"
         "2634854400 22  # 1 Jul 1983\n"
         "2698012800 23  # 1 Jul 1985\n"
         "2776982400 24  # 1 Jan 1988\n"
         "2840140800 25  # 1 Jan 1990\n"
         "2871676800 26  # 1 Jan 1991\n"
         "2918937600 27  # 1 Jul 1992\n"
         "2950473600 28  # 1 Jul 1993\n"
         "2982009600 29  # 1 Jul 1994\n"
         "3029443200 30  # 1 Jan 1996\n"
         "3076704000 31  # 1 Jul 1997\n"
         "3124137600 32  # 1 Jan 1999\n"
         "3345062400 33  # 1 Jan 2006\n"
         "3439756800 34  # 1 Jan 2009\n"
         "3550089600 35  # 1 Jul 2012\n"))))
    
    (update-cache! (open-leap-seconds-list-port))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (tai-to-utc-offset-at-utc-day utc-day)
    ;;
    ;; The tai-to-utc-offset-at-utc-day procedure returns the TAI to UTC
    ;; offset at the instant specified by its argument utc-day. The
    ;; instant is specified by the number of UTC days since 1970-01-01
    ;; 00:00:00 UTC.
    ;;
    ;; To convert a UTC time since 1972-01-01 00:00:00 UTC to number of
    ;; TAI seconds since 1972-01-01 00:00:00 TAI, first find the number
    ;; of whole UTC days D since 1970-01-01 00:00:00 UTC and the number
    ;; of UTC seconds S since the start of the current day. The number
    ;; of TAI seconds since 1972-01-01 00:00:00 TAI is then
    ;;
    ;;   (+ (* D 86400) S (tai-to-utc-offset-at-utc-day D))
    ;;
    ;; This implementation does not return the correct result for
    ;; instants prior to 1972-01-01 00:00:00 UTC.
    ;;
    ;; Converting a UTC time prior to 1972-01-01 00:00:00 UTC to TAI is
    ;; more involved, since prior to this date UTC and TAI seconds were
    ;; not equal. See,
    ;;
    ;;   http://hpiers.obspm.fr/eop-pc/index.php?index=TAI-UTC_tab
    
    (define (tai-to-utc-offset-at-utc-day-loop utc-day alist)
      (cond ((null? alist) 10)
            ((>= utc-day (caar alist)) (cdar alist))
            (else (tai-to-utc-offset-at-utc-day-loop utc-day (cdr alist)))))
    
    (define (tai-to-utc-offset-at-utc-day utc-day)
      (tai-to-utc-offset-at-utc-day-loop
       utc-day
       (cache-utc-day-alist (cache))))
    
    ;; (tai-to-utc-offset-at-tai-second tai-second)
    ;;
    ;; The tai-to-utc-offset-at-tai-second procedure returns TAI to UTC
    ;; offset at the instant specified by its argument tai-second. The
    ;; instant is specified by the number of TAI seconds since
    ;; 1970-01-01 00:00:00 TAI.
    ;;
    ;; This implementation does not return the correct result for
    ;; instants prior to 1972-01-01 00:00:00 UTC.
    
    (define (tai-to-utc-offset-at-tai-second-loop tai-second alist)
      (cond
       ((null? alist) 10)
       ((>= tai-second (caar alist)) (cdar alist))
       (else (tai-to-utc-offset-at-tai-second-loop tai-second (cdr alist)))))
    
    (define (tai-to-utc-offset-at-tai-second tai-second)
      (tai-to-utc-offset-at-tai-second-loop
       tai-second
       (cache-tai-second-alist (cache))))))
;; Copyright (c) 2012 Alan Watson. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;; This library implements TAI clocks with an epoch of 1970-01-01
;; 00:00:00 TAI.

(define-library (scheme time tai)
  
  (export make-tai-clock)
  
  (import (scheme base))
  (import (scheme time tai-to-utc-offset))
  
  (begin
    
    (define seconds-per-day (* 24.0 60.0 60.0))
    
    (define (make-tai-clock-from-tai-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        second)
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    (define (make-tai-clock-from-posix-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        (+ second (tai-to-utc-offset-at-utc-day (/ second seconds-per-day))))
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    (define (make-tai-clock-from-ntp-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        (+ second
           (tai-to-utc-offset-at-utc-day (/ second seconds-per-day))
           (if leap-second-indicator 1.0 0.0)))
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    ;; (make-tai-clock type call-with-current-clock-values)
    ;;
    ;; The make-tai-clock procedure returns a procedure that, when
    ;; called with no arguments, returns an estimate of the number of
    ;; TAI seconds since 1970-01-01 00:00:00 TAI.
    ;;
    ;; The type and call-with-current-clock-values argument should
    ;; conform to the descriptions in the documentation of the (clock
    ;; system-clock) library.
    
    (define (make-tai-clock type call-with-current-clock-values)
      (case type
        ((tai-like)
         (make-tai-clock-from-tai-like-clock call-with-current-clock-values))
        ((posix-like)
         (make-tai-clock-from-posix-like-clock call-with-current-clock-values))
        ((ntp-like)
         (make-tai-clock-from-ntp-like-clock call-with-current-clock-values))
        (else
         (error "invalid clock type" type))))))

(define-library (scheme cxr)
  (import (chibi))
  (export
   caaar caadr cadar caddr cdaar cdadr cddar cdddr
   caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr)
  (include "cxr.scm"))
;; This library is deprecated, occurring in early R7RS drafts before
;; being removed.

(define-library (scheme division)
  (import (chibi))
  (export ceiling-quotient ceiling-remainder ceiling/
          centered-quotient centered-remainder centered/
          euclidean-quotient euclidean-remainder euclidean/
          floor-quotient floor-remainder floor/
          round-quotient round-remainder round/
          truncate-quotient truncate-remainder truncate/)
  ;; The second definition is always valid, but the first is simpler
  ;; and faster if exact ratios are supported and handled correctly
  ;; but floor/ceil/round.
  (cond-expand
   (ratios
    (begin
      (define-syntax copy-exactness2
        (syntax-rules ()
          ((copy-exactness2 src1 src2 expr)
           expr)))))
   (else
    (begin
      (define-syntax copy-exactness2
        (syntax-rules ()
          ((copy-exactness2 src1 src2 expr)
           (let ((tmp expr))
             (if (and (exact? src1) (exact? src2))
                 (inexact->exact tmp)
                 tmp))))))))
  (include "division.scm"))
;; This library is deprecated, occurring in early R7RS drafts before
;; being removed.

(define-library (scheme char normalization)
  (import (rename (chibi)
                  (string=? string-ni=?)
                  (string<? string-ni<?)
                  (string>? string-ni>?)
                  (string<=? string-ni<=?)
                  (string>=? string-ni>=?)))
  (export string-ni=? string-ni<? string-ni>? string-ni<=? string-ni>=?))

(define (char-alphabetic? ch) (char-set-contains? char-set:letter ch))
(define (char-lower-case? ch) (char-set-contains? char-set:lower-case ch))
(define (char-upper-case? ch) (char-set-contains? char-set:upper-case ch))
(define (char-numeric? ch) (char-set-contains? char-set:digit ch))
(define (char-whitespace? ch) (char-set-contains? char-set:whitespace ch))

(define (char-downcase ch)
  (let ((n (char->integer ch)))
    (let lp ((ls char-downcase-offsets))
      (cond
       ((null? ls)
        (let lp ((lo 0) (hi (vector-length char-downcase-map)))
          (if (> lo hi)
              ch
              (let* ((mid (+ lo (* (quotient (- hi lo) 4) 2)))
                     (m (vector-ref char-downcase-map mid)))
                (cond
                 ((= n m)
                  (integer->char (vector-ref char-downcase-map (+ mid 1))))
                 ((< n m)
                  (lp lo (- mid 2)))
                 (else
                  (lp (+ mid 2) hi)))))))
       ((iset-contains? (caar ls) n)
        (integer->char (+ n (cdar ls))))
       (else (lp (cdr ls)))))))

(define char-foldcase char-downcase)

(define (char-upcase ch)
  (let ((n (char->integer ch)))
    (let lp ((ls char-downcase-offsets))
      (cond
       ((null? ls)
        (let lp ((lo 0) (hi (vector-length char-upcase-map)))
          (if (> lo hi)
              ch
              (let* ((mid (+ lo (* (quotient (- hi lo) 4) 2)))
                     (m (vector-ref char-upcase-map mid)))
                (cond
                 ((= n m)
                  (integer->char (vector-ref char-upcase-map (+ mid 1))))
                 ((< n m)
                  (lp lo (- mid 2)))
                 (else
                  (lp (+ mid 2) hi)))))))
       ((iset-contains? (caar ls) (- n (cdar ls)))
        (integer->char (- n (cdar ls))))
       (else (lp (cdr ls)))))))

(define (char-cmp-ci op a ls)
  (let lp ((op op) (a (char->integer (char-foldcase a))) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (char-downcase (car ls)))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char-ci=? a . ls) (char-cmp-ci = a ls))
(define (char-ci<? a . ls) (char-cmp-ci < a ls))
(define (char-ci>? a . ls) (char-cmp-ci > a ls))
(define (char-ci<=? a . ls) (char-cmp-ci <= a ls))
(define (char-ci>=? a . ls) (char-cmp-ci >= a ls))

(define (char-get-special-case ch off)
  (let ((i (char->integer ch)))
    (let lp ((a 0) (b (vector-length special-cases)))
      (let* ((mid (+ a (quotient (- b a) 2)))
             (vec (vector-ref special-cases mid))
             (val (vector-ref vec 0)))
        (cond ((< i val) (and (< mid b) (lp a mid)))
              ((> i val) (and (> mid a) (lp mid b)))
              (else (vector-ref vec off)))))))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (string-down-or-fold-case str fold?)
  (call-with-output-string
    (lambda (out)
      (let ((in (open-input-string str)))
        (let lp ()
          (let ((ch (read-char in)))
            (cond
             ((not (eof-object? ch))
              (display
               (if (and (not fold?) (eqv? ch #\x03A3))
                   (let ((ch2 (peek-char in)))
                     (if (or (eof-object? ch2)
                             (not (char-set-contains? char-set:letter ch2)))
                         #\x03C2
                         #\x03C3))
                   (or (char-get-special-case ch 1) (char-downcase ch)))
               out)
              (lp)))))))))

(define (string-downcase str) (string-down-or-fold-case str #f))
(define (string-foldcase str) (string-down-or-fold-case str #t))

(define (string-upcase str)
  (call-with-output-string
    (lambda (out)
      (string-for-each
       (lambda (ch)
         (display (if (memv ch '(#\x03C2 #\x03C3))
                      #\x03A3
                      (or (char-get-special-case ch 3)
                          (char-upcase ch)))
                  out))
       str))))

(define (string-cmp-ci op a ls)
  (let lp ((op op) (a (string-foldcase a)) (ls ls))
    (if (null? ls)
        #t
        (let ((b (string-foldcase (car ls))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (string-ci=? a . ls) (string-cmp-ci string=? a ls))
(define (string-ci<? a . ls) (string-cmp-ci string<? a ls))
(define (string-ci>? a . ls) (string-cmp-ci string>? a ls))
(define (string-ci<=? a . ls) (string-cmp-ci string<=? a ls))
(define (string-ci>=? a . ls) (string-cmp-ci string>=? a ls))

(define char-foldcase char-downcase)

(define (string-downcase str)
  (string-map char-downcase str))

(define (string-upcase str)
  (string-map char-upcase str))

(define (string-foldcase str)
  (string-map char-foldcase str))
(define char-downcase-offsets (list (cons (%make-iset 8579 8579 #f (%make-iset 880 1318 727785128884533462021393239927996327852405488163715491688443665188997571489595753887351274307852390522542297450010406753856251110621253 (%make-iset 256 590 46622255956467149554182616418411281498693699703261745055828801286035997868185593113689917615708132693 #f #f) (%make-iset 7680 7934 154389452316421593898094646677763852341147247234746543203694500835710989587797 #f #f)) (%make-iset 42560 42646 340282366921041625127166164553021347157 (%make-iset 11360 11506 6277101735386773453122860106355103562402757378851211577985 #f #f) (%make-iset 42786 42920 6277101735386680792844867735842886829046547597890503906645 #f #f))) 1) (cons (%make-iset 913 1071 6277101736117431582331099698849039600728809650576250765311 (%make-iset 65 222 6277101735750628925305668009417060106580289400525817905151 #f #f) (%make-iset 65313 65338 #f #f #f)) 32) (cons (%make-iset 11264 11310 #f (%make-iset 1329 1366 #f #f #f) #f) 48) (cons (%make-iset 7944 8169 80881074129870197631446573842447034610982086425645202976396910985471 #f #f) -8) (cons (%make-iset 9398 9423 #f #f #f) 26) (cons (%make-iset 4256 4301 36009005809663 #f #f) 7264) (cons (%make-iset 66560 66599 #f #f #f) 40)))

(define char-downcase-map (quote #(181 956 376 255 383 115 385 595 390 596 393 598 394 599 398 477 399 601 400 603 403 608 404 611 406 617 407 616 412 623 413 626 415 629 422 640 425 643 430 648 433 650 434 651 439 658 452 454 455 457 458 460 497 499 502 405 503 447 544 414 570 11365 573 410 574 11366 579 384 580 649 581 652 837 953 902 940 904 941 905 942 906 943 908 972 910 973 911 974 975 983 976 946 977 952 981 966 982 960 1008 954 1009 961 1012 952 1013 949 1017 1010 1021 891 1022 892 1023 893 1024 1104 1025 1105 1026 1106 1027 1107 1028 1108 1029 1109 1030 1110 1031 1111 1032 1112 1033 1113 1034 1114 1035 1115 1036 1116 1037 1117 1038 1118 1039 1119 1216 1231 7835 7777 8122 8048 8123 8049 8126 953 8136 8050 8137 8051 8138 8052 8139 8053 8154 8054 8155 8055 8170 8058 8171 8059 8172 8165 8184 8056 8185 8057 8186 8060 8187 8061 8486 969 8490 107 8491 229 8498 8526 8544 8560 8545 8561 8546 8562 8547 8563 8548 8564 8549 8565 8550 8566 8551 8567 8552 8568 8553 8569 8554 8570 8555 8571 8556 8572 8557 8573 8558 8574 8559 8575 11362 619 11363 7549 11364 637 11373 593 11374 625 11375 592 11376 594 11390 575 11391 576 42877 7545 42893 613 42922 614)))

(define char-upcase-map (quote #(107 8490 115 383 229 8491 255 376 384 579 405 502 410 573 414 544 447 503 454 452 457 455 460 458 477 398 499 497 575 11390 576 11391 592 11375 593 11373 594 11376 595 385 596 390 598 393 599 394 601 399 603 400 608 403 611 404 613 42893 614 42922 616 407 617 406 619 11362 623 412 625 11374 626 413 629 415 637 11364 640 422 643 425 648 430 649 580 650 433 651 434 652 581 658 439 891 1021 892 1022 893 1023 940 902 941 904 942 905 943 906 946 976 949 1013 1010 1017 952 1012 952 977 953 837 953 8126 954 1008 956 181 960 982 961 1009 966 981 969 8486 972 908 973 910 974 911 983 975 1104 1024 1105 1025 1106 1026 1107 1027 1108 1028 1109 1029 1110 1030 1111 1031 1112 1032 1113 1033 1114 1034 1115 1035 1116 1036 1117 1037 1118 1038 1119 1039 1231 1216 7545 42877 7549 11363 7777 7835 8048 8122 8049 8123 8050 8136 8051 8137 8052 8138 8053 8139 8054 8154 8055 8155 8056 8184 8057 8185 8058 8170 8059 8171 8060 8186 8061 8187 8165 8172 8526 8498 8560 8544 8561 8545 8562 8546 8563 8547 8564 8548 8565 8549 8566 8550 8567 8551 8568 8552 8569 8553 8570 8554 8571 8555 8572 8556 8573 8557 8574 8558 8575 8559 11365 570 11366 574)))

;; Unconditoinal non-1-to-1 case mappings derived from Unicode data
;; file SpecialCasing.txt.

(define special-cases
  ;; <code> <lower> <title> <upper>
  #(#(223 "" "Ss" "SS")
    #(304 "i" "" "")
    #(329 "" "N" "N")
    #(496 "" "J" "J")
    #(912 "" "" "")
    #(944 "" "" "")
    #(1415 "" "" "")
    #(7830 "" "H" "H")
    #(7831 "" "T" "T")
    #(7832 "" "W" "W")
    #(7833 "" "Y" "Y")
    #(7834 "" "A" "A")
    #(8016 "" "" "")
    #(8018 "" "" "")
    #(8020 "" "" "")
    #(8022 "" "" "")
    #(8064 "" "" "")
    #(8065 "" "" "")
    #(8066 "" "" "")
    #(8067 "" "" "")
    #(8068 "" "" "")
    #(8069 "" "" "")
    #(8070 "" "" "")
    #(8071 "" "" "")
    #(8072 "" "" "")
    #(8073 "" "" "")
    #(8074 "" "" "")
    #(8075 "" "" "")
    #(8076 "" "" "")
    #(8077 "" "" "")
    #(8078 "" "" "")
    #(8079 "" "" "")
    #(8080 "" "" "")
    #(8081 "" "" "")
    #(8082 "" "" "")
    #(8083 "" "" "")
    #(8084 "" "" "")
    #(8085 "" "" "")
    #(8086 "" "" "")
    #(8087 "" "" "")
    #(8088 "" "" "")
    #(8089 "" "" "")
    #(8090 "" "" "")
    #(8091 "" "" "")
    #(8092 "" "" "")
    #(8093 "" "" "")
    #(8094 "" "" "")
    #(8095 "" "" "")
    #(8096 "" "" "")
    #(8097 "" "" "")
    #(8098 "" "" "")
    #(8099 "" "" "")
    #(8100 "" "" "")
    #(8101 "" "" "")
    #(8102 "" "" "")
    #(8103 "" "" "")
    #(8104 "" "" "")
    #(8105 "" "" "")
    #(8106 "" "" "")
    #(8107 "" "" "")
    #(8108 "" "" "")
    #(8109 "" "" "")
    #(8110 "" "" "")
    #(8111 "" "" "")
    #(8114 "" "" "")
    #(8115 "" "" "")
    #(8116 "" "" "")
    #(8118 "" "" "")
    #(8119 "" "" "")
    #(8124 "" "" "")
    #(8130 "" "" "")
    #(8131 "" "" "")
    #(8132 "" "" "")
    #(8134 "" "" "")
    #(8135 "" "" "")
    #(8140 "" "" "")
    #(8146 "" "" "")
    #(8147 "" "" "")
    #(8150 "" "" "")
    #(8151 "" "" "")
    #(8162 "" "" "")
    #(8163 "" "" "")
    #(8164 "" "" "")
    #(8166 "" "" "")
    #(8167 "" "" "")
    #(8178 "" "" "")
    #(8179 "" "" "")
    #(8180 "" "" "")
    #(8182 "" "" "")
    #(8183 "" "" "")
    #(8188 "" "" "")
    #(64256 "" "Ff" "FF")
    #(64257 "" "Fi" "FI")
    #(64258 "" "Fl" "FL")
    #(64259 "" "Ffi" "FFI")
    #(64260 "" "Ffl" "FFL")
    #(64261 "" "St" "ST")
    #(64262 "" "St" "ST")
    #(64275 "" "" "")
    #(64276 "" "" "")
    #(64277 "" "" "")
    #(64278 "" "" "")
    #(64279 "" "" "")))

(define-library (scheme file)
  (import (chibi) (only (chibi filesystem) delete-file file-exists?))
  (export
   call-with-input-file call-with-output-file
   delete-file file-exists?
   open-binary-input-file open-binary-output-file
   open-input-file open-output-file
   with-input-from-file with-output-to-file))

(cond-expand
 (full-unicode
  (define zeros
    '#(#\x0030                ;DIGIT ZERO
       #\x0660                ;ARABIC-INDIC DIGIT ZERO
       #\x06F0                ;EXTENDED ARABIC-INDIC DIGIT ZERO
       #\x07C0                ;NKO DIGIT ZERO
       #\x0966                ;DEVANAGARI DIGIT ZERO
       #\x09E6                ;BENGALI DIGIT ZERO
       #\x0A66                ;GURMUKHI DIGIT ZERO
       #\x0AE6                ;GUJARATI DIGIT ZERO
       #\x0B66                ;ORIYA DIGIT ZERO
       #\x0BE6                ;TAMIL DIGIT ZERO
       #\x0C66                ;TELUGU DIGIT ZERO
       #\x0CE6                ;KANNADA DIGIT ZERO
       #\x0D66                ;MALAYALAM DIGIT ZERO
       #\x0E50                ;THAI DIGIT ZERO
       #\x0ED0                ;LAO DIGIT ZERO
       #\x0F20                ;TIBETAN DIGIT ZERO
       #\x1040                ;MYANMAR DIGIT ZERO
       #\x1090                ;MYANMAR SHAN DIGIT ZERO
       #\x17E0                ;KHMER DIGIT ZERO
       #\x1810                ;MONGOLIAN DIGIT ZERO
       #\x1946                ;LIMBU DIGIT ZERO
       #\x19D0                ;NEW TAI LUE DIGIT ZERO
       #\x1A80                ;TAI THAM HORA DIGIT ZERO
       #\x1A90                ;TAI THAM THAM DIGIT ZERO
       #\x1B50                ;BALINESE DIGIT ZERO
       #\x1BB0                ;SUNDANESE DIGIT ZERO
       #\x1C40                ;LEPCHA DIGIT ZERO
       #\x1C50                ;OL CHIKI DIGIT ZERO
       #\xA620                ;VAI DIGIT ZERO
       #\xA8D0                ;SAURASHTRA DIGIT ZERO
       #\xA900                ;KAYAH LI DIGIT ZERO
       #\xA9D0                ;JAVANESE DIGIT ZERO
       #\xAA50                ;CHAM DIGIT ZERO
       #\xABF0                ;MEETEI MAYEK DIGIT ZERO
       #\xFF10                ;FULLWIDTH DIGIT ZERO
       #\x104A0               ;OSMANYA DIGIT ZERO
       #\x11066               ;BRAHMI DIGIT ZERO
       #\x1D7CE               ;MATHEMATICAL BOLD DIGIT ZERO
       #\x1D7D8               ;MATHEMATICAL DOUBLE-STRUCK DIGIT ZERO
       #\x1D7E2               ;MATHEMATICAL SANS-SERIF DIGIT ZERO
       #\x1D7EC               ;MATHEMATICAL SANS-SERIF BOLD DIGIT ZERO
       #\x1D7F6               ;MATHEMATICAL MONOSPACE DIGIT ZERO
       )))
 (else
  (define zeros #(#\0))))

(define (digit-value ch)
  (let ((n (char->integer ch)))
    (let lp ((lo 0) (hi (- (vector-length zeros) 1)))
      (if (> lo hi)
          #f
          (let* ((mid (+ lo (quotient (- hi lo) 2)))
                 (mid-zero (char->integer (vector-ref zeros mid))))
            (cond
             ((<= mid-zero n (+ mid-zero 9))
              (- n mid-zero))
             ((< n mid-zero)
              (lp lo (- mid 1)))
             (else
              (lp (+ mid 1) hi))))))))

(define-syntax define-values
  (syntax-rules ()
    ((define-values () expr)
     (define dummy
       (call-with-values (lambda () expr)
         (lambda args #f))))
    ((define-values (var) expr)
     (define var expr))
    ((define-values (var0 var1 ... varn) expr)
     (begin
       (define var0
         (call-with-values (lambda () expr) list))
       (define var1
         (let ((v (cadr var0)))
           (set-cdr! var0 (cddr var0))
           v))
       ...
       (define varn
         (let ((v (cadr var0)))
           (set! var0 (car var0))
           v))))
    ((define-values (var0 var1 ... . var-dot) expr)
     (begin
       (define var0
         (call-with-values (lambda () expr) list))
       (define var1
         (let ((v (cadr var0)))
           (set-cdr! var0 (cddr var0))
           v))
       ...
       (define var-dot
         (let ((v (cdr var0)))
           (set! var0 (car var0))
           v))))
    ((define-values var expr)
     (define var
       (call-with-values (lambda () expr) list)))))
;; meta.scm -- meta langauge for describing modules
;; Copyright (c) 2009-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; modules

(define *this-module* '())
(define *this-path* '())

(define (make-module exports env meta) (vector exports env meta #f))
(define (%module-exports mod) (vector-ref mod 0))
(define (module-env mod) (vector-ref mod 1))
(define (module-env-set! mod env) (vector-set! mod 1 env))
(define (module-meta-data mod) (vector-ref mod 2))
(define (module-meta-data-set! mod x) (vector-set! mod 2 x))

(define (module-exports mod)
  (or (%module-exports mod)
      (if (module-env mod)
          (env-exports (module-env mod))
          '())))

(define (module-name->strings ls res)
  (if (null? ls)
      res
      (let ((str (cond ((symbol? (car ls)) (symbol->string (car ls)))
                       ((number? (car ls)) (number->string (car ls)))
                       ((string? (car ls)) (car ls))
                       (else (error "invalid module name" (car ls))))))
        (module-name->strings (cdr ls) (cons "/" (cons str res))))))

(define (module-name->file name)
  (string-concatenate
   (reverse (cons ".sld" (cdr (module-name->strings name '()))))))

(define (module-name-prefix name)
  (string-concatenate (reverse (cdr (cdr (module-name->strings name '()))))))

(define load-module-definition
  (let ((meta-env (current-environment)))
    (lambda (name)
      (let* ((file (module-name->file name))
             (path (find-module-file file)))
        (if path (load path meta-env))))))

(define (find-module name)
  (cond
   ((assoc name *modules*) => cdr)
   (else
    (load-module-definition name)
    (cond ((assoc name *modules*) => cdr)
          (else #f)))))

(define (add-module! name module)
  (set! *modules* (cons (cons name module) *modules*)))

(define (delete-module! name)
  (let lp ((ls *modules*) (prev #f))
    (cond ((null? ls))
          ((equal? name (car (car ls)))
           (if prev
               (set-cdr! prev (cdr ls))
               (set! *modules* (cdr ls))))
          (else (lp (cdr ls) ls)))))

(define (symbol-append a b)
  (string->symbol (string-append (symbol->string a) (symbol->string b))))

(define (symbol-drop a b)
  (let ((as (symbol->string a))
        (bs (symbol->string b)))
    (if (and (> (string-length bs) (string-length as))
             (string=? as (substring bs 0 (string-length as))))
        (string->symbol (substring bs (string-length as)))
        b)))

(define (warn msg . args)
  (display msg (current-error-port))
  (display ":" (current-error-port))
  (for-each (lambda (a)
              (display " " (current-error-port))
              (write a (current-error-port)))
            args)
  (newline (current-error-port)))

(define (to-id id) (if (pair? id) (car id) id))
(define (from-id id) (if (pair? id) (cdr id) id))
(define (id-filter pred ls)
  (cond ((null? ls) '())
        ((pred (to-id (car ls))) (cons (car ls) (id-filter pred (cdr ls))))
        (else (id-filter pred (cdr ls)))))

(define (resolve-import x)
  (cond
   ((not (and (pair? x) (list? x)))
    (error "invalid module syntax" x))
   ((and (memq (car x) '(prefix drop-prefix))
         (symbol? (car (cddr x))) (list? (cadr x)))
    (let ((mod-name+imports (resolve-import (cadr x))))
      (cons (car mod-name+imports)
            (map (lambda (i)
                   (cons ((if (eq? (car x) 'drop-prefix)
                              symbol-drop
                              symbol-append)
                          (car (cddr x))
                          (to-id i))
                         (from-id i)))
                 (or (cdr mod-name+imports)
                     (module-exports (find-module (car mod-name+imports))))))))
   ((and (pair? (cdr x)) (pair? (cadr x)))
    (if (memq (car x) '(only except rename))
        (let* ((mod-name+imports (resolve-import (cadr x)))
               (imp-ids (or (cdr mod-name+imports)
                            (and (not (eq? 'only (car x)))
                                 (module-exports
                                  (find-module (car mod-name+imports)))))))
          ;; (if (not (eq? 'only (car x)))
          ;;     (let ((unbound
          ;;            (id-filter (lambda (i) (not (memq i imp-ids))) (cddr x))))
          ;;       (if (pair? unbound)
          ;;           (warn "import excepting unbound identifiers" unbound))))
          (cons (car mod-name+imports)
                (case (car x)
                  ((only)
                   (cddr x))
                  ((except)
                   (id-filter (lambda (i) (not (memq i (cddr x)))) imp-ids))
                  ((rename)
                   (map (lambda (i)
                          (let ((rename (assq (to-id i) (cddr x))))
                            (if rename (cons (cadr rename) (from-id i)) i)))
                        imp-ids)))))
        (error "invalid import modifier" x)))
   ((find-module x)
    => (lambda (mod) (cons x (%module-exports mod))))
   (else
    (error "couldn't find import" x))))

(define (eval-module name mod . o)
  (let ((env (if (pair? o) (car o) (make-environment)))
        (meta (module-meta-data mod))
        (dir (module-name-prefix name)))
    (define (load-modules files extension fold?)
      (for-each
       (lambda (f)
         (let ((f (string-append dir f extension)))
           (cond
            ((find-module-file f)
             => (lambda (path)
                  (cond (fold?
                         (let ((in (open-input-file path)))
                           (set-port-fold-case! in #t)
                           (load in env)))
                        (else
                         (load path env)))))
            (else (error "couldn't find include" f)))))
       files))
    ;; catch cyclic references
    (cond
     ((procedure? meta)
      (meta env))
     (else
      (module-meta-data-set!
       mod
       `((error "module attempted to reference itself while loading" ,name)))
      (for-each
       (lambda (x)
         (case (and (pair? x) (car x))
           ((import import-immutable)
            (for-each
             (lambda (m)
               (let* ((mod2-name+imports (resolve-import m))
                      (mod2 (load-module (car mod2-name+imports))))
                 (%import env (module-env mod2) (cdr mod2-name+imports) #t)))
             (cdr x)))))
       meta)
      (protect
          (exn (else
                (module-meta-data-set! mod meta)
                (if (not (any (lambda (x)
                                (and (pair? x)
                                     (memq (car x) '(import import-immutable))))
                              meta))
                    (warn "WARNING: exception inside module with no imports - did you forget to (import (scheme base)) in" name))
                (raise-continuable exn)))
        (for-each
         (lambda (x)
           (case (and (pair? x) (car x))
             ((include)
              (load-modules (cdr x) "" #f))
             ((include-ci)
              (load-modules (cdr x) "" #t))
             ((include-shared)
              (load-modules (cdr x) *shared-object-extension* #f))
             ((body begin)
              (for-each (lambda (expr) (eval expr env)) (cdr x)))
             ((error)
              (apply error (cdr x)))))
         meta))
      (module-meta-data-set! mod meta)
      (warn-undefs env #f)
      env))))

(define (environment . ls)
  (let ((env (make-environment)))
    (for-each
     (lambda (m)
       (let* ((mod2-name+imports (resolve-import m))
              (mod2 (load-module (car mod2-name+imports))))
         (%import env (module-env mod2) (cdr mod2-name+imports) #t)))
     ls)
    env))

(define (load-module name)
  (let ((mod (find-module name)))
    (if (and mod (not (module-env mod)))
        (module-env-set! mod (eval-module name mod)))
    mod))

(define-syntax meta-begin begin)
(define-syntax meta-define define)

(define define-library-transformer
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((name (cadr expr))
           (body (cddr expr))
           (tmp (rename 'tmp))
           (this-module (rename '*this-module*))
           (add-module! (rename 'add-module!))
           (_make-module (rename 'make-module))
           (_define (rename 'meta-define))
           (_lambda (rename 'lambda))
           (_let (rename 'let))
           (_map (rename 'map))
           (_if (rename 'if))
           (_cond (rename 'cond))
           (_set! (rename 'set!))
           (_quote (rename 'quote))
           (_and (rename 'and))
           (_= (rename '=))
           (_eq? (rename 'eq?))
           (_pair? (rename 'pair?))
           (_null? (rename 'null?))
           (_reverse (rename 'reverse))
           (_append (rename 'append))
           (_assq (rename 'assq))
           (_=> (rename '=>))
           (_else (rename 'else))
           (_length (rename 'length))
           (_identifier->symbol (rename 'identifier->symbol))
           (_error (rename 'error))
           (_cons (rename 'cons))
           (_car (rename 'car))
           (_cdr (rename 'cdr))
           (_caar (rename 'caar))
           (_cadr (rename 'cadr))
           (_cdar (rename 'cdar))
           (_cddr (rename 'cddr)))
       ;; Check for suspicious defines.
       (for-each
        (lambda (x)
          (if (and (pair? x) (memq (strip-syntactic-closures (car x))
                                   '(define define-syntax)))
              (warn "suspicious use of define in library declarations - did you forget to wrap it in begin?" x)))
        (cdr expr))
       ;; Generate the library wrapper.
       (set! *this-path*
             (cons (string-concatenate
                    (module-name->strings (cdr (reverse name)) '()))
                   *this-path*))
       `(,_let ((,tmp ,this-module))
          (,_define (rewrite-export x)
            (,_if (,_pair? x)
                (,_if (,_and (,_= 3 (,_length x))
                             (,_eq? (,_quote rename)
                                    (,_identifier->symbol (,_car x))))
                    (,_cons (,_car (,_cddr x)) (,_cadr x))
                    (,_error "invalid module export" x))
                x))
          (,_define (extract-exports)
            (,_cond
             ((,_assq (,_quote export-all) ,this-module)
              ,_=> (,_lambda (x)
                     (,_if (,_pair? (,_cdr x))
                         (,_error "export-all takes no parameters" x))
                     #f))
             (,_else
              (,_let lp ((ls ,this-module) (res (,_quote ())))
                (,_cond
                 ((,_null? ls) res)
                 ((,_and (,_pair? (,_car ls))
                         (,_eq? (,_quote export) (,_caar ls)))
                  (lp (,_cdr ls)
                      (,_append (,_map rewrite-export (,_cdar ls)) res)))
                 (,_else (lp (,_cdr ls) res)))))))
          (,_set! ,this-module (,_quote ()))
          ,@body
          (,add-module! (,_quote ,name)
                        (,_make-module (extract-exports)
                                       #f
                                       (,_reverse ,this-module)))
          (,_set! ,this-module ,tmp)
          (,(rename 'pop-this-path)))))))

(define-syntax define-library define-library-transformer)
(define-syntax module define-library-transformer)

(define-syntax pop-this-path
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (pair? *this-path*)
         (set! *this-path* (cdr *this-path*)))
     #f)))

(define-syntax include-library-declarations
  (er-macro-transformer
   (lambda (expr rename compare)
     (let lp1 ((ls (cdr expr)) (res '()))
       (cond
        ((pair? ls)
         (let* ((file (car ls))
                (rel-path (if (pair? *this-path*)
                              (string-append (car *this-path*) "/" file)
                              file)))
           (cond
            ((find-module-file rel-path)
             => (lambda (path)
                  (call-with-input-file path
                    (lambda (in)
                      (let lp2 ((res res))
                        (let ((x (read in)))
                          (if (eof-object? x)
                              (lp1 (cdr ls) res)
                              (lp2 (cons x res)))))))))
            (else
             (error "couldn't find include-library-declarations file" file)))))
        (else
         `(,(rename 'meta-begin)
           ,@(reverse res)
           (,(rename 'set!) ,(rename '*this-module*)
            (,(rename 'cons) (,(rename 'quote)
                              ,(cons 'include-library-declarations (cdr expr)))
             ,(rename '*this-module*))))))))))

(define-syntax define-meta-primitive
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((name (cadr expr)))
       `(define-syntax ,name
          (er-macro-transformer
           (lambda (expr rename compare)
             (let ((this-module (rename '*this-module*))
                   (_set! (rename 'set!))
                   (_cons (rename 'cons))
                   (_quote (rename 'syntax-quote)))
               `(,_set! ,this-module
                        (,_cons (,_quote ,(cons ',name (cdr expr)))
                                ,this-module))))))))))

(define-meta-primitive import)
(define-meta-primitive import-immutable)
(define-meta-primitive export)
(define-meta-primitive export-all)
(define-meta-primitive include)
(define-meta-primitive include-ci)
(define-meta-primitive include-shared)
(define-meta-primitive body)
(define-meta-primitive begin)

;; The `import' binding used by (chibi) and (scheme base), etc.
(define-syntax repl-import
  (er-macro-transformer
   (let ((meta-env (current-environment)))
     (lambda (expr rename compare)
       (let lp ((ls (cdr expr)) (res '()))
         (cond
          ((null? ls)
           (cons (rename 'meta-begin) (reverse res)))
          (else
           (let ((mod+imps (resolve-import (car ls))))
             (cond
              ((pair? mod+imps)
               (lp (cdr ls)
                   (cons `(,(rename '%import)
                           #f
                           (,(rename 'module-env)
                            (,(rename 'load-module)
                             (,(rename 'quote) ,(car mod+imps))))
                           (,(rename 'quote) ,(cdr mod+imps))
                           #f)
                         res)))
              (else
               (error "couldn't find module" (car ls))))))))))))

(define *modules*
  (list
   (cons '(chibi)
         ;; capture a static copy of the current environment to serve
         ;; as the (chibi) module
         (let ((env (make-environment)))
           (%import env (interaction-environment) #f #t)
           (make-module #f (env-parent env) '((include "init-7.scm")))))
   (cons '(chibi primitive)
         (make-module #f #f (lambda (env) (primitive-environment 7))))
   (cons '(meta)
         (make-module #f (current-environment) '()))
   (cons '(srfi 0)
         (make-module (list 'cond-expand)
                      (current-environment)
                      (list (list 'export 'cond-expand))))))
;; init-7.scm -- core library procedures for R7RS
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (cons-source kar kdr source)
  ((lambda (pair)
     (if (pair? source)
         (pair-source-set! pair (pair-source source)))
     pair)
   (cons kar kdr)))

;; basic utils

(define (procedure? x) (if (closure? x) #t (opcode? x)))

(define (length ls)
  (if (list? ls) (length* ls) (error "length: not a list" ls)))

(define (list . args) args)

(define (list-tail ls k)
  (if (eq? k 0)
      ls
      (list-tail (cdr ls) (- k 1))))

(define (list-ref ls k) (car (list-tail ls k)))

(define (append-helper ls res)
  (if (null? ls)
      res
      (append-helper (cdr ls) (append2 (car ls) res))))

(define (append . o)
  (if (null? o)
      '()
      ((lambda (lol)
         (append-helper (cdr lol) (car lol)))
       (reverse o))))

(define (apply proc . args)
  (if (null? args)
      (proc)
      ((lambda (lol)
         (apply1 proc (append2 (reverse (cdr lol)) (car lol))))
       (reverse args))))

;; map with a fast-path for single lists

(define (map proc ls . lol)
  (define (map1 proc ls res)
    (if (pair? ls)
        (map1 proc (cdr ls) (cons (proc (car ls)) res))
        (reverse res)))
  (define (mapn proc lol res)
    (if (every pair? lol)
        (mapn proc
              (map1 cdr lol '())
              (cons (apply proc (map1 car lol '())) res))
        (reverse res)))
  (if (null? lol)
      (map1 proc ls '())
      (mapn proc (cons ls lol) '())))

(define (for-each f ls . lol)
  (define (for1 f ls) (if (pair? ls) (begin (f (car ls)) (for1 f (cdr ls)))))
  (if (null? lol) (for1 f ls) (begin (apply map f ls lol) (if #f #f))))

(define (any pred ls . lol)
  (define (any1 pred ls)
    (if (pair? (cdr ls))
        ((lambda (x) (if x x (any1 pred (cdr ls)))) (pred (car ls)))
        (pred (car ls))))
  (define (anyn pred lol)
    (if (every pair? lol)
        ((lambda (x) (if x x (anyn pred (map cdr lol))))
         (apply pred (map car lol)))
        #f))
  (if (null? lol) (if (pair? ls) (any1 pred ls) #f) (anyn pred (cons ls lol))))

(define (every pred ls . lol)
  (define (every1 pred ls)
    (if (null? (cdr ls))
        (pred (car ls))
        (if (pred (car ls)) (every1 pred (cdr ls)) #f)))
  (if (null? lol)
      (if (pair? ls) (every1 pred ls) #t)
      (not (apply any (lambda xs (not (apply pred xs))) ls lol))))

(define (error msg . args)
  (raise (make-exception 'user msg args #f #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax

(define sc-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      (make-syntactic-closure mac-env '() (f expr use-env)))))

(define rsc-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      (f expr mac-env))))

(define er-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      ((lambda (rename compare) (f expr rename compare))
       ((lambda (renames)
          (lambda (identifier)
            ((lambda (cell)
               (if cell
                   (cdr cell)
                   ((lambda (name)
                      (set! renames (cons (cons identifier name) renames))
                      name)
                    (make-syntactic-closure mac-env '() identifier))))
             (assq identifier renames))))
        '())
       (lambda (x y) (identifier=? use-env x use-env y))))))

(define-syntax cond
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr))
         (if #f #f)
         ((lambda (cl)
            (if (compare (rename 'else) (car cl))
                (if (pair? (cddr expr))
                    (error "non-final else in cond" expr)
                    (cons (rename 'begin) (cdr cl)))
                (if (if (null? (cdr cl)) #t (compare (rename '=>) (cadr cl)))
                    (list (list (rename 'lambda) (list (rename 'tmp))
                                (list (rename 'if) (rename 'tmp)
                                      (if (null? (cdr cl))
                                          (rename 'tmp)
                                          (list (car (cddr cl)) (rename 'tmp)))
                                      (cons (rename 'cond) (cddr expr))))
                          (car cl))
                    (list (rename 'if)
                          (car cl)
                          (cons (rename 'begin) (cdr cl))
                          (cons (rename 'cond) (cddr expr))))))
          (cadr expr))))))

(define-syntax or
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond ((null? (cdr expr)) #f)
           ((null? (cddr expr)) (cadr expr))
           (else
            (list (rename 'let) (list (list (rename 'tmp) (cadr expr)))
                  (list (rename 'if) (rename 'tmp)
                        (rename 'tmp)
                        (cons (rename 'or) (cddr expr)))))))))

(define-syntax and
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond ((null? (cdr expr)))
           ((null? (cddr expr)) (cadr expr))
           (else (list (rename 'if) (cadr expr)
                       (cons (rename 'and) (cddr expr))
                       #f))))))

(define-syntax quasiquote
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (qq x d)
       (cond
        ((pair? x)
         (cond
          ((compare (rename 'unquote) (car x))
           (if (<= d 0)
               (cadr x)
               (list (rename 'list) (list (rename 'quote) 'unquote)
                     (qq (cadr x) (- d 1)))))
          ((compare (rename 'unquote-splicing) (car x))
           (if (<= d 0)
               (list (rename 'cons) (qq (car x) d) (qq (cdr x) d))
               (list (rename 'list) (list (rename 'quote) 'unquote-splicing)
                     (qq (cadr x) (- d 1)))))
          ((compare (rename 'quasiquote) (car x))
           (list (rename 'list) (list (rename 'quote) 'quasiquote)
                 (qq (cadr x) (+ d 1))))
          ((and (<= d 0) (pair? (car x))
                (compare (rename 'unquote-splicing) (caar x)))
           (if (null? (cdr x))
               (cadr (car x))
               (list (rename 'append) (cadr (car x)) (qq (cdr x) d))))
          (else
           (list (rename 'cons) (qq (car x) d) (qq (cdr x) d)))))
        ((vector? x) (list (rename 'list->vector) (qq (vector->list x) d)))
        ((if (identifier? x) #t (null? x)) (list (rename 'quote) x))
        (else x)))
     (qq (cadr expr) 0))))

(define-syntax letrec
  (er-macro-transformer
   (lambda (expr rename compare)
     ((lambda (defs)
        `((,(rename 'lambda) () ,@defs ,@(cddr expr))))
      (map (lambda (x) (cons (rename 'define) x)) (cadr expr))))))

(define-syntax let
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "empty let" expr))
     (if (null? (cddr expr)) (error "no let body" expr))
     ((lambda (bindings)
        (if (list? bindings) #f (error "bad let bindings"))
        (if (every (lambda (x)
                     (if (pair? x) (if (pair? (cdr x)) (null? (cddr x)) #f) #f))
                   bindings)
            ((lambda (vars vals)
               (if (identifier? (cadr expr))
                   `((,(rename 'lambda) ,vars
                      (,(rename 'letrec) ((,(cadr expr)
                                           (,(rename 'lambda) ,vars
                                            ,@(cdr (cddr expr)))))
                       (,(cadr expr) ,@vars)))
                     ,@vals)
                   `((,(rename 'lambda) ,vars ,@(cddr expr)) ,@vals)))
             (map car bindings)
             (map cadr bindings))
            (error "bad let syntax" expr)))
      (if (identifier? (cadr expr)) (car (cddr expr)) (cadr expr))))))

(define-syntax let*
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "empty let*" expr))
     (if (null? (cddr expr)) (error "no let* body" expr))
     (if (null? (cadr expr))
         `(,(rename 'let) () ,@(cddr expr))
         (if (if (list? (cadr expr))
                 (every
                  (lambda (x)
                    (if (pair? x) (if (pair? (cdr x)) (null? (cddr x)) #f) #f))
                  (cadr expr))
                 #f)
             `(,(rename 'let) (,(caar (cdr expr)))
               (,(rename 'let*) ,(cdar (cdr expr)) ,@(cddr expr)))
             (error "bad let* syntax"))))))

(define-syntax case
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (body exprs)
       (cond
        ((null? exprs)
         (rename 'tmp))
        ((compare (rename '=>) (car exprs))
         `(,(cadr exprs) ,(rename 'tmp)))
        (else
         `(,(rename 'begin) ,@exprs))))
     (define (clause ls)
       (cond
        ((null? ls) #f)
        ((compare (rename 'else) (caar ls))
         (body (cdar ls)))
        ((and (pair? (car (car ls))) (null? (cdr (car (car ls)))))
         `(,(rename 'if) (,(rename 'eqv?) ,(rename 'tmp)
                          (,(rename 'quote) ,(car (caar ls))))
           ,(body (cdar ls))
           ,(clause (cdr ls))))
        (else
         `(,(rename 'if) (,(rename 'memv) ,(rename 'tmp)
                          (,(rename 'quote) ,(caar ls)))
           ,(body (cdar ls))
           ,(clause (cdr ls))))))
     `(let ((,(rename 'tmp) ,(cadr expr)))
        ,(clause (cddr expr))))))

(define-syntax do
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((body
             `(,(rename 'begin)
               ,@(cdr (cddr expr))
               (,(rename 'lp)
                ,@(map (lambda (x)
                         (if (pair? (cddr x))
                             (if (pair? (cdr (cddr x)))
                                 (error "too many forms in do iterator" x)
                                 (car (cddr x)))
                             (car x)))
                       (cadr expr)))))
            (check (car (cddr expr)))
            (wrap
             (if (null? (cdr check))
                 `(,(rename 'let) ((,(rename 'tmp) ,(car check)))
                   (,(rename 'if) ,(rename 'tmp)
                    ,(rename 'tmp)
                    ,body))
                 `(,(rename 'if) ,(car check)
                   (,(rename 'begin) ,@(cdr check))
                   ,body))))
       `(,(rename 'let) ,(rename 'lp)
         ,(map (lambda (x) (list (car x) (cadr x))) (cadr expr))
         ,wrap)))))

(define-syntax delay-force
  (er-macro-transformer
   (lambda (expr rename compare)
     `(,(rename 'promise) #f (,(rename 'lambda) () ,(cadr expr))))))

(define-syntax delay
  (er-macro-transformer
   (lambda (expr rename compare)
     `(,(rename 'delay-force) (,(rename 'promise) #t ,(cadr expr))))))

(define-syntax define-auxiliary-syntax
  (er-macro-transformer
   (lambda (expr rename compare)
     `(,(rename 'define-syntax) ,(cadr expr)
       (,(rename 'er-macro-transformer)
        (,(rename 'lambda) (expr rename compare)
         (,(rename 'error) "invalid use of auxiliary syntax" ',(cadr expr))))))))

(define-auxiliary-syntax _)
(define-auxiliary-syntax =>)
(define-auxiliary-syntax ...)
(define-auxiliary-syntax else)
(define-auxiliary-syntax unquote)
(define-auxiliary-syntax unquote-splicing)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library functions

;; booleans

(define (not x) (if x #f #t))
(define (boolean? x) (if (eq? x #t) #t (eq? x #f)))

;; char utils

(define (char-alphabetic? ch) (<= 65 (char->integer (char-upcase ch)) 90))
(define (char-numeric? ch) (<= 48 (char->integer ch) 57))
(define (char-whitespace? ch)
  (if (eq? ch #\space)
      #t
      (if (eq? ch #\tab) #t (if (eq? ch #\newline)
                                #t
                                (if (eq? ch #\xC0) #f (eq? ch #\return))))))
(define (char-upper-case? ch) (<= 65 (char->integer ch) 90))
(define (char-lower-case? ch) (<= 97 (char->integer ch) 122))

(define (char-cmp op a ls)
  (let lp ((op op) (a (char->integer a)) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (car ls))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char=? a . ls) (char-cmp = a ls))
(define (char<? a . ls) (char-cmp < a ls))
(define (char>? a . ls) (char-cmp > a ls))
(define (char<=? a . ls) (char-cmp <= a ls))
(define (char>=? a . ls) (char-cmp >= a ls))

(define (char-cmp-ci op a ls)
  (let lp ((op op) (a (char->integer (char-downcase a))) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (char-downcase (car ls)))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char-ci=? a . ls) (char-cmp-ci = a ls))
(define (char-ci<? a . ls) (char-cmp-ci < a ls))
(define (char-ci>? a . ls) (char-cmp-ci > a ls))
(define (char-ci<=? a . ls) (char-cmp-ci <= a ls))
(define (char-ci>=? a . ls) (char-cmp-ci >= a ls))

;; string utils

(define (digit-char n)
  (if (<= n 9)
      (integer->char (+ n (char->integer #\0)))
      (integer->char (+ (- n 10) (char->integer #\a)))))

(define (%number->string num)
  (call-with-output-string (lambda (out) (write num out))))

(define (number->string num . o)
  (cond
   ((not (number? num))
    (error "not a number" num))
   ((if (null? o) #t (eq? 10 (car o)))
    (%number->string num))
   (else
    (let lp ((n (abs num)) (d (car o)) (res '()))
      (if (> n 0)
          (lp (quotient n d) d (cons (digit-char (remainder n d)) res))
          (if (null? res)
              "0"
              (list->string (if (negative? num) (cons #\- res) res))))))))

(define (list->string ls)
  (call-with-output-string
    (lambda (out) (for-each (lambda (ch) (write-char ch out)) ls))))

(define (string->list str . o)
  (cond
   ((null? o)
    (let lp ((i (string-cursor-prev str (string-cursor-end str))) (res '()))
      (if (< i 0)
          res
          (lp (string-cursor-prev str i) (cons (string-cursor-ref str i) res)))))
   (else
    (string->list (apply substring str o)))))

(define (string-fill! str ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i (- end 1)))
      (if (>= i start) (begin (string-set! str i ch) (lp (- i 1)))))))

(define (string . args) (list->string args))
(define (string-append . args) (string-concatenate args))

(define (string-cmp-ls op ci? s ls)
  (if (null? ls)
      #t
      (and (op (string-cmp s (car ls) ci?) 0)
           (string-cmp-ls op ci? (car ls) (cdr ls)))))

(define (string=? s . ls) (string-cmp-ls eq? #f s ls))
(define (string<? s . ls) (string-cmp-ls < #f s ls))
(define (string>? s . ls) (string-cmp-ls > #f s ls))
(define (string<=? s . ls) (string-cmp-ls <= #f s ls))
(define (string>=? s . ls) (string-cmp-ls >= #f s ls))

(define (string-ci=? s . ls) (string-cmp-ls eq? #t s ls))
(define (string-ci<? s . ls) (string-cmp-ls < #t s ls))
(define (string-ci>? s . ls) (string-cmp-ls > #t s ls))
(define (string-ci<=? s . ls) (string-cmp-ls <= #t s ls))
(define (string-ci>=? s . ls) (string-cmp-ls >= #t s ls))

;; list utils

(define (make-list n . o)
  (let ((default (if (pair? o) (car o))))
    (let lp ((n n) (res '()))
      (if (<= n 0) res (lp (- n 1) (cons default res))))))

(define (list-copy ls)
  (let lp ((ls ls) (res '()))
    (if (pair? ls)
        (lp (cdr ls) (cons (car ls) res))
        (append (reverse res) ls))))

(define (member obj ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let lp ((ls ls))
      (and (pair? ls) (if (eq obj (car ls)) ls (lp (cdr ls)))))))

(define memv member)

(define (assoc obj ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let assoc ((ls ls))
      (cond ((null? ls) #f)
            ((eq obj (caar ls)) (car ls))
            (else (assoc (cdr ls)))))))

(define (assv obj ls) (assoc obj ls eqv?))

(define (find-tail pred ls)
  (and (pair? ls) (if (pred (car ls)) ls (find-tail pred (cdr ls)))))

(define (find pred ls)
  (cond ((find-tail pred ls) => car) (else #f)))

;; vector utils

(define (vector-copy vec . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec)))
         (res (make-vector (- end start))))
    (do ((i 0 (+ i 1)) (j start (+ j 1))) ((>= j end) res)
      (vector-set! res i (vector-ref vec j)))))

(define (list->vector ls)
  (let ((vec (make-vector (length ls) #f)))
    (let lp ((ls ls) (i 0))
      (if (pair? ls)
          (begin
            (vector-set! vec i (car ls))
            (lp (cdr ls) (+ i 1)))))
    vec))

(define (vector->list vec . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (let lp ((i (- end 1)) (res '()))
      (if (< i start) res (lp (- i 1) (cons (vector-ref vec i) res))))))

(define (vector-fill! vec ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (let lp ((i (- end 1)))
      (if (>= i start) (begin (vector-set! vec i ch) (lp (- i 1)))))))

(define (vector . args) (list->vector args))

;; I/O utils

(define (display x . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (cond ((char? x) (write-char x out))
          ((string? x) (%write-string x #t out))
          (else (write x out)))))

(define (newline . o)
  (write-char #\newline (if (pair? o) (car o) (current-output-port))))

(define (port? x) (or (input-port? x) (output-port? x)))

(define textual-port? port?)

(define (call-with-input-string str proc)
  (let* ((in (open-input-string str))
         (res (proc in)))
    (close-input-port in)
    res))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

(define (call-with-input-file file proc)
  (let* ((in (open-input-file file))
         (res (proc in)))
    (close-input-port in)
    res))

(define (call-with-output-file file proc)
  (let* ((out (open-output-file file))
         (res (proc out)))
    (close-output-port out)
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; values

(define *values-tag* (list 'values))

(define (%values ls)
  (if (and (pair? ls) (null? (cdr ls)))
      (car ls)
      (cons *values-tag* ls)))

(define (values . ls) (%values ls))

(define (call-with-values producer consumer)
  (let ((res (producer)))
    (if (and (pair? res) (eq? *values-tag* (car res)))
        (apply consumer (cdr res))
        (consumer res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SRFI-0

(define-syntax cond-expand
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (check x)
       (if (pair? x)
           (case (car x)
             ((and) (every check (cdr x)))
             ((or) (any check (cdr x)))
             ((not) (not (check (cadr x))))
             ((library) (eval `(find-module ',(cadr x)) (%meta-env)))
             (else (error "cond-expand: bad feature" x)))
           (memq (identifier->symbol x) *features*)))
     (let expand ((ls (cdr expr)))
       (cond ((null? ls))  ; (error "cond-expand: no expansions" expr)
             ((not (pair? (car ls))) (error "cond-expand: bad clause" (car ls)))
             ((eq? 'else (identifier->symbol (caar ls)))
              (if (pair? (cdr ls))
                  (error "cond-expand: else in non-final position")
                  `(,(rename 'begin) ,@(cdar ls))))
             ((check (caar ls)) `(,(rename 'begin) ,@(cdar ls)))
             (else (expand (cdr ls))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dynamic-wind

(define %make-point vector)
(define (%point-depth point) (vector-ref point 0))
(define (%point-in point) (vector-ref point 1))
(define (%point-out point) (vector-ref point 2))
(define (%point-parent point) (vector-ref point 3))

(define root-point			; Shared among all state spaces
  (%make-point 0
	      (lambda () (error "winding in to root!"))
	      (lambda () (error "winding out of root!"))
	      #f))

(cond-expand
 (threads)
 (else
  (define %dk
    (let ((dk root-point))
      (lambda o (if (pair? o) (set! dk (car o)) dk))))))

(%dk root-point)

(define (dynamic-wind in body out)
  (in)
  (let ((here (%dk)))
    (%dk (%make-point (+ (%point-depth here) 1)
                     in
                     out
                     here))
    (let ((res (body)))
      (%dk here)
      (out)
      res)))

(define (travel-to-point! here target)
  (cond
   ((eq? here target)
    'done)
   ((< (%point-depth here) (%point-depth target))
    (travel-to-point! here (%point-parent target))
    ((%point-in target)))
   (else
    ((%point-out here))
    (travel-to-point! (%point-parent here) target))))

(define (continuation->procedure cont point)
  (lambda res
    (travel-to-point! (%dk) point)
    (%dk point)
    (cont (%values res))))

(define (call-with-current-continuation proc)
  (%call/cc
   (lambda (cont)
     (proc (continuation->procedure cont (%dk))))))

(define (with-input-from-file file thunk)
  (let ((old-in (current-input-port))
        (tmp-in (open-input-file file)))
    (dynamic-wind
      (lambda () (current-input-port tmp-in))
      (lambda () (let ((res (thunk))) (close-input-port tmp-in) res))
      (lambda () (current-input-port old-in)))))

(define (with-output-to-file file thunk)
  (let ((old-out (current-output-port))
        (tmp-out (open-output-file file)))
    (dynamic-wind
      (lambda () (current-output-port tmp-out))
      (lambda () (let ((res (thunk))) (close-output-port tmp-out) res))
      (lambda () (current-output-port old-out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax-rules

(define-syntax syntax-rules
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((ellipsis-specified? (identifier? (cadr expr)))
           (count 0)
           (_er-macro-transformer (rename 'er-macro-transformer))
           (_lambda (rename 'lambda))      (_let (rename 'let))
           (_begin (rename 'begin))        (_if (rename 'if))
           (_and (rename 'and))            (_or (rename 'or))
           (_eq? (rename 'eq?))            (_equal? (rename 'equal?))
           (_car (rename 'car))            (_cdr (rename 'cdr))
           (_cons (rename 'cons))          (_pair? (rename 'pair?))
           (_null? (rename 'null?))        (_expr (rename 'expr))
           (_rename (rename 'rename))      (_compare (rename 'compare))
           (_quote (rename 'syntax-quote)) (_apply (rename 'apply))
           (_append (rename 'append))      (_map (rename 'map))
           (_vector? (rename 'vector?))    (_list? (rename 'list?))
           (_len (rename'len))             (_length (rename 'length*))
           (_- (rename '-))   (_>= (rename '>=))   (_error (rename 'error))
           (_ls (rename 'ls)) (_res (rename 'res)) (_i (rename 'i))
           (_reverse (rename 'reverse))
           (_vector->list (rename 'vector->list))
           (_list->vector (rename 'list->vector))
           (_cons3 (rename 'cons-source)))
       (define ellipsis (rename (if ellipsis-specified? (cadr expr) '...)))
       (define lits (if ellipsis-specified? (car (cddr expr)) (cadr expr)))
       (define forms (if ellipsis-specified? (cdr (cddr expr)) (cddr expr)))
       (define (next-symbol s)
         (set! count (+ count 1))
         (rename (string->symbol (string-append s (%number->string count)))))
       (define (expand-pattern pat tmpl)
         (let lp ((p (cdr pat))
                  (x (list _cdr _expr))
                  (dim 0)
                  (vars '())
                  (k (lambda (vars)
                       (list _cons (expand-template tmpl vars) #f))))
           (let ((v (next-symbol "v.")))
             (list
              _let (list (list v x))
              (cond
               ((identifier? p)
                (if (any (lambda (l) (compare p l)) lits)
                    (list _and
                          (list _compare v (list _rename (list _quote p)))
                          (k vars))
                    (list _let (list (list p v)) (k (cons (cons p dim) vars)))))
               ((ellipsis? p)
                (cond
                 ((not (null? (cdr (cdr p))))
                  (cond
                   ((any (lambda (x) (and (identifier? x) (compare x ellipsis)))
                         (cddr p))
                    (error "multiple ellipses" p))
                   (else
                    (let ((len (length* (cdr (cdr p))))
                          (_lp (next-symbol "lp.")))
                      `(,_let ((,_len (,_length ,v)))
                         (,_and (,_>= ,_len ,len)
                                (,_let ,_lp ((,_ls ,v)
                                             (,_i (,_- ,_len ,len))
                                             (,_res (,_quote ())))
                                  (,_if (,_>= 0 ,_i)
                                      ,(lp `(,(cddr p) 
                                             (,(car p) ,(car (cdr p))))
                                           `(,_cons ,_ls
                                                    (,_cons (,_reverse ,_res)
                                                            (,_quote ())))
                                           dim
                                           vars
                                           k)
                                      (,_lp (,_cdr ,_ls)
                                            (,_- ,_i 1)
                                            (,_cons3 (,_car ,_ls)
                                                     ,_res
                                                     ,_ls))))))))))
                 ((identifier? (car p))
                  (list _and (list _list? v)
                        (list _let (list (list (car p) v))
                              (k (cons (cons (car p) (+ 1 dim)) vars)))))
                 (else
                  (let* ((w (next-symbol "w."))
                         (_lp (next-symbol "lp."))
                         (new-vars (all-vars (car p) (+ dim 1)))
                         (ls-vars (map (lambda (x)
                                         (next-symbol
                                          (string-append
                                           (symbol->string
                                            (identifier->symbol (car x)))
                                           "-ls")))
                                       new-vars))
                         (once
                          (lp (car p) (list _car w) (+ dim 1) '()
                              (lambda (_)
                                (cons
                                 _lp
                                 (cons
                                  (list _cdr w)
                                  (map (lambda (x l)
                                         (list _cons (car x) l))
                                       new-vars
                                       ls-vars)))))))
                    (list
                     _let
                     _lp (cons (list w v)
                               (map (lambda (x) (list x (list _quote '()))) ls-vars))
                     (list _if (list _null? w)
                           (list _let (map (lambda (x l)
                                             (list (car x) (list _reverse l)))
                                           new-vars
                                           ls-vars)
                                 (k (append new-vars vars)))
                           (list _and (list _pair? w) once)))))))
               ((pair? p)
                (list _and (list _pair? v)
                      (lp (car p)
                          (list _car v)
                          dim
                          vars
                          (lambda (vars)
                            (lp (cdr p) (list _cdr v) dim vars k)))))
               ((vector? p)
                (list _and
                      (list _vector? v)
                      (lp (vector->list p) (list _vector->list v) dim vars k)))
               ((null? p) (list _and (list _null? v) (k vars)))
               (else (list _and (list _equal? v p) (k vars))))))))
       (define (ellipsis-escape? x) (and (pair? x) (compare ellipsis (car x))))
       (define (ellipsis? x)
         (and (pair? x) (pair? (cdr x)) (compare ellipsis (cadr x))))
       (define (ellipsis-depth x)
         (if (ellipsis? x)
             (+ 1 (ellipsis-depth (cdr x)))
             0))
       (define (ellipsis-tail x)
         (if (ellipsis? x)
             (ellipsis-tail (cdr x))
             (cdr x)))
       (define (all-vars x dim)
         (let lp ((x x) (dim dim) (vars '()))
           (cond ((identifier? x)
                  (if (any (lambda (lit) (compare x lit)) lits)
                      vars
                      (cons (cons x dim) vars)))
                 ((ellipsis? x) (lp (car x) (+ dim 1) (lp (cddr x) dim vars)))
                 ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
                 ((vector? x) (lp (vector->list x) dim vars))
                 (else vars))))
       (define (free-vars x vars dim)
         (let lp ((x x) (free '()))
           (cond
            ((identifier? x)
             (if (and (not (memq x free))
                      (cond ((assq x vars) => (lambda (cell) (>= (cdr cell) dim)))
                            (else #f)))
                 (cons x free)
                 free))
            ((pair? x) (lp (car x) (lp (cdr x) free)))
            ((vector? x) (lp (vector->list x) free))
            (else free))))
       (define (expand-template tmpl vars)
         (let lp ((t tmpl) (dim 0))
           (cond
            ((identifier? t)
             (cond
              ((find (lambda (v) (compare t (car v))) vars)
               => (lambda (cell)
                    (if (<= (cdr cell) dim)
                        t
                        (error "too few ...'s"))))
              (else
               (list _rename (list _quote t)))))
            ((pair? t)
             (cond
              ((ellipsis-escape? t)
               (list _quote
                     (if (pair? (cdr t))
                         (if (pair? (cddr t)) (cddr t) (cadr t))
                         (cdr t))))
              ((ellipsis? t)
               (let* ((depth (ellipsis-depth t))
                      (ell-dim (+ dim depth))
                      (ell-vars (free-vars (car t) vars ell-dim)))
                 (cond
                  ((null? ell-vars)
                   (error "too many ...'s"))
                  ((and (null? (cdr (cdr t))) (identifier? (car t)))
                   ;; shortcut for (var ...)
                   (lp (car t) ell-dim))
                  (else
                   (let* ((once (lp (car t) ell-dim))
                          (nest (if (and (null? (cdr ell-vars))
                                         (identifier? once)
                                         (eq? once (car vars)))
                                    once ;; shortcut
                                    (cons _map
                                          (cons (list _lambda ell-vars once)
                                                ell-vars))))
                          (many (do ((d depth (- d 1))
                                     (many nest
                                           (list _apply _append many)))
                                    ((= d 1) many))))
                     (if (null? (ellipsis-tail t))
                         many ;; shortcut
                         (list _append many (lp (ellipsis-tail t) dim))))))))
              (else (list _cons3 (lp (car t) dim) (lp (cdr t) dim) (list _quote t)))))
            ((vector? t) (list _list->vector (lp (vector->list t) dim)))
            ((null? t) (list _quote '()))
            (else t))))
       (list
        _er-macro-transformer
        (list _lambda (list _expr _rename _compare)
              (list
               _car
               (cons
                _or
                (append
                 (map
                  (lambda (clause) (expand-pattern (car clause) (cadr clause)))
                  forms)
                 (list
                  (list _cons
                        (list _error "no expansion for"
                              (list (rename 'strip-syntactic-closures) _expr))
                        #f)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; additional syntax

(define-syntax syntax-error
  (er-macro-transformer
   (lambda (expr rename compare)
     (apply error (cdr expr)))))

(define-syntax letrec*
  (syntax-rules ()
    ((letrec* ((var val) ...) . body)
     (let () (define var val) ... . body))))

(define-syntax let-optionals*
  (syntax-rules ()
    ((let-optionals* opt-ls () . body)
     (begin . body))
    ((let-optionals* (op . args) vars . body)
     (let ((tmp (op . args)))
       (let-optionals* tmp vars . body)))
    ((let-optionals* tmp ((var default) . rest) . body)
     (let ((var (if (pair? tmp) (car tmp) default))
           (tmp2 (if (pair? tmp) (cdr tmp) '())))
       (let-optionals* tmp2 rest . body)))
    ((let-optionals* tmp tail . body)
     (let ((tail tmp)) . body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; exceptions

;; We wrap continuable objects in specially marked exceptions.
(define (raise-continuable exn)
  (raise (make-exception 'continuable "" exn #f #f)))

(cond-expand
 (threads
  (define (%with-exception-handler handler thunk)
    (let* ((old (thread-parameters))
           (new (cons (cons current-exception-handler handler) old)))
      (dynamic-wind
        (lambda () (thread-parameters-set! new))
        thunk
        (lambda () (thread-parameters-set! old))))))
 (else
  (define (%with-exception-handler handler thunk)
    (let ((old (current-exception-handler)))
      (dynamic-wind
        (lambda () (current-exception-handler handler))
        thunk
        (lambda () (current-exception-handler old)))))))

(define (with-exception-handler handler thunk)
  (letrec ((orig-handler (current-exception-handler))
           (self (lambda (exn)
                   (%with-exception-handler orig-handler
                     (lambda ()
                       (cond
                        ((and (exception? exn)
                              (eq? 'continuable (exception-kind exn)))
                         (handler (exception-irritants exn)))
                        (else
                         (handler exn)
                         (error "exception handler returned"))))))))
    (%with-exception-handler self thunk)))

(define-syntax protect
  (syntax-rules ()
    ((protect (var clause ...) e1 e2 ...)
     (let ((orig-handler (current-exception-handler)))
       (call-with-current-continuation
        (lambda (protect-k)
          (with-exception-handler
           (lambda (condition)
             (let ((var condition))  ; clauses may set! var
               (protect-k
                (protect-aux (raise-continuable condition) clause ...))))
           (lambda () e1 e2 ...))))))))

(define-syntax protect-aux
  (syntax-rules (else =>)
    ((protect-aux reraise (else result1 result2 ...))
     (begin result1 result2 ...))
    ((protect-aux reraise (test => result))
     (let ((temp test))
       (if temp (result temp) reraise)))
    ((protect-aux reraise (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp (result temp) (protect-aux reraise clause1 clause2 ...))))
    ((protect-aux reraise (test))
     (or test reraise))
    ((protect-aux reraise (test) clause1 clause2 ...)
     (or test (protect-aux reraise clause1 clause2 ...)))
    ((protect-aux reraise (test result1 result2 ...))
     (if test (begin result1 result2 ...) reraise))
    ((protect-aux reraise (test result1 result2 ...) clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (protect-aux reraise clause1 clause2 ...)))))

;; Similar to unwind-protect, but allows escape via continuations
;; assuming they'll return, whereas exceptions are assumed to not return.
(define (with-exception-protect thunk final)
  (let* ((finalized? #f)
         (run-finalize
          (lambda ()
            (cond ((not finalized?)
                   (set! finalized? #t)
                   (final))))))
    (protect (exn (else (run-finalize) (raise exn)))
      (let ((res (thunk)))
        (run-finalize)
        res))))

(define-syntax exception-protect
  (syntax-rules ()
    ((exception-protect expr final)
     (with-exception-protect (lambda () expr)  (lambda () final)))))

(define (eval x . o)
  (let ((thunk (compile x (if (pair? o) (car o) (interaction-environment)))))
    (if (procedure? thunk) (thunk) (raise thunk))))

(define (load file . o)
  (let* ((env (if (pair? o) (car o) (interaction-environment)))
         (len (string-length file))
         (ext *shared-object-extension*)
         (ext-len (string-length ext)))
    (cond
     ((and (> len ext-len 0) (equal? ext (substring file (- len ext-len))))
      (%load file env))
     (else
      (let ((old-env (current-environment)))
        (dynamic-wind
          (lambda () (set-current-environment! env))
          (lambda ()
            (call-with-input-file file
              (lambda (in)
                (set-port-line! in 1)
                (let lp ()
                  (let ((x (read in)))
                    (cond
                     ((not (eof-object? x))
                      (eval x env)
                      (lp))))))))
          (lambda () (set-current-environment! old-env))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; promises

(cond-expand
 (auto-force
  )
 (else
  (define (promise done? proc)
    (list (cons done? proc)))
  (define (promise-done? x) (car (car x)))
  (define (promise-value x) (cdr (car x)))
  (define (promise-update! new old)
    (set-car! (car old) (promise-done? new))
    (set-cdr! (car old) (promise-value new))
    (set-car! new (car old)))
  (define (force promise)
    (if (promise-done? promise)
        (promise-value promise)
        (let ((promise* ((promise-value promise))))
          (if (not (promise-done? promise))
            (promise-update! promise* promise))
          (force promise))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; math utils

(cond-expand
 (complex
  (define (exact-complex? x)
    (and (%complex? x) (exact? (complex-real x)) (exact? (complex-imag x)))))
 (else
  (define (exact-complex? x) #f)))

(cond-expand
 (ratios
  (cond-expand
   (complex
    (define (exact? x)
      (if (fixnum? x)
          #t
          (if (bignum? x) #t (if (ratio? x) #t (exact-complex? x))))))
   (else
    (define (exact? x) (if (fixnum? x) #t (if (bignum? x) #t (ratio? x))))))
  (define (numerator x)
    (if (ratio? x)
        (ratio-numerator x)
        (if (inexact? x)
            (exact->inexact (numerator (inexact->exact x)))
            x)))
  (define (denominator x)
    (if (exact? x)
        (if (ratio? x) (ratio-denominator x) 1)
        (if (integer? x)
            1.0
            (exact->inexact (denominator (inexact->exact x)))))))
 (else
  (cond-expand
   (complex
    (define (exact? x)
      (if (fixnum? x) #t (if (bignum? x) #t (exact-complex? x)))))
   (else
    (define (exact? x) (if (fixnum? x) #t (bignum? x)))))
  (define (numerator x)
    (if (integer? x) x (numerator (* x 10))))
  (define (denominator x)
    (if (exact? x)
        1
        (let lp ((x x) (r 1.0)) (if (integer? x) r (lp (* x 10) (* r 10))))))))

(cond-expand
 (complex
  (define (inexact? x)
    (if (flonum? x) #t (and (%complex? x) (not (exact-complex? x))))))
 (else (define inexact? flonum?)))
(define (exact-integer? x) (if (fixnum? x) #t (bignum? x)))
(define (integer? x)
  (if (exact-integer? x) #t (and (flonum? x) (= x (truncate x)))))
(define (number? x) (if (inexact? x) #t (exact? x)))
(define complex? number?)
(cond-expand
 (complex (define (real? x) (and (number? x) (not (%complex? x)))))
 (else (define real? number?)))
(define (rational? x)
  (and (real? x) (= x x) (not (= x (+ x (if (positive? x) 1 -1))))))

(define (eqv? a b) (if (eq? a b) #t (and (number? a) (equal? a b))))

(define (zero? x) (= x 0))
(define (positive? x) (> x 0))
(define (negative? x) (< x 0))
(define (even? n) (= (remainder n 2) 0))
(define (odd? n) (not (= (remainder n 2) 0)))

(define (abs x) (if (< x 0) (- x) x))

(define (modulo a b)
  (let ((res (remainder a b)))
    (if (< b 0)
        (if (<= res 0) res (+ res b))
        (if (>= res 0) res (+ res b)))))

(define (gcd2 a b)
  (if (= b 0)
      (abs a)
      (gcd b (remainder a b))))

(define (gcd . args)
  (if (null? args)
      0
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (gcd2 x (car ls)) (cdr ls))))))

(define (lcm2 a b)
  (abs (quotient (* a b) (gcd a b))))

(define (lcm . args)
  (if (null? args)
      1
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (lcm2 x (car ls)) (cdr ls))))))

(define (max x . rest)
  (define (~max hi ls)
    (if (null? ls)
        (exact->inexact hi)
        (~max (if (> (car ls) hi) (car ls) hi) (cdr ls))))
  (if (inexact? x)
      (~max x rest)
      (let lp ((hi x) (ls rest))
        (cond ((null? ls) hi)
              ((inexact? (car ls)) (~max hi ls))
              (else (lp (if (> (car ls) hi) (car ls) hi) (cdr ls)))))))

(define (min x . rest)
  (define (~min lo ls)
    (if (null? ls)
        (exact->inexact lo)
        (~min (if (< (car ls) lo) (car ls) lo) (cdr ls))))
  (if (inexact? x)
      (~min x rest)
      (let lp ((lo x) (ls rest))
        (cond ((null? ls) lo)
              ((inexact? (car ls)) (~min lo ls))
              (else (lp (if (< (car ls) lo) (car ls) lo) (cdr ls)))))))

(cond-expand
 (complex
  (define (real-part z) (if (%complex? z) (complex-real z) z))
  (define (imag-part z) (if (%complex? z) (complex-imag z) 0))
  (define (magnitude z)
    (sqrt (+ (* (real-part z) (real-part z))
             (* (imag-part z) (imag-part z)))))
  (define (angle z) (atan (imag-part z) (real-part z)))
  (define (make-rectangular x y)
    (+ x (* y (sqrt -1))))
  (define (make-polar r phi)
    (make-rectangular (* r (cos phi)) (* r (sin phi)))))
 (else
  (define (real-part z) z)
  (define (imag-part z) 0.0)
  (define magnitude abs)
  (define (angle z) (if (< z 0) 3.141592653589793 0))))

(define (log x . o)
  (if (pair? o) (/ (ln x) (ln (car o))) (ln x)))

(define (atan y . o)
  (define (inf? z) (if (= +inf.0 z) #t (= -inf.0 z)))
  (if (null? o)
      (atan1 y)
      (let ((x (exact->inexact (car o))))
        (if (and (inf? x) (inf? y))
            (* (if (< y 0) -1 1) (if (= x -inf.0) 3 1) 0.7853981633974483)
            (if (negative? x)
                (if (or (negative? y) (eqv? y -0.0))
                    (- (atan1 (/ y x)) 3.141592653589793)
                    (- 3.141592653589793 (atan1 (/ y (- x)))))
                (if (and (zero? x) (zero? y))
                    (* (if (eqv? y -0.0) -1 1)
                       (if (eqv? x -0.0) 3.141592653589793 x))
                    (atan1 (/ y x))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string cursors

(define string-cursor<? <)
(define string-cursor<=? <=)
(define string-cursor>? >)
(define string-cursor>=? >=)
(define string-cursor=? =)

(define (string-cursor-start s) 0)

(define (string-copy str . o)
  (apply substring str (if (pair? o) o '(0))))

(cond-expand
 (full-unicode
  (define string-cursor-end string-size))
 (else
  (define (string-index->offset str i) i)
  (define (string-offset->index str off) off)
  (define string-size string-length)
  (define substring-cursor substring)
  (define string-cursor-end string-length)
  (define string-cursor-ref string-ref)
  (define (string-cursor-next s i) (+ i 1))
  (define (string-cursor-prev s i) (- i 1))))
